

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Yang Qiu">
  <meta name="keywords" content="">
  
    <meta name="description" content="综合面经JAVAJAVA基础基础概念和常识JAVA有哪些特点 简单易学 面向对象（封装，继承，多态） 跨平台（因为跑在虚拟机上） 支持多线程 解释与编译并存  JVM，jdk，jre的区别 JVM是运行java字节码文件的虚拟机。jvm有针对不同操作系统的实现，因此诞生了java跨平台可移植的特性，简单来说就是解决了java一次编译，随处运行的特点。常见的jvm是HotSpot VM，当然还有各种">
<meta property="og:type" content="article">
<meta property="og:title" content="面经">
<meta property="og:url" content="https://swustcoder.github.io/2023/12/26/%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="木易禾火">
<meta property="og:description" content="综合面经JAVAJAVA基础基础概念和常识JAVA有哪些特点 简单易学 面向对象（封装，继承，多态） 跨平台（因为跑在虚拟机上） 支持多线程 解释与编译并存  JVM，jdk，jre的区别 JVM是运行java字节码文件的虚拟机。jvm有针对不同操作系统的实现，因此诞生了java跨平台可移植的特性，简单来说就是解决了java一次编译，随处运行的特点。常见的jvm是HotSpot VM，当然还有各种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/compiled-and-interpreted-languages.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-1ae0425ce8646adfb768b5374951eeb820d.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413175809959.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413180021072.png">
<meta property="og:image" content="https://oss.javaguide.cn/javaguide/image-20210817142715396.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/a478c74d-2c48-40ae-9374-87aacf05188c.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.8_hashmap.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87-Windows.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm2.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-release-lock-block.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/reentrantlock-class-diagram.png">
<meta property="og:image" content="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-d54a5992.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-inner-threadpool.png">
<meta property="og:image" content="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-d65f3309.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadpoolexecutor-methods.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/meituan-dynamically-configuring-thread-pool-parameters.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/tools/maven/mvnrepository.com.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/tools/maven/maven-plugins.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/tools/maven/dubbo-maven-multi-module.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200831175708.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/062b422bd7ac4d53afd28fb74b2bc94d.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/24bc2bad3ce28144d60d9e0a2edf6c7f.jpg">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/image-20210809181452421.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/159b3d3e70dd45e6afa81bf06d09264e.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/mvc-mode1.png">
<meta property="og:image" content="https://oss.javaguide.cn/java-guide-blog/mvc-model2.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/image-20220728201854641.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/image-20220728183540954.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/63e13d91922d4b78a72d30daba24ea92.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8d44ab6c91934eb986458647870bc4de.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/bfa052c973a34634baca758fb42c55fb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4a845e6cf73248c688d43ac8a00bc069.png">
<meta property="og:image" content="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510090309427.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/mysql/innodb-myisam-performance-comparison.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/database/mysql20210513092328171.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/database/mysql20210513092224836.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/open-source-project/cluster-index.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/open-source-project/no-cluster-index.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/database/mysql20210420165311654.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/database/mysql20210420165326946.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/database/mysql20210420165341868.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/mysql/not-using-covering-index-demo.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/mysql/using-covering-index-demo.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/37e4378d2edcb5e217b00e5f12973efd.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E6%80%A7%E8%83%BD.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7-20230309232240301.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/337021a153944fd0f964ca834e34d0f2-20230309232243363.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea-20230309232249413.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/723d6c580c05400b3841bc69566dd61b-20230309232257343.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309232301042.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/c34a9d1f58d602ff1fe8601f7270baa7-20230309232304226.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/ebd620db8a1af66fbeb8f4d4ef6adc68-20230309232308604.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/f67379b60d151262753fec3b817b8617-20230309232312657.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/26f88373d8454682b9e0c1d4fd1611b4.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%98%A0%E5%B0%84%E5%88%86%E5%B8%83%E5%85%B3%E7%B3%BB.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/e2b8d2eb5536aa71664772457792ec40.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/acb5f4e7ef24a524a53c39eb016f63d4.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/b7031182f770a7a5b3c82eaf749f53b0.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/6e3db3ba2f829ddc14237f5c7c00e7ce-20230309232338149.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/cc208c2931b4e889d1a58cb655537767-20230309232342573.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/1cc7401143e79383ead96582ac11b615-20230309232407419.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/WriteThrough.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/writeback.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/2a2ea2854bbc3ae8ae86d7da45fa32ee.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/a4440f0d572612e0832b903e4a62bd2b.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/2ee2280e9f59b6b4879ebdec6eb0cf52.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%E5%9B%9E%E6%BB%9A.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.1-vs-http2.0.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http2.0-vs-http3.0.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/c9ea9b844e87bcd4acd3e320403ecab3.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/3a81c23ce57c27cf63fc2b77e34de0ab-20230309230604522.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/internet_protocol_ip_address_diagram.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/Figure-1-IPv4Addressformatwithdotteddecimalnotation-29c824f6a451d48d8c27759799f0c995.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/Figure-2-IPv6Addressformatwithhexadecimalnotation-7da3a419bd81627a9b2cef3b0efb4940.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-address-translation.png">
<meta property="og:image" content="https://javaguide.cn/assets/2008410143049281-3c367990.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/34.jpg">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/35.jpg">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/843fd07074874ee0b695eca659411b42~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7547a145adf9404aa3a05f01f5ca2e32~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b3d2d4dc8f24890b5957df1c7d6feb8~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39355a1ea404323a11ca6644e009183~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff1daddcec44d61994f254e664987b4~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23dbbc8243a84ed181e088e38bffb37a~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa64869551d94c8d89fa80eaf4395bfa~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97ea11a212924900b10d159226783887~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69b74e63981472b852797f2fa08976f~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b7d6fca78b45c8840c12411b717f2f~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef81cb5e2f0a4d3d9ac5a44ecf97e3cc~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1a3dbf87e3e41ff894f39512a10f66d~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1481f0409da94ba6bb0fee69bf0996f8~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dde4b76be6240699312d822a3fe1ed3~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://oss.javaguide.cn/2020-8/Kernel_Layout.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/usermode-and-kernelmode.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/the-way-switch-between-user-mode-and-kernel-mode.drawio.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call-procedure.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/state-transition-of-process.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/network/scheduling-algorithms-of-process.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/process-resource-allocation-diagram.jpg">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux-buddy-system.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/buddy-system-memory-waste.png">
<meta property="og:image" content="https://oss.javaguide.cn/xingqiu/virtual-memory.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-virtual-address-composition.png">
<meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/6142bc3c917e4a6298bdb62936e0d332.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/disk-scheduling-algorithms.png">
<meta property="og:image" content="https://javaguide.cn/assets/%E6%96%87%E4%BB%B6inode%E4%BF%A1%E6%81%AF-d9175a2d.png">
<meta property="og:image" content="https://swustcoder.github.io/assets/Linux%E7%9B%AE%E5%BD%95%E6%A0%91-b82202fa.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux/linux-command-search.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux/shell-now.png">
<meta property="og:image" content="https://swustcoder.github.io/assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB-7c1098a0.png">
<meta property="article:published_time" content="2023-12-26T14:16:21.923Z">
<meta property="article:modified_time" content="2023-12-26T14:18:19.934Z">
<meta property="article:author" content="Yang Qiu">
<meta property="article:tag" content="Mysql">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JDBC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png">
  
  
  
  <title>面经 - 木易禾火</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"swustcoder.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"BXibcoTbCapgOKboPyfaCvEg-gzGzoHsz","app_key":"AXnipJlPBAZletGKKHdttapq","server_url":"https://bxibcotb.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>木易禾火</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面经"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Yang Qiu
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-26 22:16" pubdate>
          2023年12月26日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          239k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1992 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面经</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="综合面经"><a href="#综合面经" class="headerlink" title="综合面经"></a>综合面经</h1><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><h4 id="基础概念和常识"><a href="#基础概念和常识" class="headerlink" title="基础概念和常识"></a>基础概念和常识</h4><h5 id="JAVA有哪些特点"><a href="#JAVA有哪些特点" class="headerlink" title="JAVA有哪些特点"></a>JAVA有哪些特点</h5><ol>
<li>简单易学</li>
<li><strong>面向对象</strong>（封装，继承，多态）</li>
<li><strong>跨平台</strong>（因为跑在虚拟机上）</li>
<li><strong>支持多线程</strong></li>
<li>解释与编译并存</li>
</ol>
<h5 id="JVM，jdk，jre的区别"><a href="#JVM，jdk，jre的区别" class="headerlink" title="JVM，jdk，jre的区别"></a>JVM，jdk，jre的区别</h5><ol>
<li>JVM是运行java字节码文件的虚拟机。jvm有针对不同操作系统的实现，因此诞生了java跨平台可移植的特性，简单来说就是解决了java一次编译，随处运行的特点。常见的jvm是HotSpot VM，当然还有各种不同的JVM实现如J9 VM、Zing VM、JRockit VM 等 JVM</li>
<li>jdk是 Java Development Kit的缩写，他是功能齐全的java sdk，包含jre，javac（java编译器）和各种工具，可以创建和编译java程序。</li>
<li>JRE是java运行时环境，拥有并包含JVM，java类库，java命令和一些其他的基础构件。但是jre不能创建新程序。简单来说，如果只是运行一下java程序，你们一个jre就足够了，但如果要进行java编程，就必须下载jdk。</li>
</ol>
<h5 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h5><p>简单来说，jdk可以理解的代码就叫做字节码（.class），字节码不面向处理器，只面向虚拟机。java使用字节码，一定程度上解决了解释性语言效率低的问题，同时有保留了解释性语言可移植的特点。</p>
<p><strong>Java 程序从源代码到运行的过程如下图所示</strong> ：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code-with-jit.png" srcset="/img/loading.gif" lazyload alt="Java程序转变为机器代码的过程"></p>
<p>也可以说是这样</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-code-to-machine-code.png" srcset="/img/loading.gif" lazyload alt="Java程序转变为机器代码的过程"></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
<p>JDK、JRE、JVM、JIT 这四者的关系如下图所示。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-jre-jvm-jit.png" srcset="/img/loading.gif" lazyload alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
<h5 id="为什么说java是编译与解释并存"><a href="#为什么说java是编译与解释并存" class="headerlink" title="为什么说java是编译与解释并存"></a>为什么说java是编译与解释并存</h5><p>首先要理解什么是解释型，什么是编译型</p>
<ul>
<li><strong>编译型</strong> 编译型语言会通过编译器将源代码一次性编为可被平台执行的机器码。一般情况下，编译语言的执行速度快，但是开发效率低。常见编译语言有C，C++，GO，RUST等</li>
<li><strong>解释型</strong> 解释型语言会通过解释器将代码一句句解释为机器代码后再执行，解释型代码一般开发快，但是执行效率低。常见的解释型语言有 Python，javascript，PHP等。<img src="https://oss.javaguide.cn/github/javaguide/java/basis/compiled-and-interpreted-languages.png" srcset="/img/loading.gif" lazyload alt="编译型语言和解释型语言"></li>
</ul>
<p><strong>为什么说java是解释与编译并存呢</strong></p>
<p>因为java程序先编译，后解释两个步骤。由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="注释有哪几种"><a href="#注释有哪几种" class="headerlink" title="注释有哪几种"></a>注释有哪几种</h5><p>有三种注释</p>
<ol>
<li><p>单行注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//单行注释</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*这是多行注释</span><br><span class="hljs-comment">*/</span>文档注释<br></code></pre></td></tr></table></figure>
</li>
<li><p>文档注释</p>
</li>
</ol>
<h5 id="标识符和关键字的区别"><a href="#标识符和关键字的区别" class="headerlink" title="标识符和关键字的区别"></a>标识符和关键字的区别</h5><p>简单说，给java程序中的变量，方法，类等取的名字就是标识符，关键字是java中一些特殊的标识符。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。</p>
<h5 id="java有哪些关键字"><a href="#java有哪些关键字" class="headerlink" title="java有哪些关键字"></a>java有哪些关键字</h5><ul>
<li><p><strong>访问控制</strong></p>
<p>private，protected，public。</p>
</li>
<li><p><strong>类，方法和变量修饰符</strong></p>
<p>abstract，class，extends，final，new,static,strictfp,synchronized</p>
</li>
<li><p><strong>程序控制</strong></p>
<p>break，continue，return，do，for，instanceof，switch，case</p>
</li>
<li><p><strong>错误处理</strong></p>
<p>try，catch，throw，throws</p>
</li>
<li><p><strong>包相关</strong></p>
<p>import，package</p>
</li>
<li><p><strong>基本类型</strong></p>
<p>boolean，byte，char，double，short</p>
</li>
<li><p><strong>变量引用</strong></p>
<p>super，this，void</p>
</li>
<li><p><strong>保留字</strong></p>
</li>
</ul>
<p>​       goto,const</p>
<h5 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h5><p>Java 中有三种移位运算符：</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li>
<li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li>
</ul>
<p>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</p>
<p>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p>
<p><strong>如果移位的位数超过数值所占有的位数会怎样？</strong></p>
<p>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</p>
<p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p>
<h5 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h5><ul>
<li>continue：跳出当前运行的循环，执行下一次循环（条件满足的情况下）</li>
<li>break：跳出整个循环。继续执行外层循环（如果有外层）</li>
<li>return：跳出方法并返回相应值</li>
</ul>
<h5 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h5><ul>
<li><p><strong>语法形式</strong>：成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code>等修饰符修饰，而局部变量不能被访问修饰符修饰。但是成员变量和局部变量都可以被<code>final</code>修饰</p>
</li>
<li><p><strong>存储方式</strong>: 如果成员变量被static修饰，那么这个变量就属于整个类，而局部变量存在于栈内存中</p>
</li>
<li><p><strong>生存时间</strong>：成员变量属于对象，随着对象诞生而诞生，而局部变量由方法产生，随着方法结束而消亡</p>
</li>
<li><p><strong>默认值</strong>： 成员变量如果没有被赋初始值，那么会被自动赋予改类型的空值（final变量必须显式的赋初始值）</p>
</li>
</ul>
<h5 id="静态变量有什么作用？"><a href="#静态变量有什么作用？" class="headerlink" title="静态变量有什么作用？"></a>静态变量有什么作用？</h5><p>静态变量可以被该类所有实例共享，换言之，无论创建多少对象，只会有一个静态变量。</p>
<h5 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h5><ol>
<li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
</li>
<li><p>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
</li>
</ol>
<h5 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h5><ol>
<li><p><strong>调用方式</strong>： 静态方法可以使用<code>对象.方法</code>调用，也可以使用 <code>类.方法</code>调用，但是实例方法只能使用<code>对象.方法调用</code>。</p>
<blockquote>
<p>静态方法不推荐使用<code>对象.方法</code>调用，因为静态方法是属于整个类的，避免混淆</p>
</blockquote>
</li>
<li><p><strong>访问类成员</strong>：静态方法只能访问静态成员（也就是静态方法和静态变量）</p>
</li>
</ol>
<h5 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h5><p><strong>重载</strong>： 重载是发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。换言之，<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理</strong></p>
<p><strong>重写</strong>：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li><p>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
</li>
<li><p>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
</ol>
<p>换言之，<strong>重写就是对父类的方法进行改造，外部样式不能改变，内部逻辑可以改变</strong></p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">发生范围</td>
<td align="left">同一个类</td>
<td align="left">子类</td>
</tr>
<tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可修改</td>
<td align="left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可修改</td>
<td align="left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td align="left">访问修饰符</td>
<td align="left">可修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="left">发生阶段</td>
<td align="left">编译期</td>
<td align="left">运行期</td>
</tr>
</tbody></table>
<h5 id="什么是可变长参数？"><a href="#什么是可变长参数？" class="headerlink" title="什么是可变长参数？"></a>什么是可变长参数？</h5><p>所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(String arg1, String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="可变长参数遇到方法重载怎么办？"><a href="#可变长参数遇到方法重载怎么办？" class="headerlink" title="可变长参数遇到方法重载怎么办？"></a>可变长参数遇到方法重载怎么办？</h5><p>答案是会优先匹配固定参数的方法</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><h5 id="java有哪些基本数据类型"><a href="#java有哪些基本数据类型" class="headerlink" title="java有哪些基本数据类型"></a>java有哪些基本数据类型</h5><p>java有八大基本数据类型</p>
<ul>
<li><p>6种整数类型</p>
<ul>
<li><p>4种整型</p>
<p><code>byte</code></p>
<p><code>short</code></p>
<p><code>int</code></p>
<p><code>long</code></p>
</li>
<li><p>2种浮点型</p>
<p><code>double</code></p>
<p><code>float</code></p>
</li>
</ul>
</li>
</ul>
<p>对应的取值范围和所占空间大小如下:</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">位数</th>
<th align="left">字节</th>
<th align="left">默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left">8</td>
<td align="left">1</td>
<td align="left">0</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left">16</td>
<td align="left">2</td>
<td align="left">0</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left">32</td>
<td align="left">4</td>
<td align="left">0</td>
<td>-2147483648 ~ 2147483647</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left">64</td>
<td align="left">8</td>
<td align="left">0L</td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left">16</td>
<td align="left">2</td>
<td align="left">‘u0000’</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left">32</td>
<td align="left">4</td>
<td align="left">0f</td>
<td>1.4E-45 ~ 3.4028235E38</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">64</td>
<td align="left">8</td>
<td align="left">0d</td>
<td>4.9E-324 ~ 1.7976931348623157E308</td>
</tr>
<tr>
<td align="left"><code>boolean</code></td>
<td align="left">1</td>
<td align="left"></td>
<td align="left">false</td>
<td>true、false</td>
</tr>
</tbody></table>
<h5 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h5><ul>
<li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>
<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>
</ul>
<h5 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h5><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1ae0425ce8646adfb768b5374951eeb820d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h5><p><strong>什么是自动拆装箱？</strong></p>
<ul>
<li>自动装箱：将基本数据类型转换为包装类型</li>
<li>自动拆箱：将包装类型转换为基本数据类型</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></table></figure>

<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h5 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h5><p>浮点数运算精度丢失代码演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a);<span class="hljs-comment">// 0.100000024</span><br>System.out.println(b);<span class="hljs-comment">// 0.099999905</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>这和计算机存储浮点类型的方式有关，在计算机中，浮点类型的存储方式是<strong>整数部分除二取整，小数部分乘二取整，然后浮点类型数据对转化后的二进制数据进行记录偏移量后存储起来</strong>所以对于一些小数部分数据就无法精确取值，只能取近似值，比如著名的<strong>0.1+0.2!&#x3D;0.3</strong></p>
<h5 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h5><p>上面已经说到了为什么浮点类型会出现精度的丢失问题，那么在java中的常见解决方案就是使用<code>BigDecimal</code>来解决进度丢失的问题，通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>
<h5 id="超过-long-整型的数据应该如何表示？"><a href="#超过-long-整型的数据应该如何表示？" class="headerlink" title="超过 long 整型的数据应该如何表示？"></a>超过 long 整型的数据应该如何表示？</h5><p>依然是采用<code>BigDecimal</code></p>
<p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>
<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><h5 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h5><ul>
<li>面向过程是将问题拆分为不同的方法，通过一个个方法解决问题</li>
<li>面向对象是将问题拆分为不同对象，然后用对象执行方法的方式解决问题</li>
</ul>
<h5 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h5><p>创建一个对象采用<code>new</code>关键字</p>
<p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<p>对象引用和指向对象实例，可以简单理解为用气球表示对象实体，用绳子比喻为对象引用。那么一个气球可以用无数个绳子系住，但是一根绳子只能系住一个气球。</p>
<h5 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h5><ul>
<li>对象的相等一般是比较的内存中存放的内容是否相等</li>
<li>引用相等一般是比较指向的地址是否相等</li>
</ul>
<h5 id="类的构造方法作用"><a href="#类的构造方法作用" class="headerlink" title="类的构造方法作用"></a>类的构造方法作用</h5><p>构造方法是一种特殊的方法，主要是完成对象的初始化工作</p>
<h5 id="没有构造方法程序会报错吗？"><a href="#没有构造方法程序会报错吗？" class="headerlink" title="没有构造方法程序会报错吗？"></a>没有构造方法程序会报错吗？</h5><p>不会</p>
<h5 id="构造方法有哪些特点？可不可以被overwrite？"><a href="#构造方法有哪些特点？可不可以被overwrite？" class="headerlink" title="构造方法有哪些特点？可不可以被overwrite？"></a>构造方法有哪些特点？可不可以被overwrite？</h5><ol>
<li>与类名相同</li>
<li>没有返回值</li>
<li>生成对象时自动执行，无需调用</li>
</ol>
<p>构造方法不能被重写，但是可以被重载。</p>
<h5 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h5><ol>
<li><p><strong>封装</strong>：封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了</p>
</li>
<li><p><strong>继承</strong>：不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
</li>
<li><p><strong>多态</strong>：多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<p><strong>多态的特点:</strong></p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
</li>
</ol>
<h5 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h5><p><strong>共同点</strong></p>
<ul>
<li>都不能被实例化</li>
<li>都可以包含抽象方法</li>
<li>都可以有默认实现的方法</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p>
</li>
<li><p>一个类只能继承一个类，但是可以实现多个接口。</p>
</li>
<li><p>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</p>
</li>
</ul>
<h5 id="深拷贝和浅拷贝的区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝的区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝的区别？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别？什么是引用拷贝？</h5><p><strong>深拷贝</strong>：拷贝对象时，对象内部使用的其他对象同样拷贝一份，也就是说深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><strong>浅拷贝</strong>：拷贝对象时，对象内部的对象只是会被引用到新拷贝出的对象里，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>引用拷贝</strong>：简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png" srcset="/img/loading.gif" lazyload alt="浅拷贝、深拷贝、引用拷贝示意图"></p>
<h4 id="Java-常见类"><a href="#Java-常见类" class="headerlink" title="Java 常见类"></a>Java 常见类</h4><h5 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h5><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure>

<h5 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals() 的区别"></a>&#x3D;&#x3D; 和 equals() 的区别</h5><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>
<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>
<h5 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a>hashCode() 有什么用？</h5><p>hashCode()是获取对象的hash码</p>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是 ：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h5 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h5><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p><strong>总结</strong> ：</p>
<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h5 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h5><p><strong>可变性</strong></p>
<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h5 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h5><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>	<span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>🐛 修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>
<p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
</blockquote>
<h5 id="字符串拼接是用“-”还是“StringBuilder”"><a href="#字符串拼接是用“-”还是“StringBuilder”" class="headerlink" title="字符串拼接是用“+”还是“StringBuilder”"></a>字符串拼接是用“+”还是“StringBuilder”</h5><p>字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    s += arr[i];<br>&#125;<br>System.out.println(s);<br></code></pre></td></tr></table></figure>

<p>当然如果在循环中直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (String value : arr) &#123;<br>    s.append(value);<br>&#125;<br>System.out.println(s);<br></code></pre></td></tr></table></figure>

<p>不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code> 了。这个改进是 JDK9 的 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/280">JEP 280 </a> 提出的，这也意味着 JDK 9 之后，你可以放心使用“+” 进行字符串拼接了。关于这部分改进的详细介绍，推荐阅读这篇文章：还在无脑用 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7182872058743750715">StringBuilder？来重温一下字符串拼接吧 </a> 。</p>
<h5 id="String中的equals（）和-Obje的equals-有何区别？"><a href="#String中的equals（）和-Obje的equals-有何区别？" class="headerlink" title="String中的equals（）和 Obje的equals() 有何区别？"></a>String中的equals（）和 Obje的equals() 有何区别？</h5><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p>
<h5 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h5><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”ab“</span><br><span class="hljs-comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>更多关于字符串常量池的介绍可以看一下 <a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/memory-area.html">Java 内存区域详解 </a> 这篇文章。</p>
<h5 id="String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h5><p>会创建 1 或 2 个字符串对象。</p>
<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p>
<p>示例代码（JDK 1.8）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413175809959.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p>
<p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>
<p>示例代码（JDK 1.8）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串常量池中已存在字符串对象“abc”的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>对应的字节码：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/open-source-project/image-20220413180021072.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里就不对上面的字节码进行详细注释了，7 这个位置的 <code>ldc</code> 命令不会在堆中创建新的字符串对象“abc”，这是因为 0 这个位置已经执行了一次 <code>ldc</code> 命令，已经在堆中创建过一次字符串对象“abc”了。7 这个位置执行 <code>ldc</code> 命令会直接返回字符串常量池中字符串对象“abc”对应的引用。</p>
<h5 id="intern-方法有什么作用"><a href="#intern-方法有什么作用" class="headerlink" title="intern 方法有什么作用?"></a>intern 方法有什么作用?</h5><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>
</ul>
<h5 id="String-类型的变量和常量做“-”运算时发生了什么？"><a href="#String-类型的变量和常量做“-”运算时发生了什么？" class="headerlink" title="String 类型的变量和常量做“+”运算时发生了什么？"></a>String 类型的变量和常量做“+”运算时发生了什么？</h5><p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br>System.out.println(str3 == str4);<span class="hljs-comment">//false</span><br>System.out.println(str3 == str5);<span class="hljs-comment">//true</span><br>System.out.println(str4 == str5);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：</p>
<p><img src="https://oss.javaguide.cn/javaguide/image-20210817142715396.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(str1).append(str2).toString();<br></code></pre></td></tr></table></figure>

<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ing&quot;</span>;<br><span class="hljs-comment">// 下面两个表达式其实是等价的</span><br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<span class="hljs-comment">// 常量池中的对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> str1 + str2; <span class="hljs-comment">// 常量池中的对象</span><br>System.out.println(c == d);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>
<p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> getStr();<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;str&quot;</span> + <span class="hljs-string">&quot;ing&quot;</span>;<span class="hljs-comment">// 常量池中的对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> str1 + str2; <span class="hljs-comment">// 在堆上创建的新的对象</span><br>System.out.println(c == d);<span class="hljs-comment">// false</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getStr</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ing&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>&#x3D;&#x3D;:radioactive:异常的结构图预览&#x3D;&#x3D;</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png" srcset="/img/loading.gif" lazyload alt="Java 异常类层次结构图"></p>
<h5 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h5><ul>
<li>异常Exception是指程序本身可以处理的异常，在遇到这种异常时，线程一般不会终止</li>
<li>Error是指程序运行时的错误，不建议使用try&#x2F;catch来捕获。常见的错误有虚拟机运行错误，虚拟机内存不足等。当程序遇到这种异常时一般会选择程序终止。</li>
</ul>
<h5 id="Checked-Exception和Unchecked-Exception有什么区别？"><a href="#Checked-Exception和Unchecked-Exception有什么区别？" class="headerlink" title="Checked Exception和Unchecked Exception有什么区别？"></a>Checked Exception和Unchecked Exception有什么区别？</h5><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
<h5 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h5><p>正常情况下是会执行的，当然一些扯淡的情况除外（关闭虚拟机，关闭线程，关闭cpu）</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="什么是泛型？有什么作用？"><a href="#什么是泛型？有什么作用？" class="headerlink" title="什么是泛型？有什么作用？"></a>什么是泛型？有什么作用？</h5><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<h5 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h5><p>泛型主要有这三种使用方法</p>
<ul>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实例化泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">( E[] inputArray )</span><br>&#123;<br>      <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>         System.out.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>      &#125;<br>      System.out.println();<br> &#125;<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建不同类型数组： Integer, Double 和 Character</span><br>Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray( intArray  );<br>printArray( stringArray  );<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="项目中哪些地方用到了泛型"><a href="#项目中哪些地方用到了泛型" class="headerlink" title="项目中哪些地方用到了泛型"></a>项目中哪些地方用到了泛型</h5><ul>
<li><p>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</p>
</li>
<li><p>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</p>
</li>
<li><p>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</p>
</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h5 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h5><p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h5 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h5><p>通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h5><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
<h5 id="注解的解析方式"><a href="#注解的解析方式" class="headerlink" title="注解的解析方式"></a>注解的解析方式</h5><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="什么是序列化，什么是返序列化"><a href="#什么是序列化，什么是返序列化" class="headerlink" title="什么是序列化，什么是返序列化"></a>什么是序列化，什么是返序列化</h5><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>下面是序列化和反序列化常见应用场景：</p>
<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<p>维基百科是如是介绍序列化的：</p>
<blockquote>
<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/a478c74d-2c48-40ae-9374-87aacf05188c.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.corejavaguru.com/java/serialization/interview-questions-1">https://www.corejavaguru.com/java/serialization/interview-questions-1</a></p>
<p><strong>序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</strong></p>
<p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP&#x2F;IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" srcset="/img/loading.gif" lazyload alt="TCP/IP 四层模型">TCP&#x2F;IP 四层模型</p>
<p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>
<p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以序列化协议属于 TCP&#x2F;IP 协议应用层的一部分。</p>
<h5 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a>如果有些字段不想进行序列化怎么办？</h5><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>
<p>关于 <code>transient</code> 还有几点注意：</p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul>
<h5 id="常见序列化协议有哪些？"><a href="#常见序列化协议有哪些？" class="headerlink" title="常见序列化协议有哪些？"></a>常见序列化协议有哪些？</h5><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p>
<p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>
<h5 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h5><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>
<ul>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a target="_blank" rel="noopener" href="https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/">应用安全：JAVA 反序列化漏洞之殇 </a> 。</li>
</ul>
<h4 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h4><h5 id="IO流了解吗"><a href="#IO流了解吗" class="headerlink" title="IO流了解吗"></a>IO流了解吗</h5><p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<h3 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h3><h5 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h5><ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<h5 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h5><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h5 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h5><blockquote>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
<p>在 JDK1.8 中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns: true if this set did not already contain the specified element</span><br><span class="hljs-comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns : previous value, or null if none</span><br><span class="hljs-comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也就是说，在 JDK1.8 中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>
<h5 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h5><p>JDK1.8 之前</p>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 <code>hashcode</code> 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 <code>hash</code> 方法。使用 <code>hash</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png" srcset="/img/loading.gif" lazyload alt="jdk1.8 之前的内部结构-HashMap">jdk1.8 之前的内部结构-HashMap</p>
<p>JDK1.8 之后</p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.8_hashmap.png" srcset="/img/loading.gif" lazyload alt="jdk1.8之后的内部结构-HashMap">jdk1.8之后的内部结构-HashMap</p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<p>我们来结合源码分析一下 <code>HashMap</code> 链表到红黑树的转换。</p>
<p><strong>1、 <code>putVal</code> 方法中执行链表转红黑树的判断逻辑。</strong></p>
<p>链表的长度大于 8 的时候，就执行 <code>treeifyBin</code> （转换红黑树）的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 遍历链表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>    <span class="hljs-comment">// 遍历到链表最后一个节点</span><br>    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span><br>        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>            <span class="hljs-comment">// 红黑树转换（并不会直接转换成红黑树）</span><br>            treeifyBin(tab, hash);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>        <span class="hljs-keyword">break</span>;<br>    p = e;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、<code>treeifyBin</code> 方法中判断是否真的转换为红黑树。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 判断当前数组的长度是否小于 64</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        <span class="hljs-comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span><br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 否则才将列表转换为红黑树</span><br><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树。</p>
<h5 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h5><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式（重要）：<ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<p>下面，我们再来看看两者底层数据结构的对比图。</p>
<p><strong>Hashtable</strong> :</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/jdk1.7_hashmap.png" srcset="/img/loading.gif" lazyload alt="Hashtable 的内部结构">Hashtable 的内部结构</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6842045.html%3E">https://www.cnblogs.com/chengxiao/p/6842045.html&gt;</a></p>
<p><strong>JDK1.7 的 ConcurrentHashMap</strong> ：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" srcset="/img/loading.gif" lazyload alt="Java7 ConcurrentHashMap 存储结构">Java7 ConcurrentHashMap 存储结构</p>
<p><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。</p>
<p><code>Segment</code> 数组中的每个元素包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 数组属于链表结构。</p>
<p><strong>JDK1.8 的 ConcurrentHashMap</strong> ：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png" srcset="/img/loading.gif" lazyload alt="Java8 ConcurrentHashMap 存储结构">Java8 ConcurrentHashMap 存储结构</p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 &#x2F; 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<p><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装。<code>TreeBin</code>通过<code>root</code>属性维护红黑树的根结点，因为红黑树在旋转的时候，根结点可能会被它原来的子节点替换掉，在这个时间点，如果有其他线程要写这棵红黑树就会发生线程不安全问题，所以在 <code>ConcurrentHashMap</code> 中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这棵红黑树的线程，来防止其他线程的进入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeBin</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; &#123;<br>        TreeNode&lt;K,V&gt; root;<br>        <span class="hljs-keyword">volatile</span> TreeNode&lt;K,V&gt; first;<br>        <span class="hljs-keyword">volatile</span> Thread waiter;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> lockState;<br>        <span class="hljs-comment">// values for lockState</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WRITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// set while holding write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITER</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">// set when waiting for write lock</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">READER</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; <span class="hljs-comment">// increment value for setting read lock</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</h5><p>JDK1.8 之前</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" srcset="/img/loading.gif" lazyload alt="Java7 ConcurrentHashMap 存储结构">Java7 ConcurrentHashMap 存储结构</p>
<p>首先将数据分为一段一段（这个“段”就是 <code>Segment</code>）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p>
<p>JDK1.8 之后</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png" srcset="/img/loading.gif" lazyload alt="Java8 ConcurrentHashMap 存储结构">Java8 ConcurrentHashMap 存储结构</p>
<p>Java 8 几乎完全重写了 <code>ConcurrentHashMap</code>，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。</p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 <code>Node + CAS + synchronized</code> 来保证并发安全。数据结构跟 <code>HashMap</code> 1.8 的结构类似，数组+链表&#x2F;红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。</p>
<p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>
<h4 id="集合使用注意事项"><a href="#集合使用注意事项" class="headerlink" title="集合使用注意事项"></a>集合使用注意事项</h4><h5 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a>集合判空</h5><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</strong></p>
</blockquote>
<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>…）。</p>
<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> sumCount();<br>    <span class="hljs-keyword">return</span> ((n &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0</span> :<br>            (n &gt; (<span class="hljs-type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :<br>            (<span class="hljs-type">int</span>)n);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] as = counterCells; CounterCell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sumCount() &lt;= <span class="hljs-number">0L</span>; <span class="hljs-comment">// ignore transient negative values</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h5><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String phoneNumber;<br>     <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br>List&lt;Person&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;18163138123&quot;</span>));<br>bookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;martin&quot;</span>,<span class="hljs-literal">null</span>));<br><span class="hljs-comment">// 空指针异常</span><br>bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));<br></code></pre></td></tr></table></figure>

<p>下面我们来解释一下原因。</p>
<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, U, M <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Map</span>&lt;K, U&gt;&gt;<br>Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">K</span>&gt; keyMapper,<br>                            Function&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span>&gt; valueMapper,<br>                            BinaryOperator&lt;U&gt; mergeFunction,<br>                            Supplier&lt;M&gt; mapSupplier) &#123;<br>    BiConsumer&lt;M, T&gt; accumulator<br>            = (map, element) -&gt; map.merge(keyMapper.apply(element),<br>                                          valueMapper.apply(element), mergeFunction);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectorImpl</span>&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>
<blockquote>
<p>如果你还不了解 Java 8 新特性的话，请看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ojyl7B6PiHaTWADqmUq2rw">《Java8 新特性总结》 </a> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> V <span class="hljs-title function_">merge</span><span class="hljs-params">(K key, V value,</span><br><span class="hljs-params">        BiFunction&lt;? <span class="hljs-built_in">super</span> V, ? <span class="hljs-built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;<br>    Objects.requireNonNull(remappingFunction);<br>    Objects.requireNonNull(value);<br>    <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> get(key);<br>    <span class="hljs-type">V</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> (oldValue == <span class="hljs-literal">null</span>) ? value :<br>               remappingFunction.apply(oldValue, value);<br>    <span class="hljs-keyword">if</span>(newValue == <span class="hljs-literal">null</span>) &#123;<br>        remove(key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        put(key, newValue);<br>    &#125;<br>    <span class="hljs-keyword">return</span> newValue;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">requireNonNull</span><span class="hljs-params">(T obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h5><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</strong></p>
</blockquote>
<p>通过反编译你会发现 foreach 语法底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>
<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong> ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出<code>ConcurrentModificationException</code>。 即使是单线程下也有可能会出现这种情况，上面已经提到过。</p>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12470446.html">什么是 fail-fast </a> 。</p>
</blockquote>
<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i) &#123;<br>    list.add(i);<br>&#125;<br>list.removeIf(filter -&gt; filter % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">/* 删除list中的所有偶数 */</span><br>System.out.println(list); <span class="hljs-comment">/* [1, 3, 5, 7, 9] */</span><br></code></pre></td></tr></table></figure>

<p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>
<ul>
<li>使用普通的 for 循环</li>
<li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li>
</ul>
<h5 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h5><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p>
</blockquote>
<p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Set 去重代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="hljs-title function_">removeDuplicateBySet</span><span class="hljs-params">(List&lt;T&gt; data)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(data);<br>&#125;<br><br><span class="hljs-comment">// List 去重代码示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">removeDuplicateByList</span><span class="hljs-params">(List&lt;T&gt; data)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    &#125;<br>    List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(data.size());<br>    <span class="hljs-keyword">for</span> (T current : data) &#123;<br>        <span class="hljs-keyword">if</span> (!result.contains(current)) &#123;<br>            result.add(current);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p>
<p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> map.containsKey(o);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p>
<p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> i;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[i]))<br>                <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们的 <code>List</code> 有 N 个元素，那时间复杂度就接近是 O (n^2)。</p>
<h5 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h5><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p>
</blockquote>
<p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String [] s= <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<br>    <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;lazy&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;over&quot;</span>, <span class="hljs-string">&quot;jumps&quot;</span>, <span class="hljs-string">&quot;fox&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>, <span class="hljs-string">&quot;quick&quot;</span>, <span class="hljs-string">&quot;A&quot;</span><br>&#125;;<br>List&lt;String&gt; list = Arrays.asList(s);<br>Collections.reverse(list);<br><span class="hljs-comment">//没有指定类型的话会报错</span><br>s=list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：<a target="_blank" rel="noopener" href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">https://shipilev.net/blog/2016/arrays-wisdom-ancients/</a></p>
<h5 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h5><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p>
</blockquote>
<p>我在之前的一个项目中就遇到一个类似的坑。</p>
<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] myArray = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>&#125;;<br>List&lt;String&gt; myList = Arrays.asList(myArray);<br><span class="hljs-comment">//上面两个语句等价于下面一条语句</span><br>List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string">&quot;Apple&quot;</span>,<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>JDK 源码对于这个方法的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span><br><span class="hljs-comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">asList</span><span class="hljs-params">(T... a)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我们来总结一下使用注意事项。</p>
<p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(myArray);<br>System.out.println(myList.size());<span class="hljs-comment">//1</span><br>System.out.println(myList.get(<span class="hljs-number">0</span>));<span class="hljs-comment">//数组地址值</span><br>System.out.println(myList.get(<span class="hljs-number">1</span>));<span class="hljs-comment">//报错：ArrayIndexOutOfBoundsException</span><br><span class="hljs-type">int</span>[] array = (<span class="hljs-type">int</span>[]) myList.get(<span class="hljs-number">0</span>);<br>System.out.println(array[<span class="hljs-number">0</span>]);<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] myArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>myList.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.clear();<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br></code></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>System.out.println(myList.getClass());<span class="hljs-comment">//class java.util.Arrays$ArrayList</span><br></code></pre></td></tr></table></figure>

<p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>      <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RandomAccess</span>, java.io.Serializable<br>  &#123;<br>      ...<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span> &#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>         ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> &#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span> &#123;<br>        ...<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    add(size(), e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>    removeRange(<span class="hljs-number">0</span>, size());<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeRange</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span> &#123;<br>    ListIterator&lt;E&gt; it = listIterator(fromIndex);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;<br>        it.next();<br>        it.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>那我们如何正确的将数组转换为 <code>ArrayList</code> ?</strong></p>
<p>1、手动实现工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK1.5+</span><br><span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">arrayToList</span><span class="hljs-params">(<span class="hljs-keyword">final</span> T[] array)</span> &#123;<br>  <span class="hljs-keyword">final</span> List&lt;T&gt; l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;T&gt;(array.length);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> T s : array) &#123;<br>    l.add(s);<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><br>Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>System.out.println(arrayToList(myArray).getClass());<span class="hljs-comment">//class java.util.ArrayList</span><br></code></pre></td></tr></table></figure>

<p>2、最简便的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>))<br></code></pre></td></tr></table></figure>

<p>3、使用 Java8 的 <code>Stream</code>(推荐)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer [] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());<br><span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><br><span class="hljs-type">int</span> [] myArray2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<p>4、使用 Guava</p>
<p>对于不可变集合，你可以使用<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"><code>ImmutableList</code> </a>类及其<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"><code>of()</code> </a>与<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"><code>copyOf()</code> </a>工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; il = ImmutableList.of(<span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;elements&quot;</span>);  <span class="hljs-comment">// from varargs</span><br>List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="hljs-comment">// from array</span><br></code></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"><code>Lists</code> </a>类及其<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"><code>newArrayList()</code> </a>工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="hljs-comment">// from collection</span><br>List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="hljs-comment">// from array</span><br>List&lt;String&gt; l3 = Lists.newArrayList(<span class="hljs-string">&quot;or&quot;</span>, <span class="hljs-string">&quot;string&quot;</span>, <span class="hljs-string">&quot;elements&quot;</span>); <span class="hljs-comment">// from varargs</span><br></code></pre></td></tr></table></figure>

<p>5、使用 Apache Commons Collections</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>CollectionUtils.addAll(list, str);<br></code></pre></td></tr></table></figure>

<p>6、 使用 Java9 的 <code>List.of()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>List&lt;Integer&gt; list = List.of(array);<br></code></pre></td></tr></table></figure>

<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h5 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h5><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（<code>.exe</code> 文件的运行）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87-Windows.png" srcset="/img/loading.gif" lazyload alt="进程示例图片-Windows"></p>
<h5 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h5><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiThread</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">// 获取 Java 线程管理 MXBean</span><br>	<span class="hljs-type">ThreadMXBean</span> <span class="hljs-variable">threadMXBean</span> <span class="hljs-operator">=</span> ManagementFactory.getThreadMXBean();<br>		<span class="hljs-comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span><br>		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>		<span class="hljs-comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span><br>		<span class="hljs-keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;<br>			System.out.println(<span class="hljs-string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="hljs-string">&quot;] &quot;</span> + threadInfo.getThreadName());<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[5] Attach Listener //添加事件<br>[4] Signal Dispatcher // 分发处理给 JVM 信号的线程<br>[3] Finalizer //调用对象 finalize 方法的线程<br>[2] Reference Handler //清除 reference 线程<br>[1] main //main 线程,程序入口<br></code></pre></td></tr></table></figure>

<p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h5 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h5><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" srcset="/img/loading.gif" lazyload alt="Java 运行时数据区域（JDK1.8 之后）">Java 运行时数据区域（JDK1.8 之后）</p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、</strong>虚拟机栈** 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong></p>
<h5 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h5><p>程序计数器主要有下面两个作用：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h5 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h5><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h5 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h5><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h4 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h4><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<p>最关键的点是：是否是 <strong>同时</strong> 执行。</p>
<h4 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h4><ul>
<li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<h4 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h4><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li>
</ul>
<h4 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h4><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>
<h4 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h4><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>
<ul>
<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>
<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>
<li>BLOCKED ：阻塞状态，需要等待锁释放。</li>
<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>
<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>
</ul>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。</p>
<p>Java 线程状态变迁图(图源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UOrXql_LhOD8dhTq_EPI0w">挑错 |《Java 并发编程的艺术》中关于线程状态的三处错误 </a>)：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" srcset="/img/loading.gif" lazyload alt="Java 线程状态变迁图">Java 线程状态变迁图</p>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>在操作系统层面，线程有 READY 和 RUNNING 状态；而在 JVM 层面，只能看到 RUNNABLE 状态（图源：<a target="_blank" rel="noopener" href="https://howtodoinjava.com/">HowToDoInJava </a>：<a target="_blank" rel="noopener" href="https://howtodoinjava.com/Java/multi-threading/Java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States </a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><strong>为什么 JVM 没有区分这两种状态呢？</strong> （摘自：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56494969/answer/154053599">Java 线程运行怎么有第六种状态？ - Dawell 的回答 </a> ） 现在的时分（time-sharing）多任务（multi-task）操作系统架构通常都是用所谓的“时间分片（time quantum or time slice）”方式进行抢占式（preemptive）轮转调度（round-robin 式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" srcset="/img/loading.gif" lazyload alt="RUNNABLE-VS-RUNNING">RUNNABLE-VS-RUNNING</p>
<ul>
<li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li>
<li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li>
<li>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</li>
<li>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li>
</ul>
<p>相关阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/R5MrTsWvk9McFSQ7bS0W2w">线程的几种状态你真的了解么？ </a> 。</p>
<h4 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a>什么是线程上下文切换?</h4><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>
<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>
<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>
<li>被终止或结束运行</li>
</ul>
<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h4 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h4><h5 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h5><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png" srcset="/img/loading.gif" lazyload alt="线程死锁示意图 ">线程死锁示意图</p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Thread[线程 1,5,main]get resource1<br>Thread[线程 2,5,main]get resource2<br>Thread[线程 1,5,main]waiting get resource2<br>Thread[线程 2,5,main]waiting get resource1<br></code></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<p>上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h5 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h5><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">Thread[线程 1,5,main]get resource1<br>Thread[线程 1,5,main]waiting get resource2<br>Thread[线程 1,5,main]get resource2<br>Thread[线程 2,5,main]get resource1<br>Thread[线程 2,5,main]waiting get resource2<br>Thread[线程 2,5,main]get resource2<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h4 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h4><p><strong>共同点</strong> ：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong> ：</p>
<ul>
<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>
<li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>
<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？</li>
</ul>
<h4 id="为什么-wait-方法不定义在-Thread-中？"><a href="#为什么-wait-方法不定义在-Thread-中？" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中？"></a>为什么 wait() 方法不定义在 Thread 中？</h4><p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>
<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>
<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h4 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h4><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><h5 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h5><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm2.png" srcset="/img/loading.gif" lazyload alt="JMM(Java 内存模型)强制在主存中进行读取">JMM(Java 内存模型)强制在主存中进行读取</p>
<p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>
<h5 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h5><p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>
<p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadFence</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">storeFence</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fullFence</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p>理论上来说，你通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p>
<p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字禁止指令重排序的效果。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<h5 id="volatile-可以保证原子性么？"><a href="#volatile-可以保证原子性么？" class="headerlink" title="volatile 可以保证原子性么？"></a>volatile 可以保证原子性么？</h5><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><h3 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>
<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performSynchronisedTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// 需要同步的操作</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>   <span class="hljs-comment">// 需要同步的操作</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>
<h5 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h5><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>
<p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png" srcset="/img/loading.gif" lazyload alt="JUC原子类概览">JUC原子类概览</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好</span><br><span class="hljs-comment">// 代价就是会消耗更多的内存空间（空间换时间）</span><br><span class="hljs-type">LongAdder</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>sum.increment();<br></code></pre></td></tr></table></figure>

<p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>
<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>
<p>理论上来说：</p>
<ul>
<li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>
<li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>
</ul>
<h5 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h5><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>
<p>版本号机制</p>
<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p><strong>举一个简单的例子</strong> ：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>&#x3D;1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>&#x3D;1 ），连同帐户扣除后余额（ <code>balance</code>&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号（ <code>version</code>&#x3D;1 ）试图向数据库提交数据（ <code>balance</code>&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>
</ol>
<p>这样就避免了操作员 B 用基于 <code>version</code>&#x3D;1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p>
<p>CAS 算法</p>
<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>
<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>
<blockquote>
<p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>
</blockquote>
<p>CAS 涉及到三个操作数：</p>
<ul>
<li><strong>V</strong> ：要更新的变量值(Var)</li>
<li><strong>E</strong> ：预期值(Expected)</li>
<li><strong>N</strong> ：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>
<p><strong>举一个简单的例子</strong> ：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p>
<ol>
<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>
<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>
</ol>
<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p>
<p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	*  CAS</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> o         包含要修改field的对象</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> offset    对象中某field的偏移量</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> expected  期望值</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> update    更新值</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span>          true | false</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,  Object expected, Object update)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> update)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> update)</span>;<br></code></pre></td></tr></table></figure>

<h5 id="乐观锁存在哪些问题？"><a href="#乐观锁存在哪些问题？" class="headerlink" title="乐观锁存在哪些问题？"></a>乐观锁存在哪些问题？</h5><p>ABA 问题是乐观锁最常见的问题。</p>
<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span><br><span class="hljs-params">                             V   newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>循环时间长开销大</p>
<p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p>
<ol>
<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>
</ol>
<p>只能保证一个共享变量的原子操作</p>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>
<h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><h5 id="synchronized-是什么？有什么用？"><a href="#synchronized-是什么？有什么用？" class="headerlink" title="synchronized 是什么？有什么用？"></a>synchronized 是什么？有什么用？</h5><p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>
<h5 id="如何使用-synchronized？"><a href="#如何使用-synchronized？" class="headerlink" title="如何使用 synchronized？"></a>如何使用 synchronized？</h5><p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p>
<ol>
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>
<p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、修饰静态方法</strong> （锁当前类）</p>
<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p><strong>3、修饰代码块</strong> （锁指定对象&#x2F;类）</p>
<p>对括号里指定的对象&#x2F;类加锁：</p>
<ul>
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能</li>
</ul>
<h5 id="synchronized-底层原理了解吗？"><a href="#synchronized-底层原理了解吗？" class="headerlink" title="synchronized 底层原理了解吗？"></a>synchronized 底层原理了解吗？</h5><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/synchronized-release-lock-block.png" srcset="/img/loading.gif" lazyload alt="执行 monitorexit 释放锁"></p>
<h5 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h5><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li>
<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>
<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li>
</ul>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="ReentrantLock-是什么？"><a href="#ReentrantLock-是什么？" class="headerlink" title="ReentrantLock 是什么？"></a>ReentrantLock 是什么？</h5><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span>, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/reentrantlock-class-diagram.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="公平锁和非公平锁有什么区别？"><a href="#公平锁和非公平锁有什么区别？" class="headerlink" title="公平锁和非公平锁有什么区别？"></a>公平锁和非公平锁有什么区别？</h5><ul>
<li><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>
<li><strong>非公平锁</strong> ：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>
</ul>
<h5 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h5><p>两者都是可重入锁</p>
<p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p>
<p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1&quot;</span>);<br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p>
<p>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</p>
<p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>
<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p>ReentrantLock 比 synchronized 增加了一些高级功能</p>
<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>&#x2F;<code>notifyAll()</code>方法相结合可以实现等待&#x2F;通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<p>如果你想使用上述功能，那么选择 <code>ReentrantLock</code> 是一个不错的选择。</p>
<p>关于 <code>Condition</code>接口的补充：</p>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><h5 id="ThreadLocal-有什么用？"><a href="#ThreadLocal-有什么用？" class="headerlink" title="ThreadLocal 有什么用？"></a>ThreadLocal 有什么用？</h5><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong></p>
<p>JDK 中自带的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的</p>
<h5 id="如何使用-ThreadLocal？"><a href="#如何使用-ThreadLocal？" class="headerlink" title="如何使用 ThreadLocal？"></a>如何使用 ThreadLocal？</h5><h5 id="ThreadLocal-内存泄露问题是怎么导致的？"><a href="#ThreadLocal-内存泄露问题是怎么导致的？" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的？"></a>ThreadLocal 内存泄露问题是怎么导致的？</h5><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h5><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p>
<h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h5 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h5><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p>
<p><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-d54a5992.png" srcset="/img/loading.gif" lazyload alt="通过构造方法实现">通过构造方法实现</p>
<p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p>
<p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p>
<ul>
<li><strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li>
</ul>
<p>对应 <code>Executors</code> 工具类中的方法如图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/executors-inner-threadpool.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="为什么-不推荐使用内置线程池"><a href="#为什么-不推荐使用内置线程池" class="headerlink" title="为什么 不推荐使用内置线程池"></a>为什么 不推荐使用内置线程池</h5><p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
</blockquote>
<p>另外，《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无界队列 LinkedBlockingQueue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br><br>&#125;<br><br><span class="hljs-comment">// 无界队列 LinkedBlockingQueue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br><br>&#125;<br><br><span class="hljs-comment">// 同步队列 SynchronousQueue，没有容量，最大线程数是 Integer.MAX_VALUE`</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<span class="hljs-number">60L</span>, TimeUnit.SECONDS,<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;());<br><br>&#125;<br><br><span class="hljs-comment">// DelayedWorkQueue（延迟阻塞队列）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedWorkQueue</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="线程池常见参数有哪些？如何解释？"><a href="#线程池常见参数有哪些？如何解释？" class="headerlink" title="线程池常见参数有哪些？如何解释？"></a>线程池常见参数有哪些？如何解释？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数 :</p>
<ul>
<li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ul>
<p>下面这张图可以加深你对线程池中各个参数的相互关系的理解（图片来源：《Java 性能调优实战》）：</p>
<p><img src="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-d65f3309.png" srcset="/img/loading.gif" lazyload alt="线程池各个参数的关系">线程池各个参数的关系</p>
<h5 id="线程池的饱和策略有哪些？"><a href="#线程池的饱和策略有哪些？" class="headerlink" title="线程池的饱和策略有哪些？"></a>线程池的饱和策略有哪些？</h5><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子：Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略来配置线程池的时候，默认使用的是 <code>AbortPolicy</code>。在这种饱和策略下，如果队列满了，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 异常来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。如果不想丢弃任务的话，可以使用<code>CallerRunsPolicy</code>。<code>CallerRunsPolicy</code> 和其他的几个策略不同，它既不会抛弃任务，也不会抛出异常，而是将任务回退给调用者，使用调用者的线程来执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">CallerRunsPolicy</span><span class="hljs-params">()</span> &#123; &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>                <span class="hljs-comment">// 直接主线程执行，而不是线程池中的线程执行</span><br>                r.run();<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h5 id="线程池常用的阻塞队列有哪些？"><a href="#线程池常用的阻塞队列有哪些？" class="headerlink" title="线程池常用的阻塞队列有哪些？"></a>线程池常用的阻塞队列有哪些？</h5><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p>
<p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p>
<ul>
<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li>
<li><code>SynchronousQueue</code>（同步队列） ：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>
</ul>
<h5 id="如何设定线程池的大小"><a href="#如何设定线程池的大小" class="headerlink" title="如何设定线程池的大小"></a>如何设定线程池的大小</h5><p>很多人甚至可能都会觉得把线程池配置过大一点比较好！我觉得这明显是有问题的。就拿我们生活中非常常见的一例子来说：<strong>并不是人多就能把事情做好，增加了沟通交流成本。你本来一件事情只需要 3 个人做，你硬是拉来了 6 个人，会提升做事效率嘛？我想并不会。</strong> 线程数量过多的影响也是和我们分配多少人做事情一样，对于多线程这个场景来说主要是增加了<strong>上下文切换</strong>成本。不清楚什么是上下文切换的话，可以看我下面的介绍。</p>
<blockquote>
<p>上下文切换：</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>
<ul>
<li>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</li>
<li>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li>
</ul>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<blockquote>
<p>🌈 拓展一下：</p>
<p>线程数更严谨的计算的方法应该是：<code>最佳线程数 = N（CPU 核心数）∗（1+WT（线程等待时间）/ST（线程计算时间））</code>，其中 <code>WT（线程等待时间）=线程运行总时间 - ST（线程计算时间）</code>。</p>
<p>线程等待时间所占比例越高，需要越多线程。线程计算时间所占比例越高，需要越少线程。</p>
<p>我们可以通过 JDK 自带的工具 VisualVM 来查看 <code>WT/ST</code> 比例。</p>
<p>CPU 密集型任务的 <code>WT/ST</code> 接近或者等于 0，因此， 线程数可以设置为 N（CPU 核心数）∗（1+0）&#x3D; N，和我们上面说的 N（CPU 核心数）+1 差不多。</p>
<p>IO 密集型任务下，几乎全是线程等待时间，从理论上来说，你就可以将线程数设置为 2N（按道理来说，WT&#x2F;ST 的结果应该比较大，这里选择 2N 的原因应该是为了避免创建过多线程吧）。</p>
</blockquote>
<p>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。我在后面介绍的美团的线程池参数动态配置这种方案就非常不错，很实用！</p>
<h5 id="如何动态修改线程池的参数？"><a href="#如何动态修改线程池的参数？" class="headerlink" title="如何动态修改线程池的参数？"></a>如何动态修改线程池的参数？</h5><p>美团技术团队在<a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java 线程池实现原理及其在美团业务中的实践》 </a>这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。</p>
<p>美团技术团队的思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：</p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><strong>为什么是这三个参数？</strong></p>
<p>我在<a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">Java 线程池详解 </a> 这篇文章中就说过这三个参数是 <code>ThreadPoolExecutor</code> 最重要的参数，它们基本决定了线程池对于任务的处理策略。</p>
<p><strong>如何支持参数动态配置？</strong> 且看 <code>ThreadPoolExecutor</code> 提供的下面这些方法。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadpoolexecutor-methods.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>格外需要注意的是<code>corePoolSize</code>， 程序运行期间的时候，我们调用 <code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</p>
<p>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 <code>ResizableCapacityLinkedBlockIngQueue</code> 的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）。</p>
<p>最终实现的可动态修改线程池参数效果如下。👏👏👏</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/meituan-dynamically-configuring-thread-pool-parameters.png" srcset="/img/loading.gif" lazyload alt="动态配置线程池参数最终效果">动态配置线程池参数最终效果</p>
<p>还没看够？推荐 why 神的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9HLuPcoWmTqAeFKa1kj-_A">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。 </a>这篇文章，深度剖析，很不错哦！</p>
<p>如果我们的项目也想要实现这种效果的话，可以借助现成的开源项目：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/opengoofy/hippo4j">Hippo-4 </a></strong> ：一款强大的动态线程池框架，解决了传统线程池使用存在的一些痛点比如线程池参数没办法动态修改、不支持运行时变量的传递、无法执行优雅关闭。除了支持动态修改线程池参数、线程池任务传递上下文，还支持通知报警、运行监控等开箱即用的功能。</li>
<li><strong><a target="_blank" rel="noopener" href="https://github.com/dromara/dynamic-tp">Dynamic TP </a></strong> ：轻量级动态线程池，内置监控告警功能，集成三方中间件线程池管理，基于主流配置中心（已支持 Nacos、Apollo，Zookeeper、Consul、Etcd，可通过 SPI 自定义实现）</li>
</ul>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><h5 id="Future类有什么用"><a href="#Future类有什么用" class="headerlink" title="Future类有什么用"></a>Future类有什么用</h5><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 <code>Future</code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。</p>
<p>这其实就是多线程中经典的 <strong>Future 模式</strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。</p>
<p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：</p>
<ul>
<li>取消任务；</li>
<li>判断任务是否被取消;</li>
<li>判断任务是否已经执行完成;</li>
<li>获取任务执行结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// V 代表了Future执行的任务返回值的类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Future</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 取消任务执行</span><br>    <span class="hljs-comment">// 成功取消返回 true，否则返回 false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span>;<br>    <span class="hljs-comment">// 判断任务是否被取消</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 判断任务是否已经执行完成</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 获取任务执行结果</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException;<br>    <span class="hljs-comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>简单理解就是：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p>
<h5 id="Callable-和-Future-有什么关系？"><a href="#Callable-和-Future-有什么关系？" class="headerlink" title="Callable 和 Future 有什么关系？"></a>Callable 和 Future 有什么关系？</h5><p>我们可以通过 <code>FutureTask</code> 来理解 <code>Callable</code> 和 <code>Future</code> 之间的关系。</p>
<p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。<code>ExecutorService.submit()</code> 方法返回的其实就是 <code>Future</code> 的实现类 <code>FutureTask</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br>Future&lt;?&gt; submit(Runnable task);<br></code></pre></td></tr></table></figure>

<p><code>FutureTask</code> 不光实现了 <code>Future</code>接口，还实现了<code>Runnable</code> 接口，因此可以作为任务直接被线程执行。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/completablefuture-class-diagram.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>FutureTask</code> 有两个构造函数，可传入 <code>Callable</code> 或者 <code>Runnable</code> 对象。实际上，传入 <code>Runnable</code> 对象也会在方法内部转换为<code>Callable</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-comment">// 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象</span><br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>    <span class="hljs-built_in">this</span>.state = NEW;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果。</p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h3 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h3><h4 id="Maven介绍"><a href="#Maven介绍" class="headerlink" title="Maven介绍"></a>Maven介绍</h4><h5 id="什么是-POM？"><a href="#什么是-POM？" class="headerlink" title="什么是 POM？"></a><strong>什么是 POM？</strong></h5><p> 每一个 Maven 工程都有一个 <code>pom.xml</code> 文件，位于根目录中，包含项目构建生命周期的详细信息。通过 <code>pom.xml</code> 文件，我们可以定义项目的坐标、项目依赖、项目信息、插件信息等等配置。</p>
<p>对于开发者来说，Maven 的主要作用主要有 3 个：</p>
<ol>
<li><strong>项目构建</strong> ：提供标准的、跨平台的自动化项目构建方式。</li>
<li><strong>依赖管理</strong> ：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。</li>
<li><strong>统一开发结构</strong> ：提供标准的、统一的项目结构。</li>
</ol>
<h4 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h4><p>项目中依赖的第三方库以及插件可统称为构件。每一个构件都可以使用 Maven 坐标唯一标识，坐标元素包括：</p>
<ul>
<li><strong>groupId</strong>(必须): 定义了当前 Maven 项目隶属的组织或公司。groupId 一般分为多段，通常情况下，第一段为域，第二段为公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织，cn 表示中国。以 apache 开源社区的 tomcat 项目为例，这个项目的 groupId 是 org.apache，它的域是 org（因为 tomcat 是非营利项目），公司名称是 apache，artifactId 是 tomcat。</li>
<li><strong>artifactId</strong>(必须)：定义了当前 Maven 项目的名称，项目的唯一的标识符，对应项目根目录的名称。</li>
<li><strong>version</strong>(必须)： 定义了 Maven 项目当前所处版本。</li>
<li><strong>packaging</strong>（可选）：定义了 Maven 项目的打包方式（比如 jar，war…），默认使用 jar。</li>
<li><strong>classifier</strong>(可选)：常用于区分从同一 POM 构建的具有不同内容的构件，可以是任意的字符串，附加在版本号之后。</li>
</ul>
<p>只要你提供正确的坐标，就能从 Maven 仓库中找到相应的构件供我们使用。</p>
<p>举个例子（引入阿里巴巴开源的 EasyExcel） ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>你可以在 <a target="_blank" rel="noopener" href="https://mvnrepository.com/">https://mvnrepository.com/ </a> 这个网站上找到几乎所有可用的构件，如果你的项目使用的是 Maven 作为构建工具，那这个网站你一定会经常接触。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/tools/maven/mvnrepository.com.png" srcset="/img/loading.gif" lazyload alt="Maven 仓库">Maven 仓库</p>
<h4 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h4><p>如果使用 Maven 构建产生的构件（例如 Jar 文件）被其他的项目引用，那么该构件就是其他项目的依赖。</p>
<h5 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h5><p><strong>配置信息示例</strong> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>配置说明</strong> ：</p>
<ul>
<li>dependencies ： 一个 pom.xml 文件中只能存在一个这样的标签，是用来管理依赖的总标签。</li>
<li>dependency：包含在 dependencies 标签中，可以有多个，每一个表示项目的一个依赖。</li>
<li>groupId,artifactId,version(必要)：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven 根据坐标才能找到需要的依赖。我们在上面解释过这些元素的具体意思，这里就不重复提了。</li>
<li>type(可选)：依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值是 jar。</li>
<li>scope(可选)：依赖的范围，默认值是 compile。</li>
<li>optional(可选)： 标记依赖是否可选</li>
<li>exclusions(可选)：用来排除传递性依赖,例如 jar 包冲突</li>
</ul>
<h5 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h5><p><strong>classpath</strong> 用于指定 <code>.class</code> 文件存放的位置，类加载器会从该路径中加载所需的 <code>.class</code> 文件到内存中。</p>
<p>Maven 在编译、执行测试、实际运行有着三套不同的 classpath：</p>
<ul>
<li><strong>编译 classpath</strong> ：编译主代码有效</li>
<li><strong>测试 classpath</strong> ：编译、运行测试代码有效</li>
<li><strong>运行 classpath</strong> ：项目运行时有效</li>
</ul>
<p>Maven 的依赖范围如下：</p>
<ul>
<li><strong>compile</strong>：编译依赖范围（默认），使用此依赖范围对于编译、测试、运行三种都有效，即在编译、测试和运行的时候都要使用该依赖 Jar 包。</li>
<li><strong>test</strong>：测试依赖范围，从字面意思就可以知道此依赖范围只能用于测试，而在编译和运行项目时无法使用此类依赖，典型的是 JUnit，它只用于编译测试代码和运行测试代码的时候才需要。</li>
<li><strong>provided</strong> ：此依赖范围，对于编译和测试有效，而对运行时无效。比如 <code>servlet-api.jar</code> 在 Tomcat 中已经提供了，我们只需要的是编译期提供而已。</li>
<li><strong>runtime</strong>：运行时依赖范围，对于测试和运行有效，但是在编译主代码时无效，典型的就是 JDBC 驱动实现。</li>
<li><strong>system</strong>：系统依赖范围，使用 system 范围的依赖时必须通过 systemPath 元素显示地指定依赖文件的路径，不依赖 Maven 仓库解析，所以可能会造成建构的不可移植。</li>
</ul>
<h5 id="传递依赖性"><a href="#传递依赖性" class="headerlink" title="传递依赖性"></a>传递依赖性</h5><h5 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h5><p><strong>1、对于 Maven 而言，同一个 groupId 同一个 artifactId 下，只能使用一个 version。</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>in.hocg.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只会使用 1.0.49 这个版本的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>in.hocg.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.49<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>若相同类型但版本不同的依赖存在于同一个 pom 文件，只会引入后一个声明的依赖。</p>
<p><strong>2、项目的两个依赖同时引入了某个依赖。</strong></p>
<p>举个例子，项目存在下面这样的依赖关系：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">依赖链路一：A -&gt; B -&gt; C -&gt; X(1.0)<br>依赖链路二：A -&gt; D -&gt; X(2.0)<br></code></pre></td></tr></table></figure>

<p>这两条依赖路径上有两个版本的 X，为了避免依赖重复，Maven 只会选择其中的一个进行解析。</p>
<p><strong>哪个版本的 X 会被 Maven 解析使用呢?</strong></p>
<p>Maven 在遇到这种问题的时候，会遵循 <strong>路径最短优先</strong> 和 <strong>声明顺序优先</strong> 两大原则。解决这个问题的过程也被称为 <strong>Maven 依赖调解</strong> 。</p>
<p><strong>路径最短优先</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">依赖链路一：A -&gt; B -&gt; C -&gt; X(1.0) // dist = 3<br>依赖链路二：A -&gt; D -&gt; X(2.0) // dist = 2<br></code></pre></td></tr></table></figure>

<p>依赖链路二的路径最短，因此，X(2.0)会被解析使用。</p>
<p>不过，你也可以发现。路径最短优先原则并不是通用的，像下面这种路径长度相等的情况就不能单单通过其解决了：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">依赖链路一：A -&gt; B -&gt; X(1.0) // dist = 3<br>依赖链路二：A -&gt; D -&gt; X(2.0) // dist = 2<br></code></pre></td></tr></table></figure>

<p>因此，Maven 又定义了声明顺序优先原则。</p>
<p>依赖调解第一原则不能解决所有问题，比如这样的依赖关系：A-&gt;B-&gt;Y(1.0)、A-&gt; C-&gt;Y(2.0)，Y(1.0)和 Y(2.0)的依赖路径长度是一样的，都为 2。Maven 定义了依赖调解的第二原则：</p>
<p><strong>声明顺序优先</strong></p>
<p>在依赖路径长度相等的前提下，在 <code>pom.xml</code> 中依赖声明的顺序决定了谁会被解析使用，顺序最前的那个依赖优胜。该例中，如果 B 的依赖声明在 D 之前，那么 X (1.0)就会被解析使用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- A pom.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    ...<br>    dependency B<br>    ...<br>    dependency D<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h5><p>单纯依赖 Maven 来进行依赖调解，在很多情况下是不适用的，需要我们手动排除依赖。</p>
<p>举个例子，当前项目存在下面这样的依赖关系：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">依赖链路一：A -&gt; B -&gt; C -&gt; X(1.5) // dist = 3<br>依赖链路二：A -&gt; D -&gt; X(1.0) // dist = 2<br></code></pre></td></tr></table></figure>

<p>根据路径最短优先原则，X(1.0) 会被解析使用，也就是说实际用的是 1.0 版本的 X。</p>
<p>但是！！！这会一些问题：如果 D 依赖用到了 1.5 版本的 X 中才有的一个类，运行项目就会报<code>NoClassDefFoundError</code>错误。如果 D 依赖用到了 1.5 版本的 X 中才有的一个方法，运行项目就会报<code>NoSuchMethodError</code>错误。</p>
<p>现在知道为什么你的 Maven 项目总是会报<code>NoClassDefFoundError</code>和<code>NoSuchMethodError</code>错误了吧？</p>
<p><strong>如何解决呢？</strong> 我们可以通过<code>exclusive</code>标签手动将 X(1.0) 给排除。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    ......<br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>x<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.x<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>一般我们在解决依赖冲突的时候，都会优先保留版本较高的。这是因为大部分 jar 在升级的时候都会做到向下兼容。</p>
<p>如果高版本修改了低版本的一些类或者方法的话，这个时候就能直接保留高版本了，而是应该考虑优化上层依赖，比如升级上层依赖的版本。</p>
<p>还是上面的例子：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">依赖链路一：A -&gt; B -&gt; C -&gt; X(1.5) // dist = 3<br>依赖链路二：A -&gt; D -&gt; X(1.0) // dist = 2<br></code></pre></td></tr></table></figure>

<p>我们保留了 1.5 版本的 X，但是这个版本的 X 删除了 1.0 版本中的某些类。这个时候，我们可以考虑升级 D 的版本到一个 X 兼容的版本。</p>
<h4 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h4><p>在 Maven 世界中，任何一个依赖、插件或者项目构建的输出，都可以称为 <strong>构件</strong> 。</p>
<p>坐标和依赖是构件在 Maven 世界中的逻辑表示方式，构件的物理表示方式是文件，Maven 通过仓库来统一管理这些文件。 任何一个构件都有一组坐标唯一标识。有了仓库之后，无需手动引入构件，我们直接给定构件的坐标即可在 Maven 仓库中找到该构件。</p>
<p>Maven 仓库分为：</p>
<ul>
<li><strong>本地仓库</strong> ：运行 Maven 的计算机上的一个目录，它缓存远程下载的构件并包含尚未发布的临时构件。<code>settings.xml</code> 文件中可以看到 Maven 的本地仓库路径配置，默认本地仓库路径是在 <code>$&#123;user.home&#125;/.m2/repository</code>。</li>
<li><strong>远程仓库</strong> ：官方或者其他组织维护的 Maven 仓库。</li>
</ul>
<p>Maven 远程仓库可以分为：</p>
<ul>
<li><strong>中央仓库</strong> ：这个仓库是由 Maven 社区来维护的，里面存放了绝大多数开源软件的包，并且是作为 Maven 的默认配置，不需要开发者额外配置。另外为了方便查询，还提供了一个<a target="_blank" rel="noopener" href="https://search.maven.org/">查询地址</a>，开发者可以通过这个地址更快的搜索需要构件的坐标。</li>
<li><strong>私服</strong> ：私服是一种特殊的远程 Maven 仓库，它是架设在局域网内的仓库服务，私服一般被配置为互联网远程仓库的镜像，供局域网内的 Maven 用户使用。</li>
<li><strong>其他的公共仓库</strong> ：有一些公共仓库是为了加速访问（比如阿里云 Maven 镜像仓库）或者部分构件不存在于中央仓库中。</li>
</ul>
<p>Maven 依赖包寻找顺序：</p>
<ol>
<li>先去本地仓库找寻，有的话，直接使用。</li>
<li>本地仓库没有找到的话，会去远程仓库找寻，下载包到本地仓库。</li>
<li>远程仓库没有找到的话，会报错。</li>
</ol>
<h4 id="Maven声明周期"><a href="#Maven声明周期" class="headerlink" title="Maven声明周期"></a>Maven声明周期</h4><p>Maven 的生命周期就是为了对所有的构建过程进行抽象和统一，包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。</p>
<p>Maven 定义了 3 个生命周期<code>META-INF/plexus/components.xml</code>：</p>
<ul>
<li><code>default</code> 生命周期</li>
<li><code>clean</code>生命周期</li>
<li><code>site</code>生命周期</li>
</ul>
<p>这些生命周期是相互独立的，每个生命周期包含多个阶段(phase)。并且，这些阶段是有序的，也就是说，后面的阶段依赖于前面的阶段。当执行某个阶段的时候，会先执行它前面的阶段。</p>
<p>执行 Maven 生命周期的命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mvn 阶段 [阶段2] ...[阶段n]<br></code></pre></td></tr></table></figure>

<h5 id="default-生命周期"><a href="#default-生命周期" class="headerlink" title="default 生命周期"></a>default 生命周期</h5><p><code>default</code>生命周期是在没有任何关联插件的情况下定义的，是 Maven 的主要生命周期，用于构建应用程序，共包含 23 个阶段。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">phases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 验证项目是否正确，并且所有必要的信息可用于完成构建过程 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>validate<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 建立初始化状态，例如设置属性 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>initialize<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 生成要包含在编译阶段的源代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 处理源代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 生成要包含在包中的资源 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 将资源复制并处理到目标目录中，为打包阶段做好准备。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 编译项目的源代码  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 对编译生成的文件进行后处理，例如对 Java 类进行字节码增强/优化 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-classes<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 生成要包含在编译阶段的任何测试源代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-test-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 处理测试源代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 生成要包含在编译阶段的测试源代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-test-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 处理从测试代码文件编译生成的文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 编译测试源代码 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test-compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 处理从测试代码文件编译生成的文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-classes<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 使用合适的单元测试框架（Junit 就是其中之一）运行测试 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在实际打包之前，执行任何的必要的操作为打包做准备 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>prepare-package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 获取已编译的代码并将其打包成可分发的格式，例如 JAR、WAR 或 EAR 文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 在执行集成测试之前执行所需的操作。 例如，设置所需的环境 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>pre-integration-test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 处理并在必要时部署软件包到集成测试可以运行的环境 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>integration-test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 执行集成测试后执行所需的操作。 例如，清理环境  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>post-integration-test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 运行任何检查以验证打的包是否有效并符合质量标准。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 	将包安装到本地仓库中，可以作为本地其他项目的依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>install<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 将最终的项目包复制到远程仓库中与其他开发者和项目共享 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>deploy<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">phases</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>根据前面提到的阶段间依赖关系理论，当我们执行 <code>mvn test</code>命令的时候，会执行从 validate 到 test 的所有阶段，这也就解释了为什么执行测试的时候，项目的代码能够自动编译。</p>
<h5 id="clean-生命周期"><a href="#clean-生命周期" class="headerlink" title="clean 生命周期"></a>clean 生命周期</h5><p>clean 生命周期的目的是清理项目，共包含 3 个阶段：</p>
<ol>
<li>pre-clean</li>
<li>clean</li>
<li>post-clean</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">phases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  执行一些需要在clean之前完成的工作 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>pre-clean<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  移除所有上一次构建生成的文件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>clean<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  执行一些需要在clean之后立刻完成的工作 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>post-clean<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">phases</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">default-phases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">clean</span>&gt;</span><br>    org.apache.maven.plugins:maven-clean-plugin:2.5:clean<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">clean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">default-phases</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>根据前面提到的阶段间依赖关系理论，当我们执行 <code>mvn clean</code> 的时候，会执行 clean 生命周期中的 pre-clean 和 clean 阶段。</p>
<h5 id="site-生命周期"><a href="#site-生命周期" class="headerlink" title="site 生命周期"></a>site 生命周期</h5><p>site 生命周期的目的是建立和发布项目站点，共包含 4 个阶段：</p>
<ol>
<li>pre-site</li>
<li>site</li>
<li>post-site</li>
<li>site-deploy</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">phases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  执行一些需要在生成站点文档之前完成的工作 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>pre-site<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  生成项目的站点文档作 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>site<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>post-site<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--  将生成的站点文档部署到特定的服务器上 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>site-deploy<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">phases</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">default-phases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">site</span>&gt;</span><br>    org.apache.maven.plugins:maven-site-plugin:3.3:site<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">site</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">site-deploy</span>&gt;</span><br>    org.apache.maven.plugins:maven-site-plugin:3.3:deploy<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">site-deploy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">default-phases</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>Maven 能够基于 <code>pom.xml</code> 所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。</p>
<h4 id="Maven-插件"><a href="#Maven-插件" class="headerlink" title="Maven 插件"></a>Maven 插件</h4><p>Maven 本质上是一个插件执行框架，所有的执行过程，都是由一个一个插件独立完成的。像咱们日常使用到的 install、clean、deploy 等命令，其实底层都是一个一个的 Maven 插件。关于 Maven 的核心插件可以参考官方的这篇文档：<a target="_blank" rel="noopener" href="https://maven.apache.org/plugins/index.html">https://maven.apache.org/plugins/index.html </a> 。</p>
<p>本地默认插件路径: <code>$&#123;user.home&#125;/.m2/repository/org/apache/maven/plugins</code></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/tools/maven/maven-plugins.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>除了 Maven 自带的插件之外，还有一些三方提供的插件比如单测覆盖率插件 jacoco-maven-plugin、帮助开发检测代码中不合规范的地方的插件 maven-checkstyle-plugin、分析代码质量的 sonar-maven-plugin。并且，我们还可以自定义插件来满足自己的需求。</p>
<p>jacoco-maven-plugin 使用示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.8.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>prepare-agent<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>generate-code-coverage-report<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>report<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>你可以将 Maven 插件理解为一组任务的集合，用户可以通过命令行直接运行指定插件的任务，也可以将插件任务挂载到构建生命周期，随着生命周期运行。</p>
<p>Maven 插件被分为下面两种类型：</p>
<ul>
<li><strong>Build plugins</strong> ：在构建时执行。</li>
<li><strong>Reporting plugins</strong>：在网站生成过程中执行</li>
</ul>
<h4 id="Maven多模块管理"><a href="#Maven多模块管理" class="headerlink" title="Maven多模块管理"></a>Maven多模块管理</h4><p>多模块管理简单地来说就是将一个项目分为多个模块，每个模块只负责单一的功能实现。直观的表现就是一个 Maven 项目中不止有一个 <code>pom.xml</code> 文件，会在不同的目录中有多个 <code>pom.xml</code> 文件，进而实现多模块管理。</p>
<p>多模块管理除了可以更加便于项目开发和管理，还有如下好处：</p>
<ol>
<li>降低代码之间的耦合性（从类级别的耦合提升到 jar 包级别的耦合）；</li>
<li>减少重复，提升复用性；</li>
<li>每个模块都可以是自解释的（通过模块名或者模块文档）；</li>
<li>模块还规范了代码边界的划分，开发者很容易通过模块确定自己所负责的内容。</li>
</ol>
<p>多模块管理下，会有一个父模块，其他的都是子模块。父模块通常只有一个 <code>pom.xml</code>，没有其他内容。父模块的 <code>pom.xml</code> 一般只定义了各个依赖的版本号、包含哪些子模块以及插件有哪些。不过，要注意的是，如果依赖只在某个子项目中使用，则可以在子项目的 pom.xml 中直接引入，防止父 pom 的过于臃肿。</p>
<p>如下图所示，Dubbo 项目就被分成了多个子模块比如 dubbo-common（公共逻辑模块）、dubbo-remoting（远程通讯模块）、dubbo-rpc（远程调用模块）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/tools/maven/dubbo-maven-multi-module.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h3><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><h5 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h5><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。</p>
<h5 id="为什么要版本控制"><a href="#为什么要版本控制" class="headerlink" title="为什么要版本控制"></a>为什么要版本控制</h5><p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>
<p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。</p>
<h4 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h4><h5 id="git的三种状态"><a href="#git的三种状态" class="headerlink" title="git的三种状态"></a>git的三种状态</h5><p>Git 有三种状态，你的文件可能处于其中之一：</p>
<ol>
<li><strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。</li>
<li><strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。</li>
<li><strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
</ol>
<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directory)<strong>、</strong>工作目录(Working Directory)</strong> 以及 <strong>暂存区域(Staging Area)</strong> 。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3areas.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>基本的 Git 工作流程如下：</strong></p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<h5 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h5><p>有两种取得 Git 项目仓库的方法。</p>
<ol>
<li>在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。</li>
<li>从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url] directoryname</code></li>
</ol>
<h5 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h5><ol>
<li><strong>检测当前文件状态</strong> : <code>git status</code></li>
<li><strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）</li>
<li><strong>忽略文件</strong>：<code>.gitignore</code> 文件</li>
<li><strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）</li>
<li><strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</li>
<li><strong>移除文件</strong> ：<code>git rm filename</code> （从暂存区域移除，然后提交。）</li>
<li><strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</li>
</ol>
<h5 id="一个好的-Git-提交消息"><a href="#一个好的-Git-提交消息" class="headerlink" title="一个好的 Git 提交消息"></a>一个好的 Git 提交消息</h5><p>一个好的 Git 提交消息如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">标题行：用这一行来描述和解释你的这次提交<br><br>主体部分可以是很少的几行，来加入更多的细节来解释提交，最好是能给出一些相关的背景或者解释这个提交能修复和解决什么问题。<br><br>主体部分当然也可以有几段，但是一定要注意换行和句子不要太长。因为这样在使用 &quot;git log&quot; 的时候会有缩进比较好看。<br></code></pre></td></tr></table></figure>

<p>提交的标题行描述应该尽量的清晰和尽量的一句话概括。这样就方便相关的 Git 日志查看工具显示和其他人的阅读。</p>
<h5 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h5><ul>
<li><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<code>git remote add origin &lt;server&gt;</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code></p>
</li>
<li><p>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <em>master</em> 换成你想要推送的任何分支)</p>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
</li>
</ul>
<h5 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h5><ul>
<li>将 test 重命名为 test1：<code>git remote rename test test1</code></li>
<li>移除远程仓库 test1:<code>git remote rm test1</code></li>
</ul>
<h5 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h5><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。</p>
<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>
<p>只看某个人的提交记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --author=bob<br></code></pre></td></tr></table></figure>

<h5 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h5><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend<br></code></pre></td></tr></table></figure>

<p>取消暂存的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset filename<br></code></pre></td></tr></table></figure>

<p>撤消对文件的修改:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- filename<br></code></pre></td></tr></table></figure>

<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br>git reset --hard origin/master<br></code></pre></td></tr></table></figure>

<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>
<p>创建一个名字叫做 test 的分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature_x<br></code></pre></td></tr></table></figure>

<p>切换到主分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout master<br></code></pre></td></tr></table></figure>

<p>合并分支(可能会有冲突)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<p>把新建的分支删掉</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d feature_x<br></code></pre></td></tr></table></figure>

<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin<br></code></pre></td></tr></table></figure>

<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h4><h5 id="Spring包含哪些部分"><a href="#Spring包含哪些部分" class="headerlink" title="Spring包含哪些部分"></a>Spring包含哪些部分</h5><ul>
<li>Test</li>
</ul>
<p><strong>Spring5.x 版本</strong> ：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200831175708.png" srcset="/img/loading.gif" lazyload alt="Spring5.x主要模块">Spring5.x主要模块</p>
<h5 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h5><ul>
<li><strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li>
<li><strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li>
<li><strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li>
<li><strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li>
</ul>
<h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><ul>
<li><strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li>
<li><strong>spring-aop</strong> ：提供了面向切面的编程实现。</li>
<li><strong>spring-instrument</strong> ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li>
</ul>
<h5 id="Data-Access-x2F-Integration"><a href="#Data-Access-x2F-Integration" class="headerlink" title="Data Access&#x2F;Integration"></a>Data Access&#x2F;Integration</h5><ul>
<li><strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li><strong>spring-tx</strong> ：提供对事务的支持。</li>
<li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li>
<li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li>
<li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li>
</ul>
<h5 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h5><ul>
<li><strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li>
<li><strong>spring-webmvc</strong> ： 提供对 Spring MVC 的实现。</li>
<li><strong>spring-websocket</strong> ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li>
</ul>
<h5 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h5><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p>
<h5 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h5><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h5 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h5><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p>
<p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p>
<p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><h5 id="谈谈自己对于-Spring-IoC-的了解"><a href="#谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="谈谈自己对于 Spring IoC 的了解"></a>谈谈自己对于 Spring IoC 的了解</h5><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<blockquote>
<p>看了一个很有趣的例子来讲解IoC，小明准备配一台电脑，那么传统的做法就是去购买电源，显卡，cpu，主板等然后自己组装，当然嫌麻烦的话也可以花钱去电脑城组装，那么小明只需要给电脑城的店员说，我要一台能打LOL的电脑，那么这个时候小明就不用去自己花时间去挑选配件自行组装了。</p>
<p>在这个例子中就有IOC的思想，比如把电脑当成一个对象的话，那么自己安装电脑就是new一个对象并实例化。如果去电脑城的话就是使用IOC，这个时候就体现出了控制反转，自己不用显式的创建对象，而是由电脑城帮我们创建好，我们只需要开箱即用即可。当然我们的主机对象里还有显卡对象，主板对象等一系列对象，这个时候作为顾客也无需去知道主机里有什么。此时就体现出了控制反转-&gt;将对象的创建权和对象属性的设置权交给容器管理。这就是控制反转。</p>
</blockquote>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<h5 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h5><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/062b422bd7ac4d53afd28fb74b2bc94d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础</p>
<h5 id="将一个类声明为Bean的注解有哪些？"><a href="#将一个类声明为Bean的注解有哪些？" class="headerlink" title="将一个类声明为Bean的注解有哪些？"></a>将一个类声明为Bean的注解有哪些？</h5><ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面</li>
</ul>
<h5 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h5><ul>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ul>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transferService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OneService <span class="hljs-title function_">getService</span><span class="hljs-params">(status)</span> &#123;<br>    <span class="hljs-keyword">case</span> (status)  &#123;<br>        when <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl1</span>();<br>        when <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl2</span>();<br>        when <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl3</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="注入Bean的注解有哪些"><a href="#注入Bean的注解有哪些" class="headerlink" title="注入Bean的注解有哪些"></a>注入Bean的注解有哪些</h5><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr>
<th>Annotaion</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr>
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody></table>
<p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p>
<h5 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h5><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p>
<p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// smsService 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure>

<p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure>

<p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p>
<p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p>
<p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Resource &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    Class&lt;?&gt; type() <span class="hljs-keyword">default</span> Object.class;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><br><span class="hljs-meta">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure>

<p>简单总结一下：</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li>
</ul>
<h5 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h5><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h5><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li>在 Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的</p>
<h5 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h5><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/24bc2bad3ce28144d60d9e0a2edf6c7f.jpg" srcset="/img/loading.gif" lazyload alt="Spring Bean 生命周期">Spring Bean 生命周期</p>
<p>与之比较类似的中文版本:</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg" srcset="/img/loading.gif" lazyload alt="Spring Bean 生命周期">Spring Bean 生命周期</p>
<h4 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h4><h5 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="谈谈自己对于 AOP 的了解"></a>谈谈自己对于 AOP 的了解</h5><blockquote>
<p>还是举一个很有趣的小例子：某一天，小明去到一个网站找陪聊，经过多方的选择后，选择到了一个美女小美，小美肤白貌美大长腿，声音又好听，让大哥十分的满意，但是大哥不知道的是，其实小美就是一个抠脚大汉。经过陪聊软件的美颜后才便成了小美的样子。在这个例子中就有aop的体现。抠脚大汉就是业务实体，美颜软件就是切面实体，而美女小美就是代理对象。AOP就是面向切面编程。Spring的AOP就是通过动态代理的方式给业务实体扩展功能。</p>
</blockquote>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" srcset="/img/loading.gif" lazyload alt="SpringAOPProcess">SpringAOPProcess</p>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>AOP 切面编程设计到的一些专业术语：</p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">目标(Target)</td>
<td align="center">被通知的对象</td>
</tr>
<tr>
<td align="left">代理(Proxy)</td>
<td align="center">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td align="left">连接点(JoinPoint)</td>
<td align="center">目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr>
<td align="left">切入点(Pointcut)</td>
<td align="center">被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td align="left">通知(Advice)</td>
<td align="center">增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr>
<td align="left">切面(Aspect)</td>
<td align="center">切入点(Pointcut)+通知(Advice)</td>
</tr>
<tr>
<td align="left">Weaving(织入)</td>
<td align="center">将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody></table>
<h5 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h5><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多</p>
<h5 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="AspectJ 定义的通知类型有哪些？"></a>AspectJ 定义的通知类型有哪些？</h5><p><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</p>
<p><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</p>
<p><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p>
<p><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p>
<p><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</p>
<h5 id="多个切面的执行顺序如何确定？"><a href="#多个切面的执行顺序如何确定？" class="headerlink" title="多个切面的执行顺序如何确定？"></a>多个切面的执行顺序如何确定？</h5><p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 值越小优先级越高</span><br><span class="hljs-meta">@Order(3)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br></code></pre></td></tr></table></figure>

<p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingAspect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br>    <span class="hljs-comment">// ....</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 返回值越小优先级越高</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h4><h5 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h5><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210809181452421.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**<a target="_blank" rel="noopener" href="https://github.com/iluwatar/java-design-patterns">java-design-patterns </a>** 项目中就有关于 MVC 的相关介绍。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/159b3d3e70dd45e6afa81bf06d09264e.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。</p>
<p><strong>Model 1 时代</strong></p>
<p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。</p>
<p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/mvc-mode1.png" srcset="/img/loading.gif" lazyload alt="mvc-mode1">mvc-mode1</p>
<p><strong>Model 2 时代</strong></p>
<p>学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p>
<ul>
<li>Model:系统涉及的数据，也就是 dao 和 bean。</li>
<li>View：展示模型中的数据，只是用来展示。</li>
<li>Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p><img src="https://oss.javaguide.cn/java-guide-blog/mvc-model2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。</p>
<p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。</p>
<p><strong>Spring MVC 时代</strong></p>
<p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h5 id="Spring-MVC-的核心组件有哪些？"><a href="#Spring-MVC-的核心组件有哪些？" class="headerlink" title="Spring MVC 的核心组件有哪些？"></a>Spring MVC 的核心组件有哪些？</h5><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p>
<ul>
<li><strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ul>
<h5 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="SpringMVC 工作原理了解吗?"></a>SpringMVC 工作原理了解吗?</h5><p><strong>Spring MVC 原理如下图所示：</strong></p>
<blockquote>
<p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 uri 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配执行 <code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h5 id="统一异常处理怎么做？"><a href="#统一异常处理怎么做？" class="headerlink" title="统一异常处理怎么做？"></a>统一异常处理怎么做？</h5><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(BaseException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="hljs-title function_">handleResourceNotFoundException</span><span class="hljs-params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p>
<p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br>	<span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getMappedMethod</span><span class="hljs-params">(Class&lt;? extends Throwable&gt; exceptionType)</span> &#123;<br>		List&lt;Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;&gt; matches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span><br>		<span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; mappedException : <span class="hljs-built_in">this</span>.mappedMethods.keySet()) &#123;<br>			<span class="hljs-keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) &#123;<br>				matches.add(mappedException);<br>			&#125;<br>		&#125;<br>    <span class="hljs-comment">// 不为空说明有方法处理异常</span><br>		<span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;<br>      <span class="hljs-comment">// 按照匹配程度从小到大排序</span><br>			matches.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionDepthComparator</span>(exceptionType));<br>      <span class="hljs-comment">// 返回处理异常的方法</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mappedMethods.get(matches.get(<span class="hljs-number">0</span>));<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>从源代码看出： **<code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</p>
<h5 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h5><p><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring 中的设计模式详解 </a></p>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
</ul>
<h4 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h4><h5 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h5><p><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p>
<p><strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</p>
<h5 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="Spring 事务中哪几种事务传播行为?"></a>Spring 事务中哪几种事务传播行为?</h5><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<blockquote>
<p>可以看看抖音相关视频</p>
</blockquote>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>正确的事务传播行为可能的值如下:</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少。</p>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常</li>
</ul>
<h5 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="Spring 事务中的隔离级别有哪几种?"></a>Spring 事务中的隔离级别有哪几种?</h5><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Isolation</span> &#123;<br><br>    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),<br><br>    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),<br><br>    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),<br><br>    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),<br><br>    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br><br>    Isolation(<span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h5 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h5><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h4 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h4><h5 id="如何使用-JPA-在数据库中非持久化一个字段？"><a href="#如何使用-JPA-在数据库中非持久化一个字段？" class="headerlink" title="如何使用 JPA 在数据库中非持久化一个字段？"></a>如何使用 JPA 在数据库中非持久化一个字段？</h5><p>假如我们有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity(name=&quot;USER&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span><br>    <span class="hljs-meta">@Column(name = &quot;ID&quot;)</span><br>    <span class="hljs-keyword">private</span> Long id;<br><br>    <span class="hljs-meta">@Column(name=&quot;USER_NAME&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@Column(name=&quot;PASSWORD&quot;)</span><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">private</span> String secrect;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String transient1; <span class="hljs-comment">// not persistent because of static</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">transient2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Satish&quot;</span>; <span class="hljs-comment">// not persistent because of final</span><br><span class="hljs-keyword">transient</span> String transient3; <span class="hljs-comment">// not persistent because of transient</span><br><span class="hljs-meta">@Transient</span><br>String transient4; <span class="hljs-comment">// not persistent because of @Transient</span><br></code></pre></td></tr></table></figure>

<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h5 id="JPA-的审计功能是做什么的？有什么用？"><a href="#JPA-的审计功能是做什么的？有什么用？" class="headerlink" title="JPA 的审计功能是做什么的？有什么用？"></a>JPA 的审计功能是做什么的？有什么用？</h5><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@MappedSuperclass</span><br><span class="hljs-meta">@EntityListeners(value = AuditingEntityListener.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractAuditBase</span> &#123;<br><br>    <span class="hljs-meta">@CreatedDate</span><br>    <span class="hljs-meta">@Column(updatable = false)</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> Instant createdAt;<br><br>    <span class="hljs-meta">@LastModifiedDate</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> Instant updatedAt;<br><br>    <span class="hljs-meta">@CreatedBy</span><br>    <span class="hljs-meta">@Column(updatable = false)</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> String createdBy;<br><br>    <span class="hljs-meta">@LastModifiedBy</span><br>    <span class="hljs-meta">@JsonIgnore</span><br>    <span class="hljs-keyword">private</span> String updatedBy;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</p>
</li>
<li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p>
<p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p>
</li>
</ul>
<h4 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h4><h5 id="有哪些控制请求访问权限的方法？"><a href="#有哪些控制请求访问权限的方法？" class="headerlink" title="有哪些控制请求访问权限的方法？"></a>有哪些控制请求访问权限的方法？</h5><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/image-20220728201854641.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><code>permitAll()</code> ：无条件允许任何形式访问，不管你登录还是没有登录。</li>
<li><code>anonymous()</code> ：允许匿名访问，也就是没有登录才可以访问。</li>
<li><code>denyAll()</code> ：无条件决绝任何形式的访问。</li>
<li><code>authenticated()</code>：只允许已认证的用户访问。</li>
<li><code>fullyAuthenticated()</code> ：只允许已经登录或者通过 remember-me 登录的用户访问。</li>
<li><code>hasRole(String)</code> : 只允许指定的角色访问。</li>
<li><code>hasAnyRole(String) </code> : 指定一个或者多个角色，满足其一的用户即可访问。</li>
<li><code>hasAuthority(String)</code> ：只允许具有指定权限的用户访问</li>
<li><code>hasAnyAuthority(String)</code> ：指定一个或者多个权限，满足其一的用户即可访问。</li>
<li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li>
</ul>
<h5 id="hasRole-和-hasAuthority-有区别吗？"><a href="#hasRole-和-hasAuthority-有区别吗？" class="headerlink" title="hasRole 和 hasAuthority 有区别吗？"></a>hasRole 和 hasAuthority 有区别吗？</h5><p>可以看看松哥的这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw">Spring Security 中的 hasRole 和 hasAuthority 有区别吗？ </a>，介绍的比较详细。</p>
<h5 id="如何对密码进行加密？"><a href="#如何对密码进行加密？" class="headerlink" title="如何对密码进行加密？"></a>如何对密码进行加密？</h5><p>如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。</p>
<p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p>
<p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PasswordEncoder</span> &#123;<br>    <span class="hljs-comment">// 加密也就是对原始密码进行编码</span><br>    String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence var1)</span>;<br>    <span class="hljs-comment">// 比对原始密码和数据库中保存的密码</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence var1, String var2)</span>;<br>    <span class="hljs-comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/image-20220728183540954.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。</p>
<h5 id="如何优雅更换系统使用的加密算法？"><a href="#如何优雅更换系统使用的加密算法？" class="headerlink" title="如何优雅更换系统使用的加密算法？"></a>如何优雅更换系统使用的加密算法？</h5><p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p>
<p>推荐的做法是通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密方案，以适应不同的业务需求。</p>
<p>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的。</p>
<h3 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h3><h4 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h4><h5 id="mybatis是什么"><a href="#mybatis是什么" class="headerlink" title="mybatis是什么"></a>mybatis是什么</h5><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语<br>句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直<br>接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。<br>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了<br>几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>
<h5 id="mybatis优缺点"><a href="#mybatis优缺点" class="headerlink" title="mybatis优缺点"></a>mybatis优缺点</h5><p><strong>优点</strong><br>与传统的数据库访问技术相比，ORM有以下优点：</p>
<p>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在<br>XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并<br>可重用<br>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接<br>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库<br>MyBatis都支持）<br>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系<br>组件维护<br>能够与Spring很好的集成<br><strong>缺点</strong></p>
<p>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定<br>要求<br>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</p>
<h5 id="Hibernate-和-MyBatis-的区别"><a href="#Hibernate-和-MyBatis-的区别" class="headerlink" title="Hibernate 和 MyBatis 的区别"></a>Hibernate 和 MyBatis 的区别</h5><p><strong>相同点</strong></p>
<ul>
<li>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>映射关系<ul>
<li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联<br>关系配置简单</li>
<li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配<br>置复杂</li>
</ul>
</li>
</ul>
<p><strong>SQL优化和移植性</strong></p>
<ul>
<li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提<br>供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如<br>果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li>
<li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工<br>作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li>
</ul>
<p><strong>ORM是什么</strong></p>
<ul>
<li>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单<br>Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的<br>元数据，将程序中的对象自动持久化到关系型数据库中。</li>
</ul>
<h5 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h5><ul>
<li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根<br>据对象关系模型直接获取，所以它是全自动的。</li>
<li>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动<br>ORM映射工具。</li>
</ul>
<h5 id="JDBC编程有哪些不足之处，MyBatis是如何解决的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h5><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解<br>决此问题。<br>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。<br>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代<br>码。-<br>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。<br>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参<br>数一一对应。<br>解决： Mybatis自动将java对象映射至sql语句。<br>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装<br>成pojo对象解析比较方便。<br>解决：Mybatis自动将sql执行结果映射至java对象。</p>
<h5 id="mybatis和hibernate的适用场景"><a href="#mybatis和hibernate的适用场景" class="headerlink" title="mybatis和hibernate的适用场景"></a>mybatis和hibernate的适用场景</h5><ul>
<li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li>
</ul>
<p><strong>开发难易程度和学习成本</strong></p>
<ul>
<li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自<br>动化系统</li>
<li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子<br>商务系统</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</li>
<li>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</li>
</ul>
<h4 id="mybatis的架构"><a href="#mybatis的架构" class="headerlink" title="mybatis的架构"></a>mybatis的架构</h4><h5 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h5><p>1、 创建SqlSessionFactory<br>2、 通过SqlSessionFactory创建SqlSession<br>3、 通过sqlsession执行数据库操作<br>4、 调用session.commit()提交事务<br>5、 调用session.close()关闭会话</p>
<h5 id="请说说MyBatis的工作原理"><a href="#请说说MyBatis的工作原理" class="headerlink" title="请说说MyBatis的工作原理"></a>请说说MyBatis的工作原理</h5><ul>
<li>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作<br>原理如下图<br><img src="https://img-blog.csdnimg.cn/63e13d91922d4b78a72d30daba24ea92.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
</ul>
<ol>
<li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运<br>行环境等信息，例如数据库连接信息。</li>
<li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在<br>MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文<br>件，每个文件对应数据库中的一张表。</li>
<li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li>
<li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li>
<li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession<br>传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li>
<li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参<br>数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</li>
<li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类<br>型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</li>
<li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类<br>型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li>
</ol>
<h5 id="Mybatis的功能架构是怎样的"><a href="#Mybatis的功能架构是怎样的" class="headerlink" title="Mybatis的功能架构是怎样的"></a>Mybatis的功能架构是怎样的</h5><p><img src="https://img-blog.csdnimg.cn/8d44ab6c91934eb986458647870bc4de.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>我们把Mybatis的功能架构分为三层：<ul>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一<br>接收到调用请求就会调用数据处理层来完成具体的数据处理。</li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目<br>的是根据调用的请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这<br>些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的<br>支撑。</li>
</ul>
</li>
</ul>
<h5 id="Mybatis的框架架构设计是怎样的"><a href="#Mybatis的框架架构设计是怎样的" class="headerlink" title="Mybatis的框架架构设计是怎样的"></a>Mybatis的框架架构设计是怎样的</h5><p><img src="https://img-blog.csdnimg.cn/bfa052c973a34634baca758fb42c55fb.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<ul>
<li>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成<br>Configuration这个类，就是图中的红框。</li>
</ul>
<ol>
<li>加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加<br>载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配<br>置），存储在内存中。</li>
<li>SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、<br>JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根<br>据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</li>
<li>SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</li>
<li>结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者<br>基本数据类型，并将最终结果返回。</li>
</ol>
<h5 id="什么是DBMS"><a href="#什么是DBMS" class="headerlink" title="什么是DBMS"></a>什么是DBMS</h5><ul>
<li>DBMS：数据库管理系统(database management system)是一种操纵和管理数据库的大型软件，<br>用于建立、使用和维护数zd据库，简称dbms。它对数据库进行统一的管理和控制，以保证数据库<br>的安全性和完整性。用户通过dbms访问数据库中的数据，数据库管理员也通过dbms进行数据库<br>的维护工作。它可使多个应用程序和用户用不同的方法在同时版或不同时刻去建立，修改和询问数<br>据库。DBMS提供数据定义语言DDL（Data Definition Language）与数据操作语言DML（Data<br>Manipulation Language），供用户定义数据库的模式结构与权限约束，实现对数据的追加权、删<br>除等操作。</li>
</ul>
<h5 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h5><ul>
<li>定义：<ul>
<li>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，<br>这样 DBMS 执行 SQL 时，就不需要重新编译。</li>
</ul>
</li>
<li>为什么需要预编译<ul>
<li>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优<br>化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越<br>复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译<br>语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，<br>下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，<br>将对所有的 SQL 进行预编译。</li>
<li>还有一个重要的原因，复制SQL注入</li>
</ul>
</li>
</ul>
<h5 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h5><ul>
<li>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</li>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭<br>Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存<br>在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次<br>使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批<br>处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个<br>Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相<br>同。</li>
</ul>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h5 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h5><ul>
<li>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手<br>动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如<br>SqlSession openSession(ExecutorType execType)。</li>
<li>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared<br>statements）； BATCH 执行器将重用语句并执行批量更新。</li>
</ul>
<h5 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h5><ul>
<li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是<br>一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载<br>lazyLoadingEnabled&#x3D;true|false。</li>
<li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调<br>用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好<br>的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完<br>成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>
<li>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</li>
</ul>
<h4 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h4><h5 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h5><ul>
<li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li>
<li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用<br>PreparedStatement的set方法来赋值。</li>
<li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li>
<li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li>
</ul>
<h5 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2&spm=1001.2101.3001.7020">模糊查询</a>like语句该怎么写</h5><p>1 ’%${question}%’ 可能引起SQL注入，不推荐<br>2 “%”#{question}“%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以<br>这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。<br>3 CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，（推荐）<br>4 使用bind标签（不推荐）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listUserLikeUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br>	select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h5><p><strong>方法1：顺序传参法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> deptId)</span>;<br>	<br>	&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>		select * from user <span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;<span class="hljs-number">0</span>&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;<span class="hljs-number">1</span>&#125;<br>	&lt;/select&gt;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<ul>
<li>#{}里面的数字代表传入参数的顺序。</li>
<li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li>
</ul>
<p><strong>方法2：@Param注解传参法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userName&quot;)</span> String name, <span class="hljs-type">int</span> <span class="hljs-meta">@Param(&quot;deptId&quot;)</span> deptId)</span>;<br>	<br>	&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>		select * from user <span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>	&lt;/select&gt;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<ul>
<li>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</li>
<li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li>
</ul>
<p><strong>方法3：Map传参法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span>;<br>	<br>	&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>		select * from user <span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>	&lt;/select&gt;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<ul>
<li>#{}里面的名称对应的是Map里面的key名称。</li>
<li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。（推荐使用）。</li>
</ul>
<p><strong>方法4：Java Bean传参法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(User user)</span>;<br>	<br>	&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>		select * from user <span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>	&lt;/select&gt;<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<ul>
<li>#{}里面的名称对应的是User类里面的成员属性。</li>
<li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方<br>便，推荐使用。（推荐使用）。</li>
</ul>
<h5 id="Mybatis如何执行批量操作"><a href="#Mybatis如何执行批量操作" class="headerlink" title="Mybatis如何执行批量操作"></a>Mybatis如何执行批量操作</h5><ul>
<li>使用foreach标签</li>
<li>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主<br>要有item，index，collection，open，separator，close。<ul>
<li>item   表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li>
<li>index   指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li>
<li>open   表示该语句以什么开始，常用“(”；</li>
<li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li>
<li>close   表示以什么结束，常用“)”。</li>
</ul>
</li>
<li>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是<br>在不同情况下，该属性的值是不一样的，主要有一下3种情况：<br>1.如果传入的是单参数且参数类型是一个List的时候，collection属性值为list<br>2.如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array<br>3.如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封<br>装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map<br>的，<br>map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封<br>装的map里面的key</li>
<li>具体用法如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-comment">&lt;!-- 批量保存(foreach插入多条数据两种方法)</span><br><span class="hljs-comment">	int addEmpsBatch(@Param(&quot;emps&quot;) List&lt;Employee&gt; emps); --&gt;</span><br>	<span class="hljs-comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用<br>	<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>		INSERT INTO emp(ename,gender,email,did)<br>		VALUES<br>		<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>			(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>12345678910<br>	<span class="hljs-comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><br><span class="hljs-comment">	如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;;&quot;</span>&gt;</span><br>			INSERT INTO emp(ename,gender,email,did)<br>				VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>		<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>12345678<br></code></pre></td></tr></table></figure>

<ul>
<li>使用ExecutorType.BATCH<ul>
<li>Mybatis内置的ExecutorType有3种，默认为simple,该模式下它为每个语句的执行创建一个<br>新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所<br>有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，<br>在事务没有提交之前，是没有办法获取到自增的id，这在某型情形下是不符合业务要求的</li>
<li>具体用法如下：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">//批量保存方法测试</span><br>	<span class="hljs-meta">@Test</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>		<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> getSqlSessionFactory();<br>		<span class="hljs-comment">//可以执行批量操作的sqlSession</span><br>		<span class="hljs-type">SqlSession</span> <span class="hljs-variable">openSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);<br>		<span class="hljs-comment">//批量保存执行前时间</span><br>		<span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> openSession.getMapper(EmployeeMapper.class);<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>				mapper.addEmp(<span class="hljs-keyword">new</span><br>				<span class="hljs-title class_">Employee</span>(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>), <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));<br>			&#125;<br>			openSession.commit();<br>			<span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>			<span class="hljs-comment">//批量保存执行后的时间</span><br>			System.out.println(<span class="hljs-string">&quot;执行时长&quot;</span> + (end - start));<br>			<span class="hljs-comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次 677</span><br>			<span class="hljs-comment">//非批量 （预编译=设置参数=执行 ）==》10000次 1121</span><br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			openSession.close();<br>		&#125;<br>	&#125;<br><span class="hljs-number">123456789101112131415161718192021222324</span><br></code></pre></td></tr></table></figure>

<ul>
<li>mapper和mapper.xml如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br>		<span class="hljs-comment">//批量保存员工</span><br>		Long <span class="hljs-title function_">addEmp</span><span class="hljs-params">(Employee employee)</span>;<br>	&#125;<br><span class="hljs-number">1234</span><br>	&lt;mapper namespace=<span class="hljs-string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span><br>		&lt;!--批量保存员工 --&gt;<br>		&lt;insert id=<span class="hljs-string">&quot;addEmp&quot;</span>&gt;<br>			insert into <span class="hljs-title function_">employee</span><span class="hljs-params">(lastName,email,gender)</span><br>				values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)<br>		&lt;/insert&gt;<br>	&lt;/mapper&gt;<br></code></pre></td></tr></table></figure>

<h5 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键"></a>如何获取生成的主键</h5><ul>
<li>新增标签中添加：keyProperty&#x3D;” ID “ 即可</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> &gt;</span><br>		insert into user(user_name, user_password, create_time)<br>		values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=TIMESTAMP&#125;)<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>1234<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/4a845e6cf73248c688d43ac8a00bc069.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<h5 id="当实体类中的属性名和表中的字段名不一样-，怎么办"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办</h5><ul>
<li>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br>		select order_id id, order_no orderno ,order_price price form orders<br>		where order_id=#&#123;id&#125;;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>1234<br></code></pre></td></tr></table></figure>

<ul>
<li>第2种： 通过 来映射字段名和实体类属性名的一一对应的关系。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;select id=<span class="hljs-string">&quot;getOrder&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultMap=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;<br>	select * from orders where order_id=#&#123;id&#125;<br>&lt;/select&gt;<br>&lt;resultMap type=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span> id=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;<br>	&lt;!–用id属性来映射主键字段–&gt;<br>	&lt;id property=<span class="hljs-string">&quot;id&quot;</span> column=<span class="hljs-string">&quot;order_id&quot;</span>&gt;<br>	&lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;<br>	&lt;<span class="hljs-type">result</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;orderno&quot;</span> column =<span class="hljs-string">&quot;order_no&quot;</span>/&gt;<br>	&lt;result property=<span class="hljs-string">&quot;price&quot;</span> column=<span class="hljs-string">&quot;order_price&quot;</span> /&gt;<br>&lt;/reslutMap&gt;<br></code></pre></td></tr></table></figure>

<h5 id="Mapper-编写有哪几种方式？"><a href="#Mapper-编写有哪几种方式？" class="headerlink" title="Mapper 编写有哪几种方式？"></a>Mapper 编写有哪几种方式？</h5><ul>
<li>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，<br>mapper 接口实现类、mapper.xml 文件。</li>
</ul>
<ol>
<li>在 sqlMapConfig.xml 中配置 mapper.xml 的位置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br>1234<br></code></pre></td></tr></table></figure>

<ol>
<li>定义 mapper 接口</li>
<li>实现类集成 SqlSessionDaoSupport<br>mapper 方法中可以 this.getSqlSession()进行数据增删改查。</li>
<li>spring 配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot; &quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mapper 接口的实现&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span><span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>123<br></code></pre></td></tr></table></figure>

<ul>
<li>第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</li>
</ul>
<ol>
<li>在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名<br>称相同且在同一个目录，这里可以不用配置</li>
<li>定义 mapper 接口：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper.xml 文件的地址&quot;</span> /&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br>1234<br></code></pre></td></tr></table></figure>

<ol>
<li>mapper.xml 中的 namespace 为 mapper 接口的地址</li>
<li>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</li>
<li>Spring 中定义</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mapper 接口地址&quot;</span> /&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>1234<br></code></pre></td></tr></table></figure>

<ul>
<li>第三种：使用 mapper 扫描器：</li>
</ul>
<ol>
<li>mapper.xml 文件编写：<br>mapper.xml 中的 namespace 为 mapper 接口的地址；<br>mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；<br>如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</li>
<li>定义 mapper 接口：<br>注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</li>
<li>配置 mapper 扫描器：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mapper 接口包地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>1234<br></code></pre></td></tr></table></figure>

<ol>
<li>使用扫描器后从 spring 容器中获取 mapper 的实现对象</li>
</ol>
<h5 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h5><ul>
<li>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调<br>用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</li>
<li>接口绑定有两种实现方式<br>1.通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来<br>绑定；<br>2.通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为<br>接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml<br>绑定，一般用xml绑定的比较多。</li>
</ul>
<h5 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h5><ol>
<li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</li>
<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相<br>同。</li>
<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</li>
<li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li>
</ol>
<h5 id="这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h5><ul>
<li>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理<br>proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将<br>sql执行结果返回。</li>
<li>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</li>
</ul>
<h5 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h5><ul>
<li>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那<br>么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</li>
<li>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有<br>namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重<br>复，namespace不同，namespace+id自然也就不同。</li>
</ul>
<h5 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h5><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射<br>文件中， 标签会被解析为ParameterMap对象，其每个子元素会被解析为<br>ParameterMapping对象。 标签会被解析为ResultMap对象，其每个子元素会被解<br>析为ResultMapping对象。每一个 、 、 、 标签均会被<br>解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象</p>
<h5 id="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h5><ul>
<li>第一种是使用 标签，逐一定义列名和对象属性名之间的映射关系。</li>
<li>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性<br>名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应<br>对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</li>
</ul>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h4 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h4><ul>
<li>还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、<br><code>&lt;selectKey&gt;</code> ，加上动态sql的9个标签，<br>trim|where|set|foreach|if|choose|when|otherwise|bind等，其中 为sql片段标签，通<br>过<code>&lt;include&gt; </code>标签引入sql片段，<code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</li>
</ul>
<h5 id="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面"><a href="#Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面" class="headerlink" title="Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面"></a>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面</h5><ul>
<li>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地<br>方，Mybatis都可以正确识别。</li>
<li>原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此<br>时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解<br>析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，<br>A标签也就可以正常解析完成了。</li>
</ul>
<h5 id="Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法"><a href="#Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法" class="headerlink" title="Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法"></a>Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法</h5><ul>
<li>能，不止可以一对多，一对一还可以多对多，一对多</li>
<li>实现方式：<br>1.单独发送一个SQL去查询关联对象，赋给主对象，然后返回主对象<br>2.使用嵌套查询，似JOIN查询，一部分是A对象的属性值，另一部分是关联对 象 B的属性值，<br>好处是只要发送一个属性值，就可以把主对象和关联对象查出来<br>3.子查询</li>
</ul>
<h5 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h5><ul>
<li>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射<br>方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</li>
<li>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至<br>javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参<br>数和获取列查询结果。</li>
</ul>
<h5 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理吗？</h5><ul>
<li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态<br>拼接sql的功能，Mybatis提供了9种动态sql标签<br>trim|where|set|foreach|if|choose|when|otherwise|bind。</li>
<li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此<br>来完成动态sql的功能。</li>
</ul>
<h5 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h5><ul>
<li>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分<br>页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成<br>物理分页。</li>
<li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截<br>待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li>
<li>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</li>
</ul>
<h5 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h5><ul>
<li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、<br>Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现<br>接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<br>InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>
<li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一<br>个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li>
</ul>
<h5 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h5><ol>
<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session<br>flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li>
<li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其<br>存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓<br>存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状<br>态),可在它的映射文件中配置</li>
<li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了<br>C&#x2F;U&#x2F;D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li>
</ol>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h5 id="什么是springboot"><a href="#什么是springboot" class="headerlink" title="什么是springboot"></a>什么是springboot</h5><ul>
<li>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用<br>Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</li>
</ul>
<h5 id="为什么要用springboot"><a href="#为什么要用springboot" class="headerlink" title="为什么要用springboot"></a>为什么要用springboot</h5><ul>
<li>快速开发，快速整合，配置简化、内嵌服务容器</li>
</ul>
<h5 id="springboot与SpringCloud的区别"><a href="#springboot与SpringCloud的区别" class="headerlink" title="springboot与SpringCloud的区别"></a>springboot与SpringCloud的区别</h5><ul>
<li>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</li>
</ul>
<h5 id="springboot有哪些优点"><a href="#springboot有哪些优点" class="headerlink" title="springboot有哪些优点"></a>springboot有哪些优点</h5><p>Spring Boot 主要有如下优点：<br>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。<br>开箱即用，远离繁琐的配置。<br>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监<br>控、运行状况检查和外部化配置等。<br>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等5</p>
<h5 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h5><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含<br>了以下 3 个注解：<br>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。<br>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例<br>如： java 如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。<br>@ComponentScan：Spring组件扫描。</p>
<h5 id="Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？"><a href="#Spring-Boot-支持哪些日志框架？推荐和默认的日志框架是哪个？" class="headerlink" title="Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？"></a>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h5><p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动<br>器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置<br>文件输出到控制台或者文件中。</p>
<h5 id="SpringBoot-Starter的工作原理"><a href="#SpringBoot-Starter的工作原理" class="headerlink" title="SpringBoot Starter的工作原理"></a>SpringBoot <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Starter&spm=1001.2101.3001.7020">Starter</a>的工作原理</h5><p>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter<br>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的<br>spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把<br>bean注入SpringContext中 &#x2F;&#x2F;（SpringContext是Spring的配置文件）</p>
<h5 id="Spring-Boot-2-X-有什么新特性？与-1-X-有什么区别？"><a href="#Spring-Boot-2-X-有什么新特性？与-1-X-有什么区别？" class="headerlink" title="Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？"></a>Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h5><ul>
<li>配置变更</li>
<li>JDK 版本升级</li>
<li>第三方类库升级</li>
<li>响应式 Spring 编程支持</li>
<li>HTTP&#x2F;2 支持</li>
<li>配置属性绑定</li>
<li>更多改进与加强</li>
</ul>
<h5 id="运行-Spring-Boot-有哪几种方式"><a href="#运行-Spring-Boot-有哪几种方式" class="headerlink" title="运行 Spring Boot 有哪几种方式"></a>运行 Spring Boot 有哪几种方式</h5><ol>
<li>打包用命令或者放到容器中运行</li>
<li>用 Maven&#x2F; Gradle 插件运行</li>
<li>直接执行 main 方法运行</li>
</ol>
<h5 id="Spring-Boot-需要独立的容器运行吗"><a href="#Spring-Boot-需要独立的容器运行吗" class="headerlink" title="Spring Boot 需要独立的容器运行吗"></a>Spring Boot 需要独立的容器运行吗</h5><ul>
<li>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</li>
</ul>
<h5 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h5><ol>
<li>继承spring-boot-starter-parent项目</li>
<li>导入spring-boot-dependencies项目依赖</li>
</ol>
<h5 id="SpringBoot-实现热部署有哪几种方式？"><a href="#SpringBoot-实现热部署有哪几种方式？" class="headerlink" title="SpringBoot 实现热部署有哪几种方式？"></a>SpringBoot 实现<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%83%AD%E9%83%A8%E7%BD%B2&spm=1001.2101.3001.7020">热部署</a>有哪几种方式？</h5><ul>
<li>热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中</li>
<li>主要有两种方式：<ul>
<li>Spring Loaded</li>
<li>Spring-boot-devtools</li>
</ul>
</li>
</ul>
<h5 id="SpringBoot事物的使用"><a href="#SpringBoot事物的使用" class="headerlink" title="SpringBoot事物的使用"></a>SpringBoot事物的使用</h5><ul>
<li>SpringBoot的事物很简单，首先使用注解EnableTransactionManagement开启事物之后，然后在<br>Service方法上添加注解Transactional便可。</li>
</ul>
<h5 id="Async异步调用方法"><a href="#Async异步调用方法" class="headerlink" title="Async异步调用方法"></a>Async异步调用方法</h5><ul>
<li>在SpringBoot中使用异步调用是很简单的，只需要在方法上使用@Async注解即可实现方法的异步<br>调用。 注意：需要在启动类加入@EnableAsync使异步调用@Async注解生效。</li>
</ul>
<h5 id="如何在-Spring-Boot-启动的时候运行一些特定的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特定的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特定的代码？"></a>如何在 Spring Boot 启动的时候运行一些特定的代码？</h5><ul>
<li>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们<br>都只提供了一个 run 方法</li>
</ul>
<h5 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h5><ul>
<li>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注<br>解来绑定变量</li>
</ul>
<h5 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h5><p>Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他，它提供了配置 Spring IOC 容器的<br>纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<br>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。<br>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。<br>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java<br>5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字<br>符串的查找。<br>常用的Java config：<br>@Configuration：在类上打上写下此注解，表示这个类是配置类<br>@ComponentScan：在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan &gt;。<br>@Bean：bean的注入：相当于以前的&lt; bean id&#x3D;“objectMapper”<br>class&#x3D;“org.codehaus.jackson.map.ObjectMapper” &#x2F;&gt;<br>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven &gt;<br>@ImportResource： 相当于xml的 &lt; import resource&#x3D;“applicationContextcache.xml”&gt;</p>
<h5 id="SpringBoot的自动配置原理是什么"><a href="#SpringBoot的自动配置原理是什么" class="headerlink" title="SpringBoot的自动配置原理是什么"></a>SpringBoot的自动配置原理是什么</h5><p>主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置<br>类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。<br>有了这个EnableAutoConfiguration的话就会：<br>从配置文件META_INF&#x2F;Spring.factories加载可能用到的自动配置类<br>去重，并将exclude和excludeName属性携带的类排除<br>过滤，将满足条件（@Conditional）的自动配置类返回</p>
<h5 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h5><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。<br>1.properties文件；<br>2.YAML文件；<br>3.系统环境变量；<br>4.命令行参数；</p>
<h5 id="什么是-YAML？"><a href="#什么是-YAML？" class="headerlink" title="什么是 YAML？"></a>什么是 YAML？</h5><ul>
<li>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要<br>在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分<br>层配置数据。</li>
</ul>
<h5 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里"></a>YAML 配置的优势在哪里</h5><ul>
<li>AML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配<br>置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？<br>配置有序，在一些特殊的场景下，配置有序很关键<br>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象<br>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入<br>自定义的 YAML 配置。</li>
</ul>
<h5 id="spring-Boot-是否可以使用-XML-配置"><a href="#spring-Boot-是否可以使用-XML-配置" class="headerlink" title="spring Boot 是否可以使用 XML 配置 ?"></a>spring Boot 是否可以使用 XML 配置 ?</h5><ul>
<li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通<br>过 @ImportResource 注解可以引入一个 XML 配置。</li>
</ul>
<h5 id="spring-boot-核心配置文件是什么？bootstrap-properties-和application-properties-有何区别"><a href="#spring-boot-核心配置文件是什么？bootstrap-properties-和application-properties-有何区别" class="headerlink" title="spring boot 核心配置文件是什么？bootstrap.properties 和application.properties 有何区别 ?"></a>spring boot 核心配置文件是什么？bootstrap.properties 和application.properties 有何区别 ?</h5><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。<br>spring boot 核心的两个配置文件：<br>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目<br>的自动化配置。</p>
<h5 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h5><p>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连<br>接、redis的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了<br>profiles机制给我们提供的就是来回切换配置文件的功能<br>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序<br>在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。<br>假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文<br>件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<h5 id="SpringBoot多数据源拆分的思路"><a href="#SpringBoot多数据源拆分的思路" class="headerlink" title="SpringBoot多数据源拆分的思路"></a>SpringBoot多数据源拆分的思路</h5><ul>
<li>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties<br>读取properties中的配置，使用@MapperScan注册到对应的mapper包中</li>
</ul>
<h5 id="SpringBoot多数据源事务如何管理"><a href="#SpringBoot多数据源事务如何管理" class="headerlink" title="SpringBoot多数据源事务如何管理"></a>SpringBoot多数据源事务如何管理</h5><ul>
<li>第一种方式是在service层的@TransactionManager中使用transactionManager指定<br>DataSourceConfig中配置的事务</li>
<li>第二种是使用jta-atomikos实现分布式事务管理</li>
</ul>
<h5 id="保护-Spring-Boot-应用有哪些方法？"><a href="#保护-Spring-Boot-应用有哪些方法？" class="headerlink" title="保护 Spring Boot 应用有哪些方法？"></a>保护 Spring Boot 应用有哪些方法？</h5><ul>
<li>在生产中使用HTTPS</li>
<li>使用Snyk检查你的依赖关系</li>
<li>升级到最新版本</li>
<li>启用CSRF保护</li>
<li>使用内容安全策略防止XSS攻击</li>
</ul>
<h5 id="比较一下-Spring-Security-和-Shiro-各自的优缺点"><a href="#比较一下-Spring-Security-和-Shiro-各自的优缺点" class="headerlink" title="比较一下 Spring Security 和 Shiro 各自的优缺点 ?"></a>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h5><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的<br>Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就<br>可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是<br>一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security<br>相比，主要有如下一些特点：<br>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架<br>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单<br>Spring Security 功能强大；Shiro 功能简单</p>
<h5 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h5><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请<br>求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Crossorigin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的<br>SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，<br>现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> &#123;<br>		registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>		.allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>		.allowCredentials(<span class="hljs-literal">true</span>)<br>		.allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>)<br>		.maxAge(<span class="hljs-number">3600</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h5><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生<br>产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一<br>些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接<br>作为 HTTP URL 访问的REST 端点来检查状态。</p>
<h5 id="如何使用-Spring-Boot-实现全局异常处理？"><a href="#如何使用-Spring-Boot-实现全局异常处理？" class="headerlink" title="如何使用 Spring Boot 实现全局异常处理？"></a>如何使用 Spring Boot 实现全局异常处理？</h5><ul>
<li>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个<br>ControlerAdvice 类，来处理控制器类抛出的所有异常。</li>
</ul>
<h5 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h5><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息<br>（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器<br>的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一<br>下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助<br>我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供<br>了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<h5 id="SpringBoot性能如何优化"><a href="#SpringBoot性能如何优化" class="headerlink" title="SpringBoot性能如何优化"></a>SpringBoot性能如何优化</h5><ul>
<li>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范<br>围</li>
<li>在项目启动时设置JVM初始内存和最大内存相同</li>
<li>将springboot内置服务器由tomcat设置为underto</li>
</ul>
<h5 id="SpringBoot微服务中如何实现-session-共享"><a href="#SpringBoot微服务中如何实现-session-共享" class="headerlink" title="SpringBoot微服务中如何实现 session 共享 ?"></a>SpringBoot微服务中如何实现 session 共享 ?</h5><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务<br>器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享<br>session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的<br>session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上<br>的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使<br>得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<h5 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h5><p>使用了下面的一些依赖项<br>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持<br>spring-boot-starter-data-jpa 数据库支持<br>spring-boot-starter-data-redis redis数据库支持<br>spring-boot-starter-data-solr solr支持<br>mybatis-spring-boot-starter 第三方的mybatis集成starter<br>自定义的starter(如果自己开发过就可以说出来)</p>
<h5 id="Spring-Boot-中的-starter-到底是什么"><a href="#Spring-Boot-中的-starter-到底是什么" class="headerlink" title="Spring Boot 中的 starter 到底是什么 ?"></a>Spring Boot 中的 starter 到底是什么 ?</h5><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提<br>供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来<br>决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配<br>置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)注入<br>将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们<br>只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<h5 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h5><ul>
<li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled<br>注解，另一-个则是使用第三方框架 Quartz。</li>
<li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li>
</ul>
<h5 id="spring-boot-starter-parent-有什么用"><a href="#spring-boot-starter-parent-有什么用" class="headerlink" title="spring-boot-starter-parent 有什么用 ?"></a>spring-boot-starter-parent 有什么用 ?</h5><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 springboot-starter-parent ，spring-boot-starter-parent 主要有如下作用：<br>定义了 Java 编译版本为 1.8 。<br>使用 UTF-8 格式编码。<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依<br>赖，所以我们在写依赖时才不需要写版本号。<br>执行打包操作的配置。<br>自动化的资源过滤。<br>自动化的插件配置。<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同<br>环境的配置文件，例如 application-dev.properties 和 application-dev.yml。<br>总结就是打包用的</p>
<h5 id="SpringBoot如何实现打包"><a href="#SpringBoot如何实现打包" class="headerlink" title="SpringBoot如何实现打包"></a>SpringBoot如何实现打包</h5><ul>
<li>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打<br>包</li>
<li>或者点击左边选项栏中的Mavne，先点击clean在点击package</li>
</ul>
<h5 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别"><a href="#Spring-Boot-打成的-jar-和普通的-jar-有什么区别" class="headerlink" title="Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?"></a>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h5><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命<br>令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。<br>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压<br>后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOTINF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
<h3 id="SpringCloud-x2F-SpringCloud-ALiBaBa"><a href="#SpringCloud-x2F-SpringCloud-ALiBaBa" class="headerlink" title="SpringCloud&#x2F;SpringCloud ALiBaBa"></a>SpringCloud&#x2F;SpringCloud ALiBaBa</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><h4 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h4><h5 id="说说mysql的基本结构"><a href="#说说mysql的基本结构" class="headerlink" title="说说mysql的基本结构"></a>说说mysql的基本结构</h5><blockquote>
<p>建议配合 <a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p>
</blockquote>
<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>
<p><img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>从上图可以看出， MySQL 主要由下面几部分构成：</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<h4 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h4><h5 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="MySQL 支持哪些存储引擎？默认使用哪个？"></a>MySQL 支持哪些存储引擎？默认使用哪个？</h5><p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510105408703.png" srcset="/img/loading.gif" lazyload alt="查看 MySQL 提供的所有存储引擎">查看 MySQL 提供的所有存储引擎</p>
<p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
<p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p>
<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<h5 id="MySQL-存储引擎架构了解吗？"><a href="#MySQL-存储引擎架构了解吗？" class="headerlink" title="MySQL 存储引擎架构了解吗？"></a>MySQL 存储引擎架构了解吗？</h5><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据</strong></p>
<h5 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="MyISAM 和 InnoDB 有什么区别？"></a>MyISAM 和 InnoDB 有什么区别？</h5><p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>
<p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解 </a>。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/mysql/image-20220510090309427.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p>
<p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p>
<p><strong>6.索引实现不一样。</strong></p>
<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>
<p>详细区别，推荐你看看我写的这篇文章：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-index.html">MySQL 索引详解 </a>。</p>
<p><strong>7.性能有差别。</strong></p>
<p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/mysql/innodb-myisam-performance-comparison.png" srcset="/img/loading.gif" lazyload alt="InnoDB 和 MyISAM 性能对比">InnoDB 和 MyISAM 性能对比</p>
<p><strong>总结</strong> ：</p>
<ul>
<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li>
<li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>
<li>MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>
<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
<p>最后，再分享一张图片给你，这张图片详细对比了常见的几种 MySQL 存储引擎。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/mysql/comparison-of-common-mysql-storage-engines.png" srcset="/img/loading.gif" lazyload alt="常见的几种 MySQL 存储引擎对比">常见的</p>
<h4 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h4><h5 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h5><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>
<blockquote>
<p>换句话说，索引是牺牲空间换区时间的一种手段和方法</p>
</blockquote>
<h5 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h5><p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h5 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h5><p><strong>Hash 表</strong></p>
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hash = hashfunc(key)<br>index = hash % array_size<br></code></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/database/mysql20210513092328171.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/mysql20210513092224836.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>
<p>试想一种情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM tb1 WHERE id &lt; <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure>

<p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<p><strong>B 树&amp; B+树</strong></p>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<blockquote>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</blockquote>
<h5 id="索引类型总结"><a href="#索引类型总结" class="headerlink" title="索引类型总结"></a>索引类型总结</h5><p>按照数据结构维度划分：</p>
<ul>
<li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li>
<li>哈希索引：类似键值对的形式，一次即可定位。</li>
<li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>按照底层存储方式角度划分：</p>
<ul>
<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>
<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>
</ul>
<p>按照应用维度划分：</p>
<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li>
<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>MySQL 8.x 中实现的索引新特性：</p>
<ul>
<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>
<li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>
<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>
</ul>
<h5 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h5><p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/open-source-project/cluster-index.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h5><p><strong>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p>二级索引:</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/open-source-project/no-cluster-index.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h5><h6 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h6><p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p>
<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p>聚簇索引的优缺点</p>
<p><strong>优点</strong> ：</p>
<ul>
<li><strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h6 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h6><p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p>
<p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<p>非聚簇索引的优缺点</p>
<p><strong>优点</strong> ：</p>
<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>
<p><strong>缺点</strong> ：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p>这是 MySQL 的表的文件截图:</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/mysql20210420165311654.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>聚簇索引和非聚簇索引:</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/mysql20210420165326946.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="非聚簇索引一定要回表吗？"><a href="#非聚簇索引一定要回表吗？" class="headerlink" title="非聚簇索引一定要回表吗？"></a>非聚簇索引一定要回表吗？</h5><p>答案肯定是不一定，比如查询语句刚好查询就是索引本身</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;guang19&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h5 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h5><h6 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h6><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/mysql20210420165341868.png" srcset="/img/loading.gif" lazyload alt="覆盖索引">覆盖索引</p>
<p>我们这里简单演示一下覆盖索引的效果。</p>
<p>1、创建一个名为 <code>cus_order</code> 的表，来实际测试一下这种排序方式。为了测试方便， <code>cus_order</code> 这张表只有 <code>id</code>、<code>score</code>、<code>name</code>这 3 个字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `cus_order` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `score` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">100000</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;<br></code></pre></td></tr></table></figure>

<p>2、定义一个简单的存储过程（PROCEDURE）来插入 100w 测试数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER ;;<br><span class="hljs-keyword">CREATE</span> DEFINER<span class="hljs-operator">=</span>`root`@`<span class="hljs-operator">%</span>` <span class="hljs-keyword">PROCEDURE</span> `BatchinsertDataToCusOder`(<span class="hljs-keyword">IN</span> start_num <span class="hljs-type">INT</span>,<span class="hljs-keyword">IN</span> max_num <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span><br>      <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">default</span> start_num;<br>      WHILE i <span class="hljs-operator">&lt;</span> max_num DO<br>          <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> `cus_order`(`id`, `score`, `name`)<br>          <span class="hljs-keyword">values</span> (i,RAND() <span class="hljs-operator">*</span> <span class="hljs-number">1000000</span>,CONCAT(<span class="hljs-string">&#x27;user&#x27;</span>, i));<br>          <span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">END</span> WHILE;<br>  <span class="hljs-keyword">END</span>;;<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>存储过程定义完成之后，我们执行存储过程即可！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> BatchinsertDataToCusOder(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>); # 插入<span class="hljs-number">100</span>w<span class="hljs-operator">+</span>的随机数据<br></code></pre></td></tr></table></figure>

<p>等待一会，100w 的测试数据就插入完成了！</p>
<p>3、创建覆盖索引并使用 <code>EXPLAIN</code> 命令分析。</p>
<p>为了能够对这 100w 数据按照 <code>score</code> 进行排序，我们需要执行下面的 SQL 语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `score`,`name` <span class="hljs-keyword">FROM</span> `cus_order` <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> `score` <span class="hljs-keyword">DESC</span>;#降序排序<br></code></pre></td></tr></table></figure>

<p>使用 <code>EXPLAIN</code> 命令分析这条 SQL 语句，通过 <code>Extra</code> 这一列的 <code>Using filesort</code> ，我们发现是没有用到覆盖索引的。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/mysql/not-using-covering-index-demo.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>不过这也是理所应当，毕竟我们现在还没有创建索引呢！</p>
<p>我们这里以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `cus_order` <span class="hljs-keyword">ADD</span> INDEX id_score_name(score, name);<br></code></pre></td></tr></table></figure>

<p>创建完成之后，再用 <code>EXPLAIN</code> 命令分析再次分析这条 SQL 语句。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/mysql/using-covering-index-demo.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>通过 <code>Extra</code> 这一列的 <code>Using index</code> ，说明这条 SQL 语句成功使用了覆盖索引。</p>
<h5 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h5><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>
<h5 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h5><h6 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h6><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p>
<p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
<p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
<p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<h6 id="频繁更新的字段应该慎重简历索引"><a href="#频繁更新的字段应该慎重简历索引" class="headerlink" title="频繁更新的字段应该慎重简历索引"></a>频繁更新的字段应该慎重简历索引</h6><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了</p>
<h6 id="限制每张表上的索引数量"><a href="#限制每张表上的索引数量" class="headerlink" title="限制每张表上的索引数量"></a>限制每张表上的索引数量</h6><p>索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h6 id="尽可能建立联合索引而不是单列索引"><a href="#尽可能建立联合索引而不是单列索引" class="headerlink" title="尽可能建立联合索引而不是单列索引"></a>尽可能建立联合索引而不是单列索引</h6><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<h6 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h6><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h6 id="字符串类型的字段使用前缀索引代替普通索引"><a href="#字符串类型的字段使用前缀索引代替普通索引" class="headerlink" title="字符串类型的字段使用前缀索引代替普通索引"></a>字符串类型的字段使用前缀索引代替普通索引</h6><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h6 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h6><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li>使用 <code>SELECT *</code> 进行查询;</li>
<li>创建了组合索引，但查询条件未遵守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;</code>;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html">隐式转换</a>;</li>
</ul>
<h6 id="删除长时间未使用的索引"><a href="#删除长时间未使用的索引" class="headerlink" title="删除长时间未使用的索引"></a>删除长时间未使用的索引</h6><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p>
<p>MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</p>
<h4 id="Mysql常见面试题"><a href="#Mysql常见面试题" class="headerlink" title="Mysql常见面试题"></a>Mysql常见面试题</h4><h5 id="执行一条查询语句的时候发生了什么"><a href="#执行一条查询语句的时候发生了什么" class="headerlink" title="执行一条查询语句的时候发生了什么"></a>执行一条查询语句的时候发生了什么</h5><p>学习 SQL 的时候，大家肯定第一个先学到的就是 select 查询语句了，比如下面这句查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> 在 product 表中，查询 id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> 的记录<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>但是有没有想过，<strong>MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？</strong></p>
<p>带着这个问题，我们可以很好的了解 MySQL 内部的架构，所以这次小林就带大家拆解一下 MySQL 内部的结构，看看内部里的每一个“零件”具体是负责做什么的。</p>
<p><strong>首先要明白mysql的执行流程</strong></p>
<p>先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="查询语句执行流程"></p>
<p>可以看到， MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong>，</p>
<ul>
<li><strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。</li>
<li><strong>存储引擎层负责数据的存储和提取</strong>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。</li>
</ul>
<p>执行一条 SQL 查询语句，期间发生了什么？</p>
<ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：<ul>
<li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
</li>
</ul>
<h5 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h5><p>①char设置多少长度就是多少长度，varchar可以改变长度，所以char的空间利用率不如varchar的空间利用率高。<br>②因为长度固定，所以存取速度要比varchar快。<br>③char适用于固定长度的字符串，比如身份证号、手机号等，varchar适用于不固定的字符串。</p>
<h5 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h5><p><strong>第一范式(1NF)：</strong> 保证字段不可再分，保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&spm=1001.2101.3001.7020">原子性</a>。<br><strong>第二范式(2NF)：</strong> 满足1NF前提下，表的每一列都必须和主键有关系。消除部分依赖关系。<br><strong>第三范式(3NF)：</strong> 满足2NF前提下，表的每一列比必须和主键有直接关系，不能是间接关系。消除传递依赖</p>
<h5 id="sql的执行顺序"><a href="#sql的执行顺序" class="headerlink" title="sql的执行顺序"></a>sql的执行顺序</h5><p>⑧select ⑨distinct(去重) ⑥聚合函数</p>
<p>①from 表1</p>
<p>③inner join | left join | right join(连接) 表2</p>
<p>②on(连接条件) 表1.字段 &#x3D; 表2.字段</p>
<p>④where 查询条件</p>
<p>⑤group by(分组) 字段</p>
<p>⑦having 分组过滤条件</p>
<p>⑩order by(排序) 字段</p>
<p>⑪limit(分页) 0,10</p>
<h5 id="什么是索引-1"><a href="#什么是索引-1" class="headerlink" title="什么是索引"></a>什么是索引</h5><p>索引是一种高效的数据结构，相当于目录，更快的找到数据，是一个文件，占用物理空间。在mysql5.7之后默认使用innodb作为存储引擎，innodb采用的索引结构是B+树。</p>
<h5 id="索引的优缺点-1"><a href="#索引的优缺点-1" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h5><p>优点：</p>
<ul>
<li>提高检索的速度</li>
<li>降低排序成本</li>
</ul>
<p>缺点：</p>
<ul>
<li>占用额外空间</li>
<li>降低更新速度（因为不仅要更新数据，还要更新索引）</li>
</ul>
<h5 id="索引有哪些类型"><a href="#索引有哪些类型" class="headerlink" title="索引有哪些类型"></a>索引有哪些类型</h5><ul>
<li>普通索引（基本索引类型，允许定义索引的字段为空和重复值）</li>
<li>唯一索引（索引的值唯一，允许索引的字段为空值）</li>
<li>主键索引（索引的值必须唯一且非空）</li>
<li>联合索引（将多个字段一起聚集为一个索引）</li>
</ul>
<blockquote>
<p>这一个问题比较开放，可以根据各种大分类回答，比如根据是否将数据和索引结构一起存放分为聚簇索引和非聚簇索引等等</p>
<ul>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ul>
</blockquote>
<h5 id="怎么设计索引"><a href="#怎么设计索引" class="headerlink" title="怎么设计索引"></a>怎么设计索引</h5><ul>
<li>选择唯一性索引（值是惟一的，可以跟更快的查询）</li>
<li>为经常查询的字段添加索引</li>
<li>为经常要进行排序，分组和联合操作的数据进行增加索引（order by、group by、union(联合)、distinct(去重)等）</li>
<li>限制索引个数（索引要占用空间，同时更新索引很费时间）</li>
<li>表数据少就不要用索引</li>
<li>删除不常用的索引</li>
<li>用类型小的数据做索引</li>
<li>使用前缀索引，字符串越长，索引占用空间越大，比较起来花费时间就越长。</li>
</ul>
<h5 id="怎么避免索引失效"><a href="#怎么避免索引失效" class="headerlink" title="怎么避免索引失效"></a>怎么避免索引失效</h5><ul>
<li>进行范围查询时，&gt;,&lt;,like.bewteen和对null的判断会导致右边的的所有索引列失效</li>
<li>不要对索引字段进行函数运算</li>
<li>在where子句中不要使用OR,!&#x3D;,&lt;&gt;和其他的比较运算符</li>
<li>避免左模糊查询%*</li>
<li>字符串不加单引号导致索引失效</li>
</ul>
<h5 id="索引的数据类型"><a href="#索引的数据类型" class="headerlink" title="索引的数据类型"></a>索引的数据类型</h5><p>索引的数据类型主要分为两种</p>
<ul>
<li><strong>B+树</strong>：每次从根节点出发去查询，然后得到地址，回表查询实际数据。</li>
<li><strong>Hash</strong>：查询时调用Hash函数获得地址，回表查询实际数据。(InnoDB和MylSAM不支持，Memory支持)。查询时调用Hash函数获得地址，回表查询实际数据。(InnoDB和MylSAM不支持，Memory支持)。</li>
</ul>
<h5 id="索引为什么使用树结构"><a href="#索引为什么使用树结构" class="headerlink" title="索引为什么使用树结构"></a>索引为什么使用树结构</h5><p>因为可以加快查询速度</p>
<h5 id="二叉查找树、B树、B-树"><a href="#二叉查找树、B树、B-树" class="headerlink" title="二叉查找树、B树、B+树"></a>二叉查找树、B树、B+树</h5><p>二叉查找树(二叉排序树、二叉搜索树)： 一个节点最多两个子节点(左小右大)，查询次数和比较次数都是最小的，但是索引是存在磁盘的，当数据量过大的时候，不能直接把整个索引文件加载到内存，需要分多次IO，最坏的情况IO的次数就是树的高度，为了减少IO，需要把树从竖向变成横向。<br>B树( B- )： 是一种多路查询树，每个节点包含K个子节点，节点都存储索引值和数据，K是B树的阶(树高被称为树的阶)。虽然比较的次数比较多，但是是在内存的比较，可以忽略不计，但是B树IO的次数要比二叉查找树要少，因为B树的高度可以更低。<br>B+树： B树的升级版，只有叶子节点储存的是索引值指向的数据库的数据。</p>
<h5 id="为什么用B-树而不用二叉树或者红黑树或者B树"><a href="#为什么用B-树而不用二叉树或者红黑树或者B树" class="headerlink" title="为什么用B+树而不用二叉树或者红黑树或者B树"></a>为什么用B+树而不用二叉树或者红黑树或者B树</h5><p>①B树只适合随机检索，而B+树同时支持随机检索和顺序检索(因为叶子节点相当于链表，保存索引值都是有序的)。<br>顺序检索： 按照序列顺序遍历比较找到给定值。<br>随机检索： 不断从序列中随机抽取数据进行比较，最终找到结果。</p>
<p>②减少了磁盘IO，提高空间利用率： 因为B+树非叶子节点不会存放数据，只有索引值，所以非叶子节点可以保存更多的索引值，这样B+树就可以更矮，减少IO次数。</p>
<p>③B+树适合范围查找： 这才是关键，因为数据库大部分都是范围查找，B+树的叶子节点是有序链表，直接遍历就行，而B树的范围查找可能两个节点距离很远，只能通过中序遍历去查找，所以使用B+树更合适。<br>中序遍历： (根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）</p>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p>最左优先，以最左边为起点任何连续的索引都能匹配上。同时遇到范围查询（&gt;、&lt;、between and、like）就会停止匹配。</p>
<p>例如：Z表建立联合索引 (a,b,c)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>这样索引abc列都起效，因为符合最左匹配原则，<span class="hljs-keyword">where</span>子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序<br><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> Z <span class="hljs-keyword">where</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>因为a列是起点，没有a列匹配不上，所以索引失效<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">where</span>  b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>因为连续不到b，所以只有a列索引生效<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">where</span>  a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure>

<h5 id="MylSAM和InnoDB、Memory的区别"><a href="#MylSAM和InnoDB、Memory的区别" class="headerlink" title="MylSAM和InnoDB、Memory的区别"></a>MylSAM和InnoDB、Memory的区别</h5><p>MylSAM： mysql5.5之前的存储引擎，是表锁（悲观锁）级别的，不支持事务和外键。<br>InnoDB： mysql5.5之后的存储引擎，是行锁（乐观锁）级别的，支持事务和外键。<br>Memory： 内存数据库引擎，因为在内存操作，所以读写很快，但是Mysql服务重启，会丢失数据，不支持事务和外键。</p>
<h5 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h5><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h5 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h5><ul>
<li>原子性(Atomicity)： 要么全部成功要么全部失败。</li>
<li>一致性(Consistency)： 事务执行前和事务执行后，原本和数据库一致的数据仍然一致。</li>
<li>隔离性(Isolation)： 事务与事务之间互不干扰。</li>
<li>持久性(Durability)： 事务一旦被提交了，那么对数据库中的数据的改变就是永久的。</li>
</ul>
<h5 id="脏读，不可重复度，幻读"><a href="#脏读，不可重复度，幻读" class="headerlink" title="脏读，不可重复度，幻读"></a>脏读，不可重复度，幻读</h5><ul>
<li>脏读： 也叫”读未提交”，顾名思义，就是某一事务A读取到了事务B未提交的数据。</li>
<li>不可重复读： 在一个事务内，多次读取同一个数据，却返回了不同的结果。实际上，这是因为在该事务间隔读取数据的期间，有其他事务对这段数据进行了修改，并且已经提交，就会发生不可重复读事故。</li>
<li>幻读： 在同一个事务中，第一次读取到结果集和第二次读取到的结果集不同。像幻觉一样所以叫幻读。</li>
</ul>
<p>从上面可以看出脏读和不可重复读是基于数据值的错误，幻读是基于条数增加或者减少的错误</p>
<h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><ul>
<li>读未提交:在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。读取未提交的数据，也被称之为脏读（Dirty Read）</li>
<li>读已提交：这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。一个事务只能看见已经提交事务所做的改变。可解决脏读</li>
<li>可重复读：这是MySQL的默认事务隔离级别，同一事务的多个实例在并发读取数据时，会看到同样的数据。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read），但是由于mvcc机制可以解决大部分的幻读。可解决脏读、不可重复读</li>
<li>串行化：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。可解决脏读、不可重复读、幻读。</li>
</ul>
<h5 id="怎么优化数据库"><a href="#怎么优化数据库" class="headerlink" title="怎么优化数据库"></a>怎么优化数据库</h5><ul>
<li>sql优化</li>
<li>加缓存</li>
<li>分库分表</li>
<li>读写分离</li>
</ul>
<h5 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h5><ul>
<li>不要使用select * 而是某个具体的字段</li>
<li>使用数字来替换字符串</li>
<li>避免返回大量数据，采用分页最好</li>
<li>使用索引，提升查询速度，不建议太多索引。</li>
<li>避免子查询，优化为多表连接查询</li>
<li>尽量使用union all替代union，因为union会自动去重。</li>
</ul>
<h5 id="常用的聚合函数"><a href="#常用的聚合函数" class="headerlink" title="常用的聚合函数"></a>常用的聚合函数</h5><p>①sum(列名) 求和 　　　　<br>②max(列名) 最大值 　　　　<br>③min(列名) 最小值 　　　　<br>④avg(列名) 平均值 　　　　<br>⑤first(列名) 第一条记录<br>⑥last(列名) 最后一条记录<br>⑦count(列名) 统计记录数不包含null值 count(*)包含null值。</p>
<h5 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h5><p><strong>内连接(inner join)：</strong> 查询两个表匹配数据。<br><strong>左连接(left join)：</strong> 查询左表全部行以及右表匹配的行。<br><strong>右连接(right join)：</strong> 查询右表全部行以及左表匹配的行。</p>
<h5 id="in和exsits的区别"><a href="#in和exsits的区别" class="headerlink" title="in和exsits的区别"></a>in和exsits的区别</h5><p><strong>in()：</strong> 适合子表(子查询)比主表数据小的情况。<br><strong>exists()：</strong> 适合子表(子查询)比主表数据大的情况。</p>
<h5 id="MVCC了解吗"><a href="#MVCC了解吗" class="headerlink" title="MVCC了解吗"></a>MVCC了解吗</h5><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YD4y1J7Qq/?spm_id_from=333.788&vd_source=baf5be2550e84a76455ae559b46746b8">5分钟精通数据库MVCC原理-事务的隔离性_哔哩哔哩_bilibili</a></p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="认识redis"><a href="#认识redis" class="headerlink" title="认识redis"></a>认识redis</h4><h5 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h5><p>redis是一种基于内存的数据库，对数据的读写都是在内存中完成的，运行速度非常快，常用于做缓存，分布式锁等场景。</p>
<p>同时redis提供了非常多的数据结构来支撑各种业务场景</p>
<p>比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p>
<p>除此之外，redis还支持事务，持久化，LUA脚本，多种集群方案（主从复制，哨兵模式，切片集群模式），发布订阅模式，内存淘汰机制，过期删除机制等。</p>
<h5 id="redis-和-Memcached-有什么区别？"><a href="#redis-和-Memcached-有什么区别？" class="headerlink" title="redis 和 Memcached 有什么区别？"></a>redis 和 Memcached 有什么区别？</h5><p>很多人都说用 Redis 作为缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，我们就要弄清楚 Redis 和 Memcached 的区别。 Redis 与 Memcached <strong>共同点</strong>：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p>Redis 与 Memcached <strong>区别</strong>：</p>
<ul>
<li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li>
</ul>
<h5 id="为什么用redis作为MySql的缓存？"><a href="#为什么用redis作为MySql的缓存？" class="headerlink" title="为什么用redis作为MySql的缓存？"></a>为什么用redis作为MySql的缓存？</h5><p>主要是因为redis的高性能和高并发</p>
<p><strong>redis具备高性能</strong></p>
<p>假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/37e4378d2edcb5e217b00e5f12973efd.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。</p>
<p><strong>redis具备高并发</strong></p>
<p>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p>
<p>所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h5 id="为什么redis快"><a href="#为什么redis快" class="headerlink" title="为什么redis快"></a>为什么redis快</h5><ul>
<li>基于内存</li>
<li>采用单线程，减少了线程上下文切换导致的性能损耗</li>
</ul>
<h4 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h4><h5 id="redis数据类型以及使用场景是什么"><a href="#redis数据类型以及使用场景是什么" class="headerlink" title="redis数据类型以及使用场景是什么"></a>redis数据类型以及使用场景是什么</h5><ul>
<li>String：字符串，常用于缓存对象，常规计数，分布式锁等</li>
<li>Hash：哈希，缓存对象，购物车等，</li>
<li>set：集合，聚合计算场景，比如点赞，共同关注，抽奖活动等</li>
<li>List：列表，消息队列</li>
<li>Zset：有序集合，排序</li>
<li>BitMap：二进制的数据，常用于统计场景，如签到，判断用户登录状态，连续签到等</li>
<li>HyperLogLog：海量数据统计的情景，比如百万级网页UV</li>
<li>Geo：地理位置的场景</li>
<li>Stream：消息队列，消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
<h5 id="五种常见的redis数据类型如何实现"><a href="#五种常见的redis数据类型如何实现" class="headerlink" title="五种常见的redis数据类型如何实现"></a>五种常见的redis数据类型如何实现</h5><p><strong>String的内部实现</strong></p>
<p>String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<p><strong>List</strong></p>
<p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<p><strong>Hash 类型内部实现</strong></p>
<p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的底层数据结构。</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<p><strong>Set 类型内部实现</strong></p>
<p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<p><strong>ZSet 类型内部实现</strong></p>
<p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p>
<h4 id="redis线程模型"><a href="#redis线程模型" class="headerlink" title="redis线程模型"></a>redis线程模型</h4><h5 id="redis是单线程吗"><a href="#redis是单线程吗" class="headerlink" title="redis是单线程吗"></a>redis是单线程吗</h5><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
<p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程</strong>（BIO）的：</p>
<ul>
<li><strong>Redis 在 2.6 版本</strong>，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务；</li>
<li><strong>Redis 在 4.0 版本之后</strong>，新增了一个新的后台线程，用来异步释放 Redis 内存，也就是 lazyfree 线程。例如执行 unlink key &#x2F; flushdb async &#x2F; flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大key。</li>
</ul>
<p>之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。</p>
<p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：</p>
<ul>
<li>BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；</li>
<li>BIO_AOF_FSYNC，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，</li>
<li>BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 &#x2F; free(dict) 删除数据库所有对象 &#x2F; free(skiplist) 释放跳表对象；</li>
</ul>
<h5 id="redis单线程模式是怎样的"><a href="#redis单线程模式是怎样的" class="headerlink" title="redis单线程模式是怎样的"></a>redis单线程模式是怎样的</h5><p>Redis 6.0 版本之前的单线模式如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.drawio.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到网络 I&#x2F;O 和命令处理都是单线程。 Redis 初始化的时候，会做下面这几件事情：</p>
<ul>
<li>首先，调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li>
<li>然后，调用 bind() 绑定端口和调用 listen() 监听该 socket；</li>
<li>然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。</li>
</ul>
<p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情：</p>
<ul>
<li>首先，先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li>
<li>接着，调用 epoll_wait 函数等待事件的到来：<ul>
<li>如果是<strong>连接事件</strong>到来，则会调用<strong>连接事件处理函数</strong>，该函数会做这些事情：调用 accpet 获取已连接的 socket -&gt; 调用 epoll_ctl 将已连接的 socket 加入到 epoll -&gt; 注册「读事件」处理函数；</li>
<li>如果是<strong>读事件</strong>到来，则会调用<strong>读事件处理函数</strong>，该函数会做这些事情：调用 read 获取客户端发送的数据 -&gt; 解析命令 -&gt; 处理命令 -&gt; 将客户端对象添加到发送队列 -&gt; 将执行结果写到发送缓存区等待发送；</li>
<li>如果是<strong>写事件</strong>到来，则会调用<strong>写事件处理函数</strong>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。</li>
</ul>
</li>
</ul>
<p>以上就是 Redis 单线模式的工作方式</p>
<h5 id="Redis-采用单线程为什么还这么快？"><a href="#Redis-采用单线程为什么还这么快？" class="headerlink" title="Redis 采用单线程为什么还这么快？"></a>Redis 采用单线程为什么还这么快？</h5><p>官方使用基准测试的结果是，<strong>单线程的 Redis 吞吐量可以达到 10W&#x2F;每秒</strong>，如下图所示：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E6%80%A7%E8%83%BD.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>之所以 Redis 采用单线程（网络 I&#x2F;O 和执行命令）那么快，有如下几个原因：</p>
<ul>
<li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；</li>
<li>Redis 采用单线程模型可以<strong>避免了多线程之间的竞争</strong>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li>
<li>Redis 采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li>
</ul>
<h5 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h5><p>虽然 Redis 的主要工作（网络 I&#x2F;O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</strong>。</p>
<p>所以为了提高网络 I&#x2F;O 的并行度，Redis 6.0 对于网络 I&#x2F;O 采用多线程来处理。**但是对于命令的执行，Redis 仍然使用单线程来处理，*<em>所以大家*<em>不要误解</em></em> Redis 有多线程同时执行命令。</p>
<p>Redis 官方表示，<strong>Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上</strong>。</p>
<p>Redis 6.0 版本支持的 I&#x2F;O 多线程特性，默认情况下 I&#x2F;O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//读请求也使用io多线程</span><br>io-threads-<span class="hljs-keyword">do</span>-reads yes <br></code></pre></td></tr></table></figure>

<p>同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）</span><br>io-threads <span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure>

<p>关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。</p>
<p>因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会<strong>额外创建 6 个线程</strong>（<em>这里的线程数不包括主线程</em>）：</p>
<ul>
<li>Redis-server ： Redis的主线程，主要负责执行命令；</li>
<li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li>
<li>io_thd_1、io_thd_2、io_thd_3：三个 I&#x2F;O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I&#x2F;O 多线程，用来分担 Redis 网络 I&#x2F;O 的压力。</li>
</ul>
<h4 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h4><h5 id="redis如何保证数据不丢失"><a href="#redis如何保证数据不丢失" class="headerlink" title="redis如何保证数据不丢失"></a>redis如何保证数据不丢失</h5><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p>
<p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li>
</ul>
<h5 id="AOF日志是如何实现的"><a href="#AOF日志是如何实现的" class="headerlink" title="AOF日志是如何实现的"></a>AOF日志是如何实现的</h5><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6f0ab40396b7fc2c15e6f4487d3a0ad7-20230309232240301.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我这里以「<em>set name xiaolin</em>」命令作为例子，Redis 执行了这条命令后，记录在 AOF 日志里的内容如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/337021a153944fd0f964ca834e34d0f2-20230309232243363.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我这里给大家解释下。</p>
<p>「*3」表示当前命令有三个部分，每部分都是以「$+数字」开头，后面紧跟着具体的命令、键或值。然后，这里的「数字」表示这部分中的命令、键或值一共有多少字节。例如，「$3 set」表示这部分有 3 个字节，也就是「set」命令这个字符串的长度。</p>
<blockquote>
<p>为什么先执行命令，再把数据写入日志呢？</p>
</blockquote>
<p>Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。</p>
<ul>
<li><strong>避免额外的检查开销</strong>：因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li>
</ul>
<p>当然，这样做也会带来风险：</p>
<ul>
<li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li>
<li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li>
</ul>
<blockquote>
<p>AOF 写回策略有几种？</p>
</blockquote>
<p>先来看看，Redis 写入 AOF 日志的过程，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/4eeef4dd1bedd2ffe0b84d4eaa0dbdea-20230309232249413.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>具体说说：</p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p>我也把这 3 个写回策略的优缺点总结成了一张表格：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>AOF 日志过大，会触发什么机制？</p>
</blockquote>
<p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。</p>
<p>所以，Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/723d6c580c05400b3841bc69566dd61b-20230309232257343.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p>
<p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p>
<blockquote>
<p>重写 AOF 日志的过程是怎样的？</p>
</blockquote>
<p>Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。</p>
<p><strong>但是重写过程中，主进程依然可以正常处理命令</strong>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309232301042.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>信号函数执行完后，主进程就可以继续像往常一样处理命令了。</p>
<h5 id="RDB快照如何实现的呢？"><a href="#RDB快照如何实现的呢？" class="headerlink" title="RDB快照如何实现的呢？"></a>RDB快照如何实现的呢？</h5><p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p>
<p>为了解决这个问题，Redis 增加了 RDB 快照。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。</p>
<p>所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<blockquote>
<p>RDB 做快照时会阻塞线程吗？</p>
</blockquote>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">save <span class="hljs-number">900</span> <span class="hljs-number">1</span><br>save <span class="hljs-number">300</span> <span class="hljs-number">10</span><br>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>

<p>别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：</p>
<ul>
<li>900 秒之内，对数据库进行了至少 1 次修改；</li>
<li>300 秒之内，对数据库进行了至少 10 次修改；</li>
<li>60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
<p>这里提一点，Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p>
<blockquote>
<p>RDB 在执行快照的时候，数据能修改吗？</p>
</blockquote>
<p>可以的，执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的，关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c34a9d1f58d602ff1fe8601f7270baa7-20230309232304226.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/ebd620db8a1af66fbeb8f4d4ef6adc68-20230309232308604.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="为什么会出现混合持久化"><a href="#为什么会出现混合持久化" class="headerlink" title="为什么会出现混合持久化"></a>为什么会出现混合持久化</h5><p>RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。</p>
<p>AOF 优点是丢失数据少，但是数据恢复不快。</p>
<p>为了集成了两者的优点， Redis 4.0 提出了<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f67379b60d151262753fec3b817b8617-20230309232312657.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<p><strong>混合持久化优点：</strong></p>
<ul>
<li>混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险。</li>
</ul>
<p><strong>混合持久化缺点：</strong></p>
<ul>
<li>AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差；</li>
<li>兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了</li>
</ul>
<h4 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h4><h5 id="redis如何实现服务高可用"><a href="#redis如何实现服务高可用" class="headerlink" title="redis如何实现服务高可用"></a>redis如何实现服务高可用</h5><p>要想设计一个高可用的 Redis 服务，一定要从 Redis 的多服务节点来考虑，比如 Redis 的主从复制、哨兵模式、切片集群。</p>
<blockquote>
<p>主从复制</p>
</blockquote>
<p>主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。</p>
<p>主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2b7231b6aabb9a9a2e2390ab3a280b2d.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>也就是说，所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p>
<p>注意，主从服务器之间的命令复制是<strong>异步</strong>进行的。</p>
<p>具体来说，在主从服务器命令传播阶段，主服务器收到新的写命令后，会发送给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了。</p>
<p>所以，无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</p>
<p>TIP</p>
<p>想更详细了解 Redis 主从复制的工作原理，可以详细看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/cluster/master_slave_replication.html">主从复制是怎么实现的？(opens new window)</a></p>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。</p>
<p>为了解决这个问题，Redis 增加了哨兵模式（<strong>Redis Sentinel</strong>），因为哨兵模式做到了可以监控主从服务器，并且提供<strong>主从节点故障转移的功能。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/26f88373d8454682b9e0c1d4fd1611b4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>TIP</p>
<p>想更详细了解 Redis 哨兵的工作原理，可以详细看这篇：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/redis/cluster/sentinel.html">哨兵是怎么实现的？(opens new window)</a></p>
<blockquote>
<p>切片集群模式</p>
</blockquote>
<p>当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 <strong>Redis 切片集群</strong>（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</p>
<p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，<strong>一个切片集群共有 16384 个哈希槽</strong>，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：</p>
<ul>
<li>根据键值对的 key，按照 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC16 算法 (opens new window)</a>计算一个 16 bit 的值。</li>
<li>再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li>
</ul>
<p>接下来的问题就是，这些哈希槽怎么被映射到具体的 Redis 节点上的呢？有两种方案：</p>
<ul>
<li><strong>平均分配：</strong> 在使用 cluster create 命令创建 Redis 集群时，Redis 会自动把所有哈希槽平均分布到集群节点上。比如集群中有 9 个节点，则每个节点上槽的个数为 16384&#x2F;9 个。</li>
<li><strong>手动分配：</strong> 可以使用 cluster meet 命令手动建立节点间的连接，组成集群，再使用 cluster addslots 命令，指定每个节点上的哈希槽个数。</li>
</ul>
<p>为了方便你的理解，我通过一张图来解释数据、哈希槽，以及节点三者的映射分布关系。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E6%98%A0%E5%B0%84%E5%88%86%E5%B8%83%E5%85%B3%E7%B3%BB.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>上图中的切片集群一共有 2 个节点，假设有 4 个哈希槽（Slot 0～Slot 3）时，我们就可以通过命令手动分配哈希槽，比如节点 1 保存哈希槽 0 和 1，节点 2 保存哈希槽 2 和 3。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.10</span> –p <span class="hljs-number">6379</span> cluster addslots <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>redis-cli -h <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.11</span> –p <span class="hljs-number">6379</span> cluster addslots <span class="hljs-number">2</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>然后在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 4 进行取模，再根据各自的模数结果，就可以被映射到哈希槽 1（对应节点1） 和 哈希槽 2（对应节点2）。</p>
<p>需要注意的是，在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</p>
<h5 id="集群脑裂导致数据丢失怎么办"><a href="#集群脑裂导致数据丢失怎么办" class="headerlink" title="集群脑裂导致数据丢失怎么办"></a>集群脑裂导致数据丢失怎么办</h5><blockquote>
<p>什么是脑裂？</p>
</blockquote>
<p>先来理解集群的脑裂现象，这就好比一个人有两个大脑，那么到底受谁控制呢？</p>
<p>那么在 Redis 中，集群脑裂产生数据丢失的现象是怎样的呢？</p>
<p>在 Redis 主从架构中，部署方式一般是「一主多从」，主节点提供写操作，从节点提供读操作。 如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p>
<p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在「从节点」中选举出一个 leader 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>然后，网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p>
<p>总结一句话就是：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<p>在 Redis 的配置文件中有两个参数我们可以设置：</p>
<ul>
<li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li>
<li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</li>
</ul>
<p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。</p>
<p>这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。</p>
<p>即使原主库是假故障，它在假故障期间也无法响应哨兵心跳，也不能和从库进行同步，自然也就无法和从库进行 ACK 确认了。这样一来，min-slaves-to-write 和 min-slaves-max-lag 的组合要求就无法得到满足，<strong>原主库就会被限制接收客户端写请求，客户端也就不能在原主库中写入新数据了</strong>。</p>
<p><strong>等到新主库上线时，就只有新主库能接收和处理客户端请求，此时，新写的数据会被直接写到新主库中。而原主库会被哨兵降为从库，即使它的数据被清空了，也不会有新数据丢失。</strong></p>
<p>再来举个例子。</p>
<p>假设我们将 min-slaves-to-write 设置为 1，把 min-slaves-max-lag 设置为 12s，把哨兵的 down-after-milliseconds 设置为 10s，主库因为某些原因卡住了 15s，导致哨兵判断主库客观下线，开始进行主从切换。</p>
<p>同时，因为原主库卡住了 15s，没有一个从库能和原主库在 12s 内进行数据复制，原主库也无法接收客户端请求了。</p>
<p>这样一来，主从切换完成后，也只有新主库能接收请求，不会发生脑裂，也就不会发生数据丢失的问题了。</p>
<h4 id="Redis-过期删除与内存淘汰"><a href="#Redis-过期删除与内存淘汰" class="headerlink" title="Redis 过期删除与内存淘汰"></a>Redis 过期删除与内存淘汰</h4><h5 id="redis采用的过期删除策略是什么"><a href="#redis采用的过期删除策略是什么" class="headerlink" title="redis采用的过期删除策略是什么"></a>redis采用的过期删除策略是什么</h5><p>Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。</p>
<p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个<strong>过期字典</strong>（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p>
<p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li>
</ul>
<p>Redis 使用的过期删除策略是「<strong>惰性删除+定期删除</strong>」这两种策略配和使用。</p>
<blockquote>
<p>什么是惰性删除策略？</p>
</blockquote>
<p>惰性删除策略的做法是，<strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</strong></p>
<p>惰性删除的流程图如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>惰性删除策略的<strong>优点</strong>：</p>
<ul>
<li>因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。</li>
</ul>
<p>惰性删除策略的<strong>缺点</strong>：</p>
<ul>
<li>如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。</li>
</ul>
<blockquote>
<p>什么是定期删除策略？</p>
</blockquote>
<p>定期删除策略的做法是，<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p>
<p>Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>可以看到，定期删除是一个循环的流程。那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<p>定期删除的流程如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>定期删除策略的<strong>优点</strong>：</p>
<ul>
<li>通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。</li>
</ul>
<p>定期删除策略的<strong>缺点</strong>：</p>
<ul>
<li>难以确定删除操作执行的时长和频率。如果执行的太频繁，就会对 CPU 不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。</li>
</ul>
<p>可以看到，惰性删除策略和定期删除策略都有各自的优点，所以 <strong>Redis 选择「惰性删除+定期删除」这两种策略配和使用</strong>，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。</p>
<h5 id="redis持久化时，对过期键是如何处理的"><a href="#redis持久化时，对过期键是如何处理的" class="headerlink" title="redis持久化时，对过期键是如何处理的"></a>redis持久化时，对过期键是如何处理的</h5><p>Redis 持久化文件有两种格式：RDB（Redis Database）和 AOF（Append Only File），下面我们分别来看过期键在这两种格式中的呈现状态。</p>
<p>RDB 文件分为两个阶段，RDB 文件生成阶段和加载阶段。</p>
<ul>
<li><p><strong>RDB 文件生成阶段</strong>：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，<strong>过期的键「不会」被保存到新的 RDB 文件中</strong>，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响。</p>
</li>
<li><p>RDB 加载阶段</p>
<p>：RDB 加载阶段时，要看服务器是主服务器还是从服务器，分别对应以下两种情况：</p>
<ul>
<li><strong>如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中</strong>。所以过期键不会对载入 RDB 文件的主服务器造成影响；</li>
<li><strong>如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中</strong>。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p>AOF 文件分为两个阶段，AOF 文件写入阶段和 AOF 重写阶段。</p>
<ul>
<li><strong>AOF 文件写入阶段</strong>：当 Redis 以 AOF 模式持久化时，<strong>如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值</strong>。</li>
<li><strong>AOF 重写阶段</strong>：执行 AOF 重写时，会对 Redis 中的键值对进行检查，<strong>已过期的键不会被保存到重写后的 AOF 文件中</strong>，因此不会对 AOF 重写造成任何影响。</li>
</ul>
<h5 id="redis主从模式中，对过期建如何处理的"><a href="#redis主从模式中，对过期建如何处理的" class="headerlink" title="redis主从模式中，对过期建如何处理的"></a>redis主从模式中，对过期建如何处理的</h5><p>当 Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，<strong>主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库</strong>，从库通过执行这条 del 指令来删除过期的 key。</p>
<h5 id="redis内存满了会发生什么"><a href="#redis内存满了会发生什么" class="headerlink" title="redis内存满了会发生什么"></a>redis内存满了会发生什么</h5><p>在 Redis 的运行内存达到了某个阀值，就会触发<strong>内存淘汰机制</strong>，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory</p>
<h5 id="redis内存淘汰策略有哪些"><a href="#redis内存淘汰策略有哪些" class="headerlink" title="redis内存淘汰策略有哪些"></a>redis内存淘汰策略有哪些</h5><p>Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。</p>
<p><em><strong>1、不进行数据淘汰的策略</strong></em></p>
<p><strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误。</p>
<p><em><strong>2、进行数据淘汰的策略</strong></em></p>
<p>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。 在设置了过期时间的数据中进行淘汰：</p>
<ul>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
<li><strong>volatile-lru</strong>（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li><strong>volatile-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
<p>在所有数据范围内进行淘汰：</p>
<ul>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>allkeys-lfu</strong>（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ul>
<h5 id="LRU算法和LFU算法的区别"><a href="#LRU算法和LFU算法的区别" class="headerlink" title="LRU算法和LFU算法的区别"></a>LRU算法和LFU算法的区别</h5><blockquote>
<p>什么是 LRU 算法？</p>
</blockquote>
<p><strong>LRU</strong> 全称是 Least Recently Used 翻译为<strong>最近最少使用</strong>，会选择淘汰最近最少使用的数据。</p>
<p>传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。</p>
<p>Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：</p>
<ul>
<li>需要用链表管理所有的缓存数据，这会带来额外的空间开销；</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</li>
</ul>
<blockquote>
<p>Redis 是如何实现 LRU 算法的？</p>
</blockquote>
<p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<p>因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。</p>
<blockquote>
<p>什么是 LFU 算法？</p>
</blockquote>
<p>LFU 全称是 Least Frequently Used 翻译为<strong>最近最不常用的</strong>，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。</p>
<p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<blockquote>
<p>Redis 是如何实现 LFU 算法的？</p>
</blockquote>
<p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    ...<br>      <br>    <span class="hljs-comment">// 24 bits，用于记录对象的访问信息</span><br>    <span class="hljs-type">unsigned</span> lru:<span class="hljs-number">24</span>;  <br>    ...<br>&#125; robj;<br></code></pre></td></tr></table></figure>

<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，用来记录 key 的访问时间戳；低 8bit 存储 logc(Logistic Counter)，用来记录 key 的访问频次。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/lru%E5%AD%97%E6%AE%B5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="redis缓存设计"><a href="#redis缓存设计" class="headerlink" title="redis缓存设计"></a>redis缓存设计</h4><h5 id="如何避免缓存雪崩，缓存击穿，缓存穿透"><a href="#如何避免缓存雪崩，缓存击穿，缓存穿透" class="headerlink" title="如何避免缓存雪崩，缓存击穿，缓存穿透"></a>如何避免缓存雪崩，缓存击穿，缓存穿透</h5><blockquote>
<p>如何避免缓存雪崩？</p>
</blockquote>
<p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/e2b8d2eb5536aa71664772457792ec40.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>那么，当**大量缓存数据在同一时间过期（失效）**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩**的问题。</p>
<p>对于缓存雪崩问题，我们可以采用两种方案解决。</p>
<ul>
<li><strong>将缓存失效时间随机打散：</strong> 我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。</li>
<li><strong>设置缓存不过期：</strong> 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。</li>
</ul>
<blockquote>
<p>如何避免缓存击穿？</p>
</blockquote>
<p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p>
<p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/acb5f4e7ef24a524a53c39eb016f63d4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。 应对缓存击穿可以采取前面说到两种方案：</p>
<ul>
<li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<blockquote>
<p>如何避免缓存穿透？</p>
</blockquote>
<p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p>
<p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/b7031182f770a7a5b3c82eaf749f53b0.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ul>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ul>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<ul>
<li><strong>非法请求的限制</strong>：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li>
<li><strong>设置空值或者默认值</strong>：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li>
<li><strong>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</strong>：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li>
</ul>
<h5 id="如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>如何设计一个缓存策略，可以动态缓存热点数据呢？</h5><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而<strong>只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p>
<p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p>
<p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p>
<ul>
<li>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；</li>
<li>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；</li>
<li>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。</li>
</ul>
<p>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p>
<h5 id="说说常见的缓存更新策略"><a href="#说说常见的缓存更新策略" class="headerlink" title="说说常见的缓存更新策略"></a>说说常见的缓存更新策略</h5><p>常见的缓存更新策略共有3种：</p>
<ul>
<li>Cache Aside（旁路缓存）策略；</li>
<li>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略；</li>
<li>Write Back（写回）策略；</li>
</ul>
<p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。</p>
<blockquote>
<p>Cache Aside（旁路缓存）策略</p>
</blockquote>
<p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6e3db3ba2f829ddc14237f5c7c00e7ce-20230309232338149.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>写策略的步骤：</strong></p>
<ul>
<li>先更新数据库中的数据，再删除缓存中的数据。</li>
</ul>
<p><strong>读策略的步骤：</strong></p>
<ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li>
</ul>
<p>注意，写策略的步骤的顺序不能倒过来，即<strong>不能先删除缓存再更新数据库</strong>，原因是在「读+写」并发的时候，会出现缓存和数据库的数据不一致性的问题。</p>
<p>举个例子，假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/cc208c2931b4e889d1a58cb655537767-20230309232342573.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致。</p>
<p><strong>为什么「先更新数据库再删除缓存」不会有数据不一致的问题？</strong></p>
<p>继续用「读 + 写」请求的并发的场景来分析。</p>
<p>假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为 21，并且清空缓存。这时请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/1cc7401143e79383ead96582ac11b615-20230309232407419.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库数据不一致。 从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p>
<p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。而一旦请求 A 早于请求 B 删除缓存之前更新了缓存，那么接下来的请求就会因为缓存不命中而从数据库中重新读取数据，所以不会出现这种不一致的情况。</p>
<p><strong>Cache Aside 策略适合读多写少的场景，不适合写多的场景</strong>，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p>
<ul>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li>
</ul>
<blockquote>
<p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</p>
</blockquote>
<p>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略原则是应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了。</p>
<p><em><strong>1、Read Through 策略</strong></em></p>
<p>先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库查询数据，并将结果写入到缓存组件，最后缓存组件将数据返回给应用。</p>
<p><em><strong>2、Write Through 策略</strong></em></p>
<p>当有数据更新的时候，先查询要写入的数据在缓存中是否已经存在：</p>
<ul>
<li>如果缓存中数据已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，然后缓存组件告知应用程序更新完成。</li>
<li>如果缓存中数据不存在，直接更新数据库，然后返回；</li>
</ul>
<p>下面是 Read Through&#x2F;Write Through 策略的示意图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/WriteThrough.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>Read Through&#x2F;Write Through 策略的特点是由缓存节点而非应用程序来和数据库打交道，在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，无论是 Memcached 还是 Redis 都不提供写入数据库和自动加载数据库中的数据的功能。而我们在使用本地缓存的时候可以考虑使用这种策略。</p>
<blockquote>
<p>Write Back（写回）策略</p>
</blockquote>
<p>Write Back（写回）策略在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行。</p>
<p>实际上，Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，因为 Redis 并没有异步更新数据库的功能。</p>
<p>Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。</p>
<p><strong>Write Back 策略特别适合写多的场景</strong>，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。</p>
<p><strong>但是带来的问题是，数据不是强一致性的，而且会有数据丢失的风险</strong>，因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。</p>
<p>这里贴一张 CPU 缓存与内存使用 Write Back 策略的流程图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/writeback.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="如何保证缓存和数据库的一致性"><a href="#如何保证缓存和数据库的一致性" class="headerlink" title="如何保证缓存和数据库的一致性"></a>如何保证缓存和数据库的一致性</h5><p>说大白话就是保证数据库和redis的双写一致问题</p>
<p>应用要把数据 X 的值从 1 更新为 2，先成功更新了数据库，然后在 Redis 缓存中删除 X 的缓存，但是这个操作却失败了，这个时候数据库中 X 的新值为 2，Redis 中的 X 的缓存值为 1，出现了数据库和缓存数据不一致的问题。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2a2ea2854bbc3ae8ae86d7da45fa32ee.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>那么，后续有访问数据 X 的请求，会先在 Redis 中查询，因为缓存并没有 诶删除，所以会缓存命中，但是读到的却是旧值 1。</p>
<p>其实不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题。</p>
<p>问题原因知道了，该怎么解决呢？有两种方法：</p>
<ul>
<li>重试机制。</li>
<li>订阅 MySQL binlog，再操作缓存。</li>
</ul>
<p>先来说第一种。</p>
<p>重试机制</p>
<p>我们可以引入<strong>消息队列</strong>，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。</p>
<ul>
<li>如果应用<strong>删除缓存失败</strong>，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是<strong>重试机制</strong>。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</li>
<li>如果<strong>删除缓存成功</strong>，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</li>
</ul>
<p>举个例子，来说明重试机制的过程。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/a4440f0d572612e0832b903e4a62bd2b.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>订阅 MySQL binlog，再操作缓存</p>
<p>「<strong>先更新数据库，再删缓存</strong>」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。</p>
<p>于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。</p>
<p>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p>
<p>下图是 Canal 的工作原理：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2ee2280e9f59b6b4879ebdec6eb0cf52.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>所以，<strong>如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。</strong></p>
<h4 id="redis实战"><a href="#redis实战" class="headerlink" title="redis实战"></a>redis实战</h4><h5 id="redis如何实现延迟队列"><a href="#redis如何实现延迟队列" class="headerlink" title="redis如何实现延迟队列"></a>redis如何实现延迟队列</h5><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li>
</ul>
<p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p>
<p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="redis的大key如何处理"><a href="#redis的大key如何处理" class="headerlink" title="redis的大key如何处理"></a>redis的大key如何处理</h5><blockquote>
<p>什么是 Redis 大 key？</p>
</blockquote>
<p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p>
<p>一般而言，下面这两种情况被称为大 key：</p>
<ul>
<li>String 类型的值大于 10 KB；</li>
<li>Hash、List、Set、ZSet 类型的元素的个数超过 5000个；</li>
</ul>
<blockquote>
<p>大 key 会造成什么问题？</p>
</blockquote>
<p>大 key 会带来以下四种影响：</p>
<ul>
<li><strong>客户端超时阻塞</strong>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li><strong>引发网络阻塞</strong>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程</strong>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li><strong>内存分布不均</strong>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<blockquote>
<p>如何找到大 key ？</p>
</blockquote>
<p><em><strong>1、redis-cli –bigkeys 查找大key</strong></em></p>
<p>可以通过 redis-cli –bigkeys 命令查找大 key：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys<br></code></pre></td></tr></table></figure>

<p>使用的时候注意事项：</p>
<ul>
<li>最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；</li>
<li>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。</li>
</ul>
<p>该方式的不足之处：</p>
<ul>
<li>这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；</li>
<li>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</li>
</ul>
<p><em><strong>2、使用 SCAN 命令查找大 key</strong></em></p>
<p>使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。</p>
<p>对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。</p>
<p>对于集合类型来说，有两种方法可以获得它占用的内存大小：</p>
<ul>
<li>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：<code>LLEN</code> 命令；Hash 类型：<code>HLEN</code> 命令；Set 类型：<code>SCARD</code> 命令；Sorted Set 类型：<code>ZCARD</code> 命令；</li>
<li>如果不能提前知道写入集合的元素大小，可以使用 <code>MEMORY USAGE</code> 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</li>
</ul>
<p><em><strong>3、使用 RdbTools 工具查找大 key</strong></em></p>
<p>使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。</p>
<p>比如，下面这条命令，将大于 10 kb 的  key  输出到一个表格文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rdb dump.rdb -c memory --bytes 10240 -f redis.csv<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如何删除大 key？</p>
</blockquote>
<p>删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。</p>
<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</p>
<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>
<p>因此，删除大 key 这一个动作，我们要小心。具体要怎么做呢？这里给出两种方法：</p>
<ul>
<li>分批次删除</li>
<li>异步删除（Redis 4.0版本以上）</li>
</ul>
<p><em><strong>1、分批次删除</strong></em></p>
<p>对于<strong>删除大 Hash</strong>，使用 <code>hscan</code> 命令，每次获取 100 个字段，再用 <code>hdel</code> 命令，每次删除 1 个字段。</p>
<p>Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_large_hash</span>():<br>  r = redis.StrictRedis(host=<span class="hljs-string">&#x27;redis-host1&#x27;</span>, port=<span class="hljs-number">6379</span>)<br>    large_hash_key =<span class="hljs-string">&quot;xxx&quot;</span> <span class="hljs-comment">#要删除的大hash键名</span><br>    cursor = <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-keyword">while</span> cursor != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 使用 hscan 命令，每次获取 100 个字段</span><br>        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=<span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data.items():<br>                <span class="hljs-comment"># 再用 hdel 命令，每次删除1个字段</span><br>                r.hdel(large_hash_key, item[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>

<p>对于<strong>删除大 List</strong>，通过 <code>ltrim</code> 命令，每次删除少量元素。</p>
<p>Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_large_list</span>():<br>  r = redis.StrictRedis(host=<span class="hljs-string">&#x27;redis-host1&#x27;</span>, port=<span class="hljs-number">6379</span>)<br>  large_list_key = <span class="hljs-string">&#x27;xxx&#x27;</span>  <span class="hljs-comment">#要删除的大list的键名</span><br>  <span class="hljs-keyword">while</span> r.llen(large_list_key)&gt;<span class="hljs-number">0</span>:<br>      <span class="hljs-comment">#每次只删除最右100个元素</span><br>      r.ltrim(large_list_key, <span class="hljs-number">0</span>, -<span class="hljs-number">101</span>) <br></code></pre></td></tr></table></figure>

<p>对于<strong>删除大 Set</strong>，使用 <code>sscan</code> 命令，每次扫描集合中 100 个元素，再用 <code>srem</code> 命令每次删除一个键。</p>
<p>Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_large_set</span>():<br>  r = redis.StrictRedis(host=<span class="hljs-string">&#x27;redis-host1&#x27;</span>, port=<span class="hljs-number">6379</span>)<br>  large_set_key = <span class="hljs-string">&#x27;xxx&#x27;</span>   <span class="hljs-comment"># 要删除的大set的键名</span><br>  cursor = <span class="hljs-string">&#x27;0&#x27;</span><br>  <span class="hljs-keyword">while</span> cursor != <span class="hljs-number">0</span>:<br>    <span class="hljs-comment"># 使用 sscan 命令，每次扫描集合中 100 个元素</span><br>    cursor, data = r.sscan(large_set_key, cursor=cursor, count=<span class="hljs-number">100</span>)<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:<br>      <span class="hljs-comment"># 再用 srem 命令每次删除一个键</span><br>      r.srem(large_size_key, item)<br></code></pre></td></tr></table></figure>

<p>对于<strong>删除大 ZSet</strong>，使用 <code>zremrangebyrank</code> 命令，每次删除 top 100个元素。</p>
<p>Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_large_sortedset</span>():<br>  r = redis.StrictRedis(host=<span class="hljs-string">&#x27;large_sortedset_key&#x27;</span>, port=<span class="hljs-number">6379</span>)<br>  large_sortedset_key=<span class="hljs-string">&#x27;xxx&#x27;</span><br>  <span class="hljs-keyword">while</span> r.zcard(large_sortedset_key)&gt;<span class="hljs-number">0</span>:<br>    <span class="hljs-comment"># 使用 zremrangebyrank 命令，每次删除 top 100个元素</span><br>    r.zremrangebyrank(large_sortedset_key,<span class="hljs-number">0</span>,<span class="hljs-number">99</span>) <br></code></pre></td></tr></table></figure>

<p><em><strong>2、异步删除</strong></em></p>
<p>从 Redis 4.0 版本开始，可以采用<strong>异步删除</strong>法，<strong>用 unlink 命令代替 del 来删除</strong>。</p>
<p>这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。</p>
<p>除了主动调用 unlink 命令实现异步删除之外，我们还可以通过配置参数，达到某些条件的时候自动进行异步删除。</p>
<p>主要有 4 种场景，默认都是关闭的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">lazyfree-lazy-eviction no<br>lazyfree-lazy-expire no<br>lazyfree-lazy-server-del<br>noslave-lazy-flush no<br></code></pre></td></tr></table></figure>

<p>它们代表的含义如下：</p>
<ul>
<li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<h5 id="redis管道有什么用"><a href="#redis管道有什么用" class="headerlink" title="redis管道有什么用"></a>redis管道有什么用</h5><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>普通命令模式，如下图所示：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E6%99%AE%E9%80%9A%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>管道模式，如下图所示：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>使用<strong>管道技术可以解决多个命令执行时的网络等待</strong>，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p>
<p>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p>
<p>要注意的是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p>
<h5 id="redis支持事务回滚吗"><a href="#redis支持事务回滚吗" class="headerlink" title="redis支持事务回滚吗"></a>redis支持事务回滚吗</h5><p>MySQL 在执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态。</p>
<p><strong>Redis 中并没有提供回滚机制</strong>，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p>
<p>下面是 DISCARD 命令用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">#读取 count 的值<span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; GET count<br><span class="hljs-string">&quot;1&quot;</span><br>#开启事务<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; MULTI <br>OK<br>#发送事务的第一个操作，对count减<span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; DECR count<br>QUEUED<br>#执行DISCARD命令，主动放弃事务<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; DISCARD<br>OK<br>#再次读取a:stock的值，值没有被修改<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; GET count<br><span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure>

<p>事务执行过程中，如果命令入队时没报错，而事务提交后，实际执行时报错了，正确的命令依然可以正常执行，所以这可以看出 <strong>Redis 并不一定保证原子性</strong>（原子性：事务中的命令要不全部成功，要不全部失败）。</p>
<p>比如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">#获取name原本的值<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; GET name<br><span class="hljs-string">&quot;xiaolin&quot;</span><br>#开启事务<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; MULTI<br>OK<br>#设置新值<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>(TX)&gt; SET name xialincoding<br>QUEUED<br>#注意，这条命令是错误的<br><span class="hljs-meta"># expire 过期时间正确来说是数字，并不是‘10s’字符串，但是还是入队成功了</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>(TX)&gt; EXPIRE name <span class="hljs-number">10</span>s<br>QUEUED<br>#提交事务，执行报错<br>#可以看到 <span class="hljs-built_in">set</span> 执行成功，而 expire 执行错误。<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>(TX)&gt; EXEC<br><span class="hljs-number">1</span>) OK<br><span class="hljs-number">2</span>) (error) ERR value is not an integer or out of range<br>#可以看到，name 还是被设置为新值了<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; GET name<br><span class="hljs-string">&quot;xialincoding&quot;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>为什么Redis 不支持事务回滚？</p>
</blockquote>
<p>Redis <a target="_blank" rel="noopener" href="https://redis.io/topics/transactions">官方文档 (opens new window)</a>的解释如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/redis%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A%E5%9B%9E%E6%BB%9A.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>大概的意思是，作者不支持事务回滚的原因有以下两个：</p>
<ul>
<li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li>
<li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。</li>
</ul>
<p>这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚。</p>
<h5 id="如何用redis实现分布式锁"><a href="#如何用redis实现分布式锁" class="headerlink" title="如何用redis实现分布式锁"></a>如何用redis实现分布式锁</h5><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。如下图所示：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%85%AB%E8%82%A1%E6%96%87/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p>
<p>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p>基于 Redis 节点实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p>
<ul>
<li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li>
<li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX&#x2F;PX 选项，设置其过期时间；</li>
<li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端；</li>
</ul>
<p>满足这三个条件的分布式命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">SET lock_key unique_value NX PX <span class="hljs-number">10000</span> <br></code></pre></td></tr></table></figure>

<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>而解锁的过程就是将 lock_key 键删除（del lock_key），但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p>
<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] then<br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>end<br></code></pre></td></tr></table></figure>

<p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p>
<blockquote>
<p>基于 Redis 实现分布式锁有什么优缺点？</p>
</blockquote>
<p>基于 Redis 实现分布式锁的<strong>优点</strong>：</p>
<ol>
<li>性能高效（这是选择缓存实现分布式锁最核心的出发点）。</li>
<li>实现方便。很多研发工程师选择使用 Redis 来实现分布式锁，很大成分上是因为 Redis 提供了 setnx 方法，实现分布式锁很方便。</li>
<li>避免单点故障（因为 Redis 是跨集群部署的，自然就避免了单点故障）。</li>
</ol>
<p>基于 Redis 实现分布式锁的<strong>缺点</strong>：</p>
<ul>
<li><p>超时时间不好设置</p>
<p>。如果锁的超时时间设置过长，会影响性能，如果设置的超时时间过短会保护不到共享资源。比如在有些场景中，一个线程 A 获取到了锁之后，由于业务代码执行时间可能比较长，导致超过了锁的超时时间，自动失效，注意 A 线程没执行完，后续线程 B 又意外的持有了锁，意味着可以操作共享资源，那么两个线程之间的共享资源就没办法进行保护了。</p>
<ul>
<li><strong>那么如何合理设置超时时间呢？</strong> 我们可以基于续约的方式设置超时时间：先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间。实现方式就是：写一个守护线程，然后去判断锁的情况，当锁快失效的时候，再次进行续约加锁，当主线程执行完成后，销毁续约锁即可，不过这种方式实现起来相对复杂。</li>
</ul>
</li>
<li><p><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
</li>
</ul>
<blockquote>
<p>Redis 如何解决集群情况下分布式锁的可靠性？</p>
</blockquote>
<p>为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。</p>
<p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p>
<p>Redlock 算法的基本思路，<strong>是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p>
<p>这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。</p>
<p>Redlock 算法加锁三个过程：</p>
<ul>
<li>第一步是，客户端获取当前时间（t1）。</li>
<li>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<ul>
<li>加锁操作使用 SET 命令，带上 NX，EX&#x2F;PX 选项，以及带上客户端的唯一标识。</li>
<li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li>
</ul>
</li>
<li>第三步是，一旦客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li>
</ul>
<p>可以看到，加锁成功要同时满足两个条件（<em>简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功</em>）：</p>
<ul>
<li>条件一：客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁；</li>
<li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li>
</ul>
<p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>加锁失败后，客户端向<strong>所有 Redis 节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了</p>
<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><h4 id="RabbitMQ常见面试题"><a href="#RabbitMQ常见面试题" class="headerlink" title="RabbitMQ常见面试题"></a>RabbitMQ常见面试题</h4><h5 id="RabbitMQ-是什么？"><a href="#RabbitMQ-是什么？" class="headerlink" title="RabbitMQ 是什么？"></a>RabbitMQ 是什么？</h5><p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<p>RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</p>
<p>PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。</p>
<p>RabbitMQ的特点</p>
<p><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</p>
<p><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</p>
<p><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</p>
<p><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</p>
<p><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</p>
<p><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</p>
<p><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</p>
<p><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</p>
<h5 id="AMQP-是什么"><a href="#AMQP-是什么" class="headerlink" title="AMQP 是什么?"></a>AMQP 是什么?</h5><p>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</p>
<p>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</p>
<p><strong>AMQP 协议的三层</strong> ：</p>
<ul>
<li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li>
<li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li>
<li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li>
</ul>
<p><strong>AMQP 模型的三大组件</strong> ：</p>
<ul>
<li><strong>交换器 (Exchange)</strong> ：消息代理服务器中用于把消息路由到队列的组件。</li>
<li><strong>队列 (Queue)</strong> ：用来存储消息的数据结构，位于硬盘或内存中。</li>
<li><strong>绑定 (Binding)</strong> ：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>
</ul>
<h5 id="说说生产者Producer和消费者Consumer"><a href="#说说生产者Producer和消费者Consumer" class="headerlink" title="说说生产者Producer和消费者Consumer"></a>说说生产者Producer和消费者Consumer</h5><p><strong>生产者</strong> :</p>
<ul>
<li>消息生产者，就是投递消息的一方。</li>
<li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li>
</ul>
<p><strong>消费者</strong> ：</p>
<ul>
<li>消费消息，也就是接收消息的一方。</li>
<li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签</li>
</ul>
<h5 id="说说-Broker-服务节点、Queue-队列、Exchange-交换器？"><a href="#说说-Broker-服务节点、Queue-队列、Exchange-交换器？" class="headerlink" title="说说 Broker 服务节点、Queue 队列、Exchange 交换器？"></a>说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h5><ul>
<li><strong>Broker</strong> ： 可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li>
<li><strong>Queue</strong> :RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</li>
<li><strong>Exchange</strong> : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>
</ul>
<h5 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列"></a>什么是死信队列</h5><p>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。</p>
<p><strong>导致的死信的几种原因</strong>：</p>
<ul>
<li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li>
<li>消息 TTL 过期。</li>
<li>队列满了，无法再添加。</li>
</ul>
<h5 id="什么是延迟队列？RabbitMQ-怎么实现延迟队列？"><a href="#什么是延迟队列？RabbitMQ-怎么实现延迟队列？" class="headerlink" title="什么是延迟队列？RabbitMQ 怎么实现延迟队列？"></a>什么是延迟队列？RabbitMQ 怎么实现延迟队列？</h5><p>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p>
<p>RabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：</p>
<ol>
<li>通过 RabbitMQ 本身队列的特性来实现，需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。</li>
<li>在 RabbitMQ 3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang&#x2F;OPT 18.0 及以上。</li>
</ol>
<p>也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。</p>
<h5 id="什么是优先级队列？"><a href="#什么是优先级队列？" class="headerlink" title="什么是优先级队列？"></a>什么是优先级队列？</h5><p>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</p>
<p>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p>
<h5 id="RabbitMQ有哪些工作模式"><a href="#RabbitMQ有哪些工作模式" class="headerlink" title="RabbitMQ有哪些工作模式"></a>RabbitMQ有哪些工作模式</h5><ul>
<li>简单模式</li>
<li>work 工作模式</li>
<li>pub&#x2F;sub 发布订阅模式</li>
<li>Routing 路由模式</li>
<li>Topic 主题模式</li>
</ul>
<h5 id="RabbitMQ-消息怎么传输？"><a href="#RabbitMQ-消息怎么传输？" class="headerlink" title="RabbitMQ 消息怎么传输？"></a>RabbitMQ 消息怎么传输？</h5><p>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用。</p>
<h5 id="如何保证消息的可靠性"><a href="#如何保证消息的可靠性" class="headerlink" title="如何保证消息的可靠性"></a>如何保证消息的可靠性</h5><p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p>
<ul>
<li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li>
<li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li>
<li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li>
</ul>
<h5 id="如何保证RabbitMQ的消息的顺序性"><a href="#如何保证RabbitMQ的消息的顺序性" class="headerlink" title="如何保证RabbitMQ的消息的顺序性"></a>如何保证RabbitMQ的消息的顺序性</h5><p>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；</p>
<p>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>
<h5 id="如何保证RabbitMQ的高可用"><a href="#如何保证RabbitMQ的高可用" class="headerlink" title="如何保证RabbitMQ的高可用"></a>如何保证RabbitMQ的高可用</h5><p>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>
<p><strong>单机模式</strong></p>
<p>Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。</p>
<p><strong>普通集群模式</strong></p>
<p>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</p>
<p>你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<p><strong>镜像集群模式</strong></p>
<p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
<p>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>
<h5 id="如何解决消息队列的延时以及过期失效问题"><a href="#如何解决消息队列的延时以及过期失效问题" class="headerlink" title="如何解决消息队列的延时以及过期失效问题"></a>如何解决消息队列的延时以及过期失效问题</h5><p>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h4><h5 id="说说OSI七层模型"><a href="#说说OSI七层模型" class="headerlink" title="说说OSI七层模型"></a>说说OSI七层模型</h5><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" srcset="/img/loading.gif" lazyload alt="OSI 七层模型">OSI 七层模型</p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" srcset="/img/loading.gif" lazyload alt="osi七层模型2"></p>
<h5 id="说说TCP-x2F-IP四层协议"><a href="#说说TCP-x2F-IP四层协议" class="headerlink" title="说说TCP&#x2F;IP四层协议"></a>说说TCP&#x2F;IP四层协议</h5><p><strong>TCP&#x2F;IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP &#x2F; IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP&#x2F;IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" srcset="/img/loading.gif" lazyload alt="TCP/IP 四层模型"></p>
<blockquote>
<p>举个有趣的小例子：如果把网络分层用网上购物表示的话，那么可以这样理解，数据链路层可以理解为高速公路，网络层可以理解为物流公司经过导航将你的数据从广东送到武汉再送到成都，也就是说这是涉及到数据在网络之间如何跳转的。传输层可以理解为快递小哥将你的包裹送到你家门口或者你家附近驿站，这里就设计到一对一了，在网络中就可以理解为为两台主机的通信进行数据传输服务。然后应用层就是你去拿包裹然后使用你买的东西。这每一层都涉及到拆这个动作，这个拆的动作可以根据后面的知识点更进一步了解。</p>
</blockquote>
<h5 id="为什么网络要分层"><a href="#为什么网络要分层" class="headerlink" title="为什么网络要分层"></a>为什么网络要分层</h5><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>
<h4 id="常见网络协议"><a href="#常见网络协议" class="headerlink" title="常见网络协议"></a>常见网络协议</h4><h5 id="应用层有哪些常见协议"><a href="#应用层有哪些常见协议" class="headerlink" title="应用层有哪些常见协议"></a>应用层有哪些常见协议</h5><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png" srcset="/img/loading.gif" lazyload alt="应用层常见协议">应用层常见协议</p>
<ul>
<li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3&#x2F;IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>
<li><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li>
<li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li>
<li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li>
</ul>
<h5 id="传输层常见协议"><a href="#传输层常见协议" class="headerlink" title="传输层常见协议"></a>传输层常见协议</h5><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png" srcset="/img/loading.gif" lazyload alt="传输层常见协议">传输层常见协议</p>
<ul>
<li><strong>TCP（Transmission Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li>
<li><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li>
</ul>
<h5 id="网络层有哪些协议"><a href="#网络层有哪些协议" class="headerlink" title="网络层有哪些协议"></a>网络层有哪些协议</h5><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png" srcset="/img/loading.gif" lazyload alt="网络层常见协议">网络层常见协议</p>
<ul>
<li><strong>IP（Internet Protocol，网际协议）</strong>：TCP&#x2F;IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li>
<li><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li>
<li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li>
<li><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li>
<li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li>
</ul>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="从输入URL到页面显示之间发生了什么。"><a href="#从输入URL到页面显示之间发生了什么。" class="headerlink" title="从输入URL到页面显示之间发生了什么。"></a>从输入URL到页面显示之间发生了什么。</h5><blockquote>
<p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p>
</blockquote>
<p>图解（图片来源：《图解 HTTP》）：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>详细内容可以查看小林哥这篇文章</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/what_happen_url.html#_2-2-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA-%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">2.2 键入网址到网页显示，期间发生了什么？ | 小林coding (xiaolincoding.com)</a></p>
<h5 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h5><p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" srcset="/img/loading.gif" lazyload alt="常见 HTTP 状态码"></p>
<h5 id="HTTP-Header中常见的字段有哪些"><a href="#HTTP-Header中常见的字段有哪些" class="headerlink" title="HTTP Header中常见的字段有哪些"></a>HTTP Header中常见的字段有哪些</h5><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><table>
<thead>
<tr>
<th align="left">请求头字段名</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">能够接受的回应内容类型（Content-Types）。</td>
<td align="left">Accept: text&#x2F;plain</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">能够接受的字符集</td>
<td align="left">Accept-Charset: utf-8</td>
</tr>
<tr>
<td align="left">Accept-Datetime</td>
<td align="left">能够接受的按照时间来表示的版本</td>
<td align="left">Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">能够接受的编码方式列表。参考 HTTP 压缩。</td>
<td align="left">Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">能够接受的回应内容的自然语言列表。</td>
<td align="left">Accept-Language: en-US</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">用于超文本传输协议的认证的认证信息</td>
<td align="left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令</td>
<td align="left">Cache-Control: no-cache</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">该浏览器想要优先使用的连接类型</td>
<td align="left">Connection: keep-alive Connection: Upgrade</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">以 八位字节数组 （8 位的字节）表示的请求体的长度</td>
<td align="left">Content-Length: 348</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果</td>
<td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</td>
<td align="left">Content-Type: application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td align="left">Cookie</td>
<td align="left">之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie</td>
<td align="left">Cookie: $Version&#x3D;1; Skin&#x3D;new;</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送)</td>
<td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
</tr>
<tr>
<td align="left">Expect</td>
<td align="left">表明客户端要求服务器做出特定的行为</td>
<td align="left">Expect: 100-continue</td>
</tr>
<tr>
<td align="left">From</td>
<td align="left">发起此请求的用户的邮件地址</td>
<td align="left">From: <a href="mailto:user@example.com">user@example.com</a></td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。</td>
<td align="left">Host: en.wikipedia.org:80</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。</td>
<td align="left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td>
<td align="left">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td>
<td align="left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td>
<td align="left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。</td>
<td align="left">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td align="left">Max-Forwards</td>
<td align="left">限制该消息可被代理及网关转发的次数。</td>
<td align="left">Max-Forwards: 10</td>
</tr>
<tr>
<td align="left">Origin</td>
<td align="left">发起一个针对 跨来源资源共享 的请求。</td>
<td align="left">Origin: <a target="_blank" rel="noopener" href="http://www.example-social-network.com/">http://www.example-social-network.com </a></td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">与具体的实现相关，这些字段可能在请求&#x2F;回应链中的任何时候产生多种效果。</td>
<td align="left">Pragma: no-cache</td>
</tr>
<tr>
<td align="left">Proxy-Authorization</td>
<td align="left">用来向代理进行认证的认证信息。</td>
<td align="left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。</td>
<td align="left">Range: bytes&#x3D;500-999</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。</td>
<td align="left">Referer: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Main_Page">http://en.wikipedia.org/wiki/Main_Page </a></td>
</tr>
<tr>
<td align="left">TE</td>
<td align="left">浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；</td>
<td align="left">TE: trailers, deflate</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">要求服务器升级到另一个协议。</td>
<td align="left">Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">浏览器的浏览器身份标识字符串</td>
<td align="left">User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">向服务器告知，这个请求是由哪些代理发出的。</td>
<td align="left">Via: 1.0 fred, 1.1 example.com (Apache&#x2F;1.1)</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">一个一般性的警告，告知，在实体内容体中可能存在错误。</td>
<td align="left">Warning: 199 Miscellaneous warning</td>
</tr>
</tbody></table>
<h5 id="HTTP和HTTPS有什么区别"><a href="#HTTP和HTTPS有什么区别" class="headerlink" title="HTTP和HTTPS有什么区别"></a>HTTP和HTTPS有什么区别</h5><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png" srcset="/img/loading.gif" lazyload alt="HTTP 和 HTTPS 对比">HTTP 和 HTTPS 对比</p>
<ul>
<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
<li><strong>SEO（搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索</li>
</ul>
<h5 id="HTTP1-0和HTTP1-1有什么区别"><a href="#HTTP1-0和HTTP1-1有什么区别" class="headerlink" title="HTTP1.0和HTTP1.1有什么区别"></a>HTTP1.0和HTTP1.1有什么区别</h5><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png" srcset="/img/loading.gif" lazyload alt="HTTP/1.0 和 HTTP/1.1 对比">HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 对比</p>
<ul>
<li><strong>连接方式</strong> : HTTP&#x2F;1.0 为短连接，HTTP&#x2F;1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP&#x2F;1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存机制</strong> : 在 HTTP&#x2F;1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP&#x2F;1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽</strong>：HTTP&#x2F;1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP&#x2F;1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host 头（Host Header）处理</strong> :HTTP&#x2F;1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP&#x2F;1.0 没有 Host 头字段，无法实现虚拟主机。</li>
</ul>
<h5 id="HTTP1-1和HTTP2-0有什么区别"><a href="#HTTP1-1和HTTP2-0有什么区别" class="headerlink" title="HTTP1.1和HTTP2.0有什么区别"></a>HTTP1.1和HTTP2.0有什么区别</h5><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.1-vs-http2.0.png" srcset="/img/loading.gif" lazyload alt="HTTP/1.0 和 HTTP/1.1 对比"></p>
<ul>
<li><strong>IO 多路复用（Multiplexing）</strong>：HTTP&#x2F;2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP&#x2F;1.1 中长链接的升级版本）。HTTP&#x2F;1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP&#x2F;2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</li>
<li><strong>二进制帧（Binary Frames）</strong>：HTTP&#x2F;2.0 使用二进制帧进行数据传输，而 HTTP&#x2F;1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</li>
<li><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP&#x2F;2.0 支持对<code>Header</code>压缩，减少了网络开销。</li>
<li><strong>服务器推送（Server Push）</strong>：HTTP&#x2F;2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP&#x2F;1.1 需要客户端自己发送请求来获取相关资源。</li>
</ul>
<h5 id="HTTP-x2F-2-0-和-HTTP-x2F-3-0-有什么区别？"><a href="#HTTP-x2F-2-0-和-HTTP-x2F-3-0-有什么区别？" class="headerlink" title="HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？"></a>HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 有什么区别？</h5><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http2.0-vs-http3.0.png" srcset="/img/loading.gif" lazyload alt="HTTP/2.0 和 HTTP/3.0 对比">HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 对比</p>
<ul>
<li><strong>传输协议</strong>：HTTP&#x2F;2.0 是基于 TCP 协议实现的，HTTP&#x2F;3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS&#x2F;SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP&#x2F;3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP&#x2F;3 最大的改造就是使用了 QUIC。</li>
<li><strong>连接建立</strong>：HTTP&#x2F;2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP&#x2F;3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。</li>
<li><strong>队头阻塞</strong>：HTTP&#x2F;2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP&#x2F;3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</li>
<li><strong>错误恢复</strong>：HTTP&#x2F;3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP&#x2F;2.0 则需要依赖于 TCP 的错误恢复机制。</li>
<li><strong>安全性</strong>：HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP&#x2F;2.0 使用 TLS 协议进行加密，而 HTTP&#x2F;3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li>
</ul>
<h5 id="HTTP是不保存状态的协议，如何保存用户状态"><a href="#HTTP是不保存状态的协议，如何保存用户状态" class="headerlink" title="HTTP是不保存状态的协议，如何保存用户状态"></a>HTTP是不保存状态的协议，如何保存用户状态</h5><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<h5 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么"></a>URI和URL的区别是什么</h5><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h5 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h5><p><strong><code>Session</code> 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 <code>Session</code> 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p><code>Cookie</code> 数据保存在客户端(浏览器端)，<code>Session</code> 数据保存在服务器端。相对来说 <code>Session</code> 安全性更高。如果使用 <code>Cookie</code> 的一些敏感信息不要写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密然后使用到的时候再去服务器端解密。</p>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><h5 id="PING的作用是什么"><a href="#PING的作用是什么" class="headerlink" title="PING的作用是什么"></a>PING的作用是什么</h5><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>
<p>这里简单举一个例子，我们来 PING 一下百度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发送4个PING请求数据包到 www.baidu.com</span><br>❯ ping -c 4 www.baidu.com<br><br>PING www.a.shifen.com (14.119.104.189): 56 data bytes<br>64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms<br>64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms<br>64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms<br>64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms<br><br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 packets received, 0.0% packet loss<br>round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms<br></code></pre></td></tr></table></figure>

<p>PING 命令的输出结果通常包括以下几部分信息：</p>
<ol>
<li><strong>ICMP Echo Request（请求报文）信息</strong>：序列号、TTL（Time to Live）值。</li>
<li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li>
<li><strong>往返时间（RTT，Round-Trip Time）</strong>：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li>
<li><strong>统计结果（Statistics）</strong>：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li>
</ol>
<p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。</p>
<h5 id="Ping的工作原理是什么"><a href="#Ping的工作原理是什么" class="headerlink" title="Ping的工作原理是什么"></a>Ping的工作原理是什么</h5><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>
<p>这里简单举一个例子，我们来 PING 一下百度。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发送4个PING请求数据包到 www.baidu.com</span><br>❯ ping -c 4 www.baidu.com<br><br>PING www.a.shifen.com (14.119.104.189): 56 data bytes<br>64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms<br>64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms<br>64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms<br>64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms<br><br>--- www.a.shifen.com ping statistics ---<br>4 packets transmitted, 4 packets received, 0.0% packet loss<br>round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms<br></code></pre></td></tr></table></figure>

<p>PING 命令的输出结果通常包括以下几部分信息：</p>
<ol>
<li><strong>ICMP Echo Request（请求报文）信息</strong>：序列号、TTL（Time to Live）值。</li>
<li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li>
<li><strong>往返时间（RTT，Round-Trip Time）</strong>：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li>
<li><strong>统计结果（Statistics）</strong>：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li>
</ol>
<p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><h5 id="DNS的作用是什么"><a href="#DNS的作用是什么" class="headerlink" title="DNS的作用是什么"></a>DNS的作用是什么</h5><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png" srcset="/img/loading.gif" lazyload alt="DNS:域名系统">DNS:域名系统</p>
<p>在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个<code>hosts</code>列表，一般来说浏览器要先查看要访问的域名是否在<code>hosts</code>列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地<code>hosts</code>列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。</p>
<p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p>
<h5 id="DNS服务器有哪些"><a href="#DNS服务器有哪些" class="headerlink" title="DNS服务器有哪些"></a>DNS服务器有哪些</h5><p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p>
<ul>
<li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li>
<li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li>
<li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li>
<li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构</li>
</ul>
<h5 id="DNS解析的过程是什么样的"><a href="#DNS解析的过程是什么样的" class="headerlink" title="DNS解析的过程是什么样的"></a>DNS解析的过程是什么样的</h5><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。</p>
<p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p>
<p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p>
<p>所以，有一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p>
<blockquote>
<p>域名的层级关系</p>
</blockquote>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
<p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p>
<p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p>
<p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p>
<p>所以域名的层级关系类似一个树状结构：</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" srcset="/img/loading.gif" lazyload alt="DNS 树状结构"></p>
<p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p>
<p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p>
<p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>
<blockquote>
<p>域名解析的工作流程</p>
</blockquote>
<ol>
<li>客户端首先会发出一个 DNS 请求，问 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP&#x2F;IP 设置中填写的 DNS 服务器地址）。</li>
<li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a target="_blank" rel="noopener" href="http://www.server.com,则它直接返回/">www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li>
<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 的 IP 地址吗？”</li>
<li>顶级域名服务器说：“我给你负责 <a target="_blank" rel="noopener" href="http://www.server.com/">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li>
<li>本地 DNS 于是转向问权威 DNS 服务器：“老三，<a href="http://www.server.com对应的IP是啥呀？”">www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li>
<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p>至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg" srcset="/img/loading.gif" lazyload alt="域名解析的工作流程"></p>
<p>DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<strong>只指路不带路</strong>。</p>
<blockquote>
<p>那是不是每次解析域名都要经过那么多的步骤呢？</p>
</blockquote>
<p>当然不是了，还有缓存这个东西的嘛。</p>
<p>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>
<h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><h5 id="tcp与udp的区别"><a href="#tcp与udp的区别" class="headerlink" title="tcp与udp的区别"></a>tcp与udp的区别</h5><ol>
<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
<li>……</li>
</ol>
<p>我把上面总结的内容通过表格形式展示出来了！确定不点个赞嘛？</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>举个简单的例子 快递小哥送货上门和放到驿站的区别</p>
</blockquote>
<h5 id="什么时候选择TCP什么时候选择UDP"><a href="#什么时候选择TCP什么时候选择UDP" class="headerlink" title="什么时候选择TCP什么时候选择UDP"></a>什么时候选择TCP什么时候选择UDP</h5><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h5 id="HTTP是基于TCP还是UDP"><a href="#HTTP是基于TCP还是UDP" class="headerlink" title="HTTP是基于TCP还是UDP"></a>HTTP是基于TCP还是UDP</h5><p>HTTP&#x2F;3.0 之前是基于 TCP 协议的，而 HTTP&#x2F;3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。此变化解决了 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。另外，HTTP&#x2F;2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP&#x2F;3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。</p>
<h5 id="还有哪些协议使用TCP协议，使用UDP的协议有哪些"><a href="#还有哪些协议使用TCP协议，使用UDP的协议有哪些" class="headerlink" title="还有哪些协议使用TCP协议，使用UDP的协议有哪些"></a>还有哪些协议使用TCP协议，使用UDP的协议有哪些</h5><p><strong>运行于 TCP 协议之上的协议</strong>：</p>
<ol>
<li><strong>HTTP 协议</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong>：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3&#x2F;IMAP 协议</strong>：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>Telnet 协议</strong>：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
<li>……</li>
</ol>
<p><strong>运行于 UDP 协议之上的协议</strong>：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong>：<strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
</ol>
<h5 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h5><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" srcset="/img/loading.gif" lazyload alt="TCP 三次握手图解">TCP 三次握手图解</p>
<p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li>
</ul>
<p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p>
<h5 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h5><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<hr>


<p><strong>这个说法其实不完整，来看看小林哥的解释</strong></p>
<p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p>
<p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p>
<p>在前面我们知道了什么是 <strong>TCP 连接</strong>：</p>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <strong>Socket、序列号和窗口大小</strong>称为连接。</li>
</ul>
<p>所以，重要的是<strong>为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。</strong></p>
<p>接下来，以三个方面分析三次握手的原因：</p>
<ul>
<li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<p><em>原因一：避免历史连接</em></p>
<p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>我们考虑一个场景，客户端先发送了 SYN（seq &#x3D; 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq &#x3D; 100）报文（<em>注意！不是重传 SYN，重传的 SYN 的序列号是一样的</em>）。</p>
<p>看看三次握手是如何阻止历史连接的：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230525514.png" srcset="/img/loading.gif" lazyload alt="三次握手避免历史连接"></p>
<p>客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在<strong>网络拥堵</strong>情况下：</p>
<ul>
<li>一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</li>
<li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会回 RST 报文。</li>
<li>服务端收到 RST 报文后，就会释放连接。</li>
<li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li>
</ul>
<p>上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p>
<p>TIP</p>
<p>有很多人问，如果服务端在收到 RST 报文之前，先收到了「新 SYN 报文」，也就是服务端收到客户端报文的顺序是：「旧 SYN 报文」-&gt;「新 SYN 报文」，此时会发生什么?</p>
<p>当服务端第一次收到 SYN 报文，也就是收到 「旧 SYN 报文」时，就会回复 <code>SYN + ACK</code> 报文给客户端，此报文中的确认号是 91（90+1）。</p>
<p>然后这时再收到「新 SYN 报文」时，就会回 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html">Challenge Ack (opens new window)</a>报文给客户端，<strong>这个 ack 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ack 确认号</strong>，也就是91（90+1）。所以客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就会回 RST 报文。</p>
<p><strong>如果是两次握手连接，就无法阻止历史连接</strong>，那为什么 TCP 两次握手为什么无法阻止历史连接呢？</p>
<p>我先直接说结论，主要是因为<strong>在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费</strong>。</p>
<p>你想想，在两次握手的情况下，服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/fe898053d2e93abac950b1637645943f.png" srcset="/img/loading.gif" lazyload alt="两次握手无法阻止历史连接"></p>
<p>可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。</p>
<p>因此，<strong>要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</strong>。</p>
<p>所以，<strong>TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。</strong></p>
<p>TIP</p>
<p>有人问：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</p>
<p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/%E7%9B%B8%E5%90%8Cack.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p>
<p><em>原因二：同步双方初始序列号</em></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230639121.png" srcset="/img/loading.gif" lazyload alt="四次握手与三次握手"></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><em>原因三：避免资源浪费</em></p>
<p>如果只有「两次握手」，当客户端发生的 <code>SYN</code> 报文在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，<strong>由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 <code>ACK</code> 报文，所以服务端每收到一个 <code>SYN</code> 就只能先主动建立一个连接</strong>，这会造成什么情况呢？</p>
<p>如果客户端发送的 <code>SYN</code> 报文在网络中阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务端在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230636571.png" srcset="/img/loading.gif" lazyload alt="两次握手会造成资源浪费"></p>
<p>即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<p>TIP</p>
<p>很多人问，两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？</p>
<p>我这里两次握手是假设「由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认报文，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接」这个场景。</p>
<p>当然你要实现成类似三次握手那样，根据上下文丢弃 syn 历史报文也是可以的，两次握手没有具体的实现，怎么假设都行。</p>
<p><em>小结</em></p>
<p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p>
<p>不使用「两次握手」和「四次握手」的原因：</p>
<ul>
<li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li>
<li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li>
</ul>
<h5 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h5><h2 id="-11"><a href="#-11" class="headerlink" title=""></a></h2><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" srcset="/img/loading.gif" lazyload alt="TCP 四次挥手图解">TCP 四次挥手图解</p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后，此时服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>
<li><strong>第三次挥手</strong>：服务端关闭与客户端的连接并发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<blockquote>
<p>其实四次挥手其实有时候是可以合并成3次挥手的，详细可以看小林哥这篇文章</p>
<p>当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
<p><strong>所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的。</strong></p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">4.22 TCP 四次挥手，可以变成三次吗？ | 小林coding (xiaolincoding.com)</a></p>
</blockquote>
<h5 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求</p>
<blockquote>
<p>详情可以看小林哥</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BA%86-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88">4.1 TCP 三次握手与四次挥手面试题 | 小林coding (xiaolincoding.com)</a></p>
</blockquote>
<h5 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h5><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<p>相同的问题如下</p>
<h5 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h5><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ul>
<p><em>原因一：防止历史连接中的数据，被后面相同四元组的连接错误的接收</em></p>
<p>为了能更好的理解这个原因，我们先来了解序列号（SEQ）和初始序列号（ISN）。</p>
<ul>
<li><strong>序列号</strong>，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。<strong>序列号是一个 32 位的无符号数，因此在到达 4G 之后再循环回到 0</strong>。</li>
<li><strong>初始序列号</strong>，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。<strong>初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，循环一次需要 4.55 小时</strong>。</li>
</ul>
<p>给大家抓了一个包，下图中的 Seq 就是序列号，其中红色框住的分别是客户端和服务端各自生成的初始序列号。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c9ea9b844e87bcd4acd3e320403ecab3.png" srcset="/img/loading.gif" lazyload alt="TCP 抓包图"></p>
<p>通过前面我们知道，<strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。</p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png" srcset="/img/loading.gif" lazyload alt="TIME-WAIT 时间过短，收到旧连接的数据报文"></p>
<p>如上图：</p>
<ul>
<li>服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li>
<li>接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 <code>SEQ = 301</code> 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li>
</ul>
<p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><em>原因二：保证「被动关闭连接」的一方，能被正确的关闭</em></p>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p>
<p><em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</em></p>
<p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</p>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/3a81c23ce57c27cf63fc2b77e34de0ab-20230309230604522.png" srcset="/img/loading.gif" lazyload alt="TIME-WAIT 时间过短，没有确保连接正常关闭"></p>
<p>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TIME-WAIT%E8%BF%9E%E6%8E%A5%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%AD.drawio.png" srcset="/img/loading.gif" lazyload alt="TIME-WAIT 时间正常，确保了连接正常关闭"></p>
<p>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<h5 id="为什么tcp是可靠的传输协议"><a href="#为什么tcp是可靠的传输协议" class="headerlink" title="为什么tcp是可靠的传输协议"></a>为什么tcp是可靠的传输协议</h5><p><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</p>
<p><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</p>
<p><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85">已丢失 </a>并进行重传。</p>
<p><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</p>
<p><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><h5 id="ip协议的作用是什么"><a href="#ip协议的作用是什么" class="headerlink" title="ip协议的作用是什么"></a>ip协议的作用是什么</h5><p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP&#x2F;IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<p>目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</p>
<h5 id="什么是ip地址，ip寻址如何工作"><a href="#什么是ip地址，ip寻址如何工作" class="headerlink" title="什么是ip地址，ip寻址如何工作"></a>什么是ip地址，ip寻址如何工作</h5><p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <strong>IP 地址（Internet Protocol address）</strong>，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。</p>
<p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p>
<p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p>
<p>这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/internet_protocol_ip_address_diagram.png" srcset="/img/loading.gif" lazyload alt="IP 地址使数据包到达其目的地">IP 地址使数据包到达其目的地</p>
<h5 id="什么是IP地址过滤"><a href="#什么是IP地址过滤" class="headerlink" title="什么是IP地址过滤"></a>什么是IP地址过滤</h5><p><strong>IP 地址过滤（IP Address Filtering）</strong> 简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。例如，你有一个图片服务突然被某一个 IP 地址攻击，那我们就可以禁止这个 IP 地址访问图片服务。</p>
<p>IP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。</p>
<h5 id="IPV4和IPV6的区别"><a href="#IPV4和IPV6的区别" class="headerlink" title="IPV4和IPV6的区别"></a>IPV4和IPV6的区别</h5><p><strong>IPv4（Internet Protocol version 4）</strong> 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/Figure-1-IPv4Addressformatwithdotteddecimalnotation-29c824f6a451d48d8c27759799f0c995.png" srcset="/img/loading.gif" lazyload alt="IPv4">IPv4</p>
<p>这么少当然不够用啦！为了解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议 - <strong>IPv6（Internet Protocol version 6）</strong>。IPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv4 使用 128 位互联网地址，这意味着越有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/Figure-2-IPv6Addressformatwithhexadecimalnotation-7da3a419bd81627a9b2cef3b0efb4940.png" srcset="/img/loading.gif" lazyload alt="IPv6">IPv6</p>
<p>除了更大的地址空间之外，IPv6 的优势还包括：</p>
<ul>
<li><strong>无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）</strong>：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。</li>
<li><strong>NAT（Network Address Translation，网络地址转换） 成为可选项</strong>：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。</li>
<li><strong>对标头结构进行了改进</strong>：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。</li>
<li><strong>可选的扩展头</strong>：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。</li>
<li><strong>ICMPv6（Internet Control Message Protocol for IPv6）</strong>：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。</li>
</ul>
<h5 id="什么是NAT，NAT的作用是什么"><a href="#什么是NAT，NAT的作用是什么" class="headerlink" title="什么是NAT，NAT的作用是什么"></a>什么是NAT，NAT的作用是什么</h5><p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-address-translation.png" srcset="/img/loading.gif" lazyload alt="NAT 实现 IP地址转换"></p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><h5 id="什么是MAC地址"><a href="#什么是MAC地址" class="headerlink" title="什么是MAC地址"></a>什么是MAC地址</h5><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p><img src="https://javaguide.cn/assets/2008410143049281-3c367990.png" srcset="/img/loading.gif" lazyload alt="路由器的背面就会注明 MAC 位址">路由器的背面就会注明 MAC 位址</p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h5 id="ARP协议解决了什么问题"><a href="#ARP协议解决了什么问题" class="headerlink" title="ARP协议解决了什么问题"></a>ARP协议解决了什么问题</h5><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<p>在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。</p>
<p>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 <strong>ARP 协议</strong>，求得下一跳的 MAC 地址。</p>
<blockquote>
<p>那么 ARP 又是如何知道对方 MAC 地址的呢？</p>
</blockquote>
<p>简单地说，ARP 是借助 <strong>ARP 请求与 ARP 响应</strong>两种类型的包确定 MAC 地址的。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/34.jpg" srcset="/img/loading.gif" lazyload alt="ARP 广播"></p>
<ul>
<li>主机会通过<strong>广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机。</li>
</ul>
<p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。</p>
<p>不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</p>
<blockquote>
<p>RARP 协议你知道是什么吗？</p>
</blockquote>
<p>ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是<strong>已知 MAC 地址求 IP 地址</strong>。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>
<p>通常这需要架设一台 <code>RARP</code> 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：</p>
<ul>
<li>该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。</li>
<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li>
</ul>
<p>最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/35.jpg" srcset="/img/loading.gif" lazyload alt="RARP"></p>
<blockquote>
<p>举个生动形象的例子</p>
<p>小明刚进入大学，他知道自己的班级基本信息，但是不知道自己的学号，于是就到教务处去询问：“我的信息是XX班XX，请问我的学号是多少？”然后就知道了自己的学号，然后大学第一天上高数的时候，高数老师说第一节课大家来自我介绍吧，然后高数老师根据学号抽到了你，然后你站起来完成了自我介绍。那么这个例子中就体现出了RARP和ARP两个协议的作用</p>
</blockquote>
<h4 id="网络安全相关"><a href="#网络安全相关" class="headerlink" title="网络安全相关"></a>网络安全相关</h4><h5 id="IP欺骗"><a href="#IP欺骗" class="headerlink" title="IP欺骗"></a>IP欺骗</h5><h6 id="IP是什么"><a href="#IP是什么" class="headerlink" title="IP是什么"></a>IP是什么</h6><p>在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「<strong>多少号多少室</strong>」，这个号就是分配给整个子网的，「<strong>室</strong>」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「<strong>室</strong>」对应的号码为主机号，这个地址的整体就是 <strong>IP 地址</strong>。</p>
<h6 id="通过IP地址我们能知道什么"><a href="#通过IP地址我们能知道什么" class="headerlink" title="通过IP地址我们能知道什么"></a>通过IP地址我们能知道什么</h6><p>通过 IP 地址，我们就可以知道判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点</p>
<p><strong>IP 头部格式</strong> :</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/843fd07074874ee0b695eca659411b42~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="IP欺骗技术是什么"><a href="#IP欺骗技术是什么" class="headerlink" title="IP欺骗技术是什么"></a>IP欺骗技术是什么</h6><p>骗呗，拐骗，诱骗！</p>
<p>IP 欺骗技术就是<strong>伪造</strong>某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够<strong>伪装</strong>另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。</p>
<p>假设现在有一个合法用户 <strong>(1.1.1.1)</strong> 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 <strong>1.1.1.1</strong>，并向服务器发送一个带有 RSI 位的 TCP 数据段。服务器接收到这样的数据后，认为从 <strong>1.1.1.1</strong> 发送的连接有错误，就会清空缓冲区中建立好的连接。</p>
<p>这时，如果合法用户 <strong>1.1.1.1</strong> 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7547a145adf9404aa3a05f01f5ca2e32~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="IP 欺骗 DDoS 攻击"></p>
<h6 id="如何缓解Ip欺骗"><a href="#如何缓解Ip欺骗" class="headerlink" title="如何缓解Ip欺骗"></a>如何缓解Ip欺骗</h6><p>虽然无法预防 IP 欺骗，但可以采取措施来阻止伪造数据包渗透网络。<strong>入口过滤</strong> 是防范欺骗的一种极为常见的防御措施，如 BCP38（通用最佳实践文档）所示。入口过滤是一种数据包过滤形式，通常在<a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/">网络边缘 </a>设备上实施，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击。</p>
<h5 id="SYN-Flood洪水"><a href="#SYN-Flood洪水" class="headerlink" title="SYN Flood洪水"></a>SYN Flood洪水</h5><h6 id="SYN-Flood是什么"><a href="#SYN-Flood是什么" class="headerlink" title="SYN Flood是什么"></a>SYN Flood是什么</h6><p>SYN Flood 是互联网上最原始、最经典的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击之一，旨在耗尽可用服务器资源，致使服务器无法传输合法流量</p>
<p>SYN Flood 利用了 TCP 协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源 IP 地址或变源端口的 TCP SYN 报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。 增加服务器性能，提供更多的连接能力对于 SYN Flood 的海量报文来说杯水车薪，防御 SYN Flood 的关键在于判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b3d2d4dc8f24890b5957df1c7d6feb8~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="TCP-SYN-Flood-攻击原理是什么？"><a href="#TCP-SYN-Flood-攻击原理是什么？" class="headerlink" title="TCP SYN Flood 攻击原理是什么？"></a>TCP SYN Flood 攻击原理是什么？</h6><p><strong>TCP SYN Flood</strong> 攻击利用的是 <strong>TCP</strong> 的三次握手（<strong>SYN -&gt; SYN&#x2F;ACK -&gt; ACK</strong>），假设连接发起方是 A，连接接受方是 B，即 B 在某个端口（<strong>Port</strong>）上监听 A 发出的连接请求，过程如下图所示，左边是 A，右边是 B。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39355a1ea404323a11ca6644e009183~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>A 首先发送 <strong>SYN</strong>（Synchronization）消息给 B，要求 B 做好接收数据的准备；B 收到后反馈 <strong>SYN-ACK</strong>（Synchronization-Acknowledgement） 消息给 A，这个消息的目的有两个：</p>
<ul>
<li>向 A 确认已做好接收数据的准备，</li>
<li>同时要求 A 也做好接收数据的准备，此时 B 已向 A 确认好接收状态，并等待 A 的确认，连接处于<strong>半开状态（Half-Open）</strong>，顾名思义只开了一半；A 收到后再次发送 <strong>ACK</strong> (Acknowledgement) 消息给 B，向 B 确认也做好了接收数据的准备，至此三次握手完成，「<strong>连接</strong>」就建立了，</li>
</ul>
<p>大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了<strong>可以接收消息</strong>的状态。而这个状态的确认主要是双方将要使用的**消息序号(**SequenceNum)，**TCP** 为保证消息按发送顺序抵达接收方的上层应用，需要用**消息序号**来标记消息的发送先后顺序的。</p>
<p><strong>TCP</strong>是「<strong>双工</strong>」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 <strong>SYN</strong> 和 <strong>SYN-ACK</strong> 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；<strong>SYN-ACK</strong> 和 <strong>ACK</strong> 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。</p>
<p>上面讨论的是双方在诚实守信，正常情况下的通信。</p>
<p>但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。</p>
<p>假设 B 通过某 <strong>TCP</strong> 端口提供服务，B 在收到 A 的 <strong>SYN</strong> 消息时，积极的反馈了 <strong>SYN-ACK</strong> 消息，使连接进入<strong>半开状态</strong>，因为 B 不确定自己发给 A 的 <strong>SYN-ACK</strong> 消息或 A 反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接都设一个<strong>Timer</strong>，如果超过时间还没有收到 A 的 <strong>ACK</strong> 消息，则重新发送一次 <strong>SYN-ACK</strong> 消息给 A，直到重试超过一定次数时才会放弃。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ff1daddcec44d61994f254e664987b4~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="图片">图片</p>
<p>B 为帮助 A 能顺利连接，需要<strong>分配内核资源</strong>维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，<strong>SYN Flood</strong> 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 <strong>Source IP</strong>，使 B 反馈的 <strong>SYN-ACK</strong> 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<h6 id="SYN-Flood-的常见形式有哪些？"><a href="#SYN-Flood-的常见形式有哪些？" class="headerlink" title="SYN Flood 的常见形式有哪些？"></a>SYN Flood 的常见形式有哪些？</h6><p><strong>恶意用户可通过三种不同方式发起 SYN Flood 攻击</strong>：</p>
<ol>
<li><strong>直接攻击：</strong>不伪造 IP 地址的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署防火墙规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。实际上，这种方法很少使用（即便使用过也不多见），因为此类攻击相当容易缓解 – 只需阻止每个恶意系统的 IP 地址。哪怕攻击者使用僵尸网络（如 <a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/">Mirai 僵尸网络 </a>），通常也不会刻意屏蔽受感染设备的 IP。</li>
<li><strong>欺骗攻击：</strong>恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以便阻止缓解措施并加大身份暴露难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。此类检测工作很难开展，但并非不可实现；特别是，如果 Internet 服务提供商 (ISP) 愿意提供帮助，则更容易实现。</li>
<li><strong>分布式攻击（DDoS）：</strong>如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。随着混淆级别的攀升，攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP。</li>
</ol>
<h6 id="如何缓解SYNFlood"><a href="#如何缓解SYNFlood" class="headerlink" title="如何缓解SYNFlood"></a>如何缓解SYNFlood</h6><p>扩展积压工作队列</p>
<p>目标设备安装的每个操作系统都允许具有一定数量的半开连接。若要响应大量 SYN 数据包，一种方法是增加操作系统允许的最大半开连接数目。为成功扩展最大积压工作，系统必须额外预留内存资源以处理各类新请求。如果系统没有足够的内存，无法应对增加的积压工作队列规模，将对系统性能产生负面影响，但仍然好过拒绝服务。</p>
<p>回收最先创建的 TCP 半开连接</p>
<p>另一种缓解策略是在填充积压工作后覆盖最先创建的半开连接。这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效。</p>
<p>SYN Cookie</p>
<p>此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。</p>
<h5 id="UDP-Flood"><a href="#UDP-Flood" class="headerlink" title="UDP Flood"></a>UDP Flood</h5><h6 id="UDP-Flood是什么"><a href="#UDP-Flood是什么" class="headerlink" title="UDP Flood是什么"></a>UDP Flood是什么</h6><p><strong>UDP Flood</strong> 也是一种拒绝服务攻击，将大量的用户数据报协议（<strong>UDP</strong>）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 <strong>UDP</strong> 泛滥而耗尽，从而导致对合法流量的拒绝服务。</p>
<h6 id="UDP攻击原理是什么"><a href="#UDP攻击原理是什么" class="headerlink" title="UDP攻击原理是什么"></a>UDP攻击原理是什么</h6><p><strong>UDP Flood</strong> 主要通过利用服务器响应发送到其中一个端口的 <strong>UDP</strong> 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 <strong>UDP</strong> 数据包时，会经过两个步骤：</p>
<ul>
<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序。</li>
<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达。</li>
</ul>
<p>举个例子。假设今天要联系酒店的小蓝，酒店客服接到电话后先查看房间的列表来确保小蓝在客房内，随后转接给小蓝。</p>
<p>首先，接待员接收到呼叫者要求连接到特定房间的电话。接待员然后需要查看所有房间的清单，以确保客人在房间中可用，并愿意接听电话。碰巧的是，此时如果突然间所有的电话线同时亮起来，那么他们就会很快就变得不堪重负了。</p>
<p>当服务器接收到每个新的 <strong>UDP</strong> 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 <strong>UDP</strong> 报文时，每个报文将包含源设备的 <strong>IP</strong> 地址。在这种类型的 <strong>DDoS</strong> 攻击期间，攻击者通常不会使用自己的真实 <strong>IP</strong> 地址，而是会欺骗 <strong>UDP</strong> 数据包的源 <strong>IP</strong> 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。</p>
<p>由于目标服务器利用资源检查并响应每个接收到的 <strong>UDP</strong> 数据包的结果，当接收到大量 <strong>UDP</strong> 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23dbbc8243a84ed181e088e38bffb37a~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="如何缓解UDP-Flooding"><a href="#如何缓解UDP-Flooding" class="headerlink" title="如何缓解UDP Flooding"></a>如何缓解UDP Flooding</h6><p>大多数操作系统部分限制了 <strong>ICMP</strong> 报文的响应速率，以中断需要 ICMP 响应的 <strong>DDoS</strong> 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 <strong>UDP Flood</strong> 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。</p>
<h5 id="HTTP-Flood"><a href="#HTTP-Flood" class="headerlink" title="HTTP Flood"></a>HTTP Flood</h5><h6 id="HTTP-Flood是什么"><a href="#HTTP-Flood是什么" class="headerlink" title="HTTP Flood是什么"></a>HTTP Flood是什么</h6><p>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa64869551d94c8d89fa80eaf4395bfa~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="HTTP 洪水攻击">HTTP 洪水攻击</p>
<h6 id="HTTP-Flood-的攻击原理是什么？"><a href="#HTTP-Flood-的攻击原理是什么？" class="headerlink" title="HTTP Flood 的攻击原理是什么？"></a>HTTP Flood 的攻击原理是什么？</h6><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><p>HTTP 洪水攻击是“第 7 层”DDoS 攻击的一种。第 7 层是 OSI 模型的应用程序层，指的是 HTTP 等互联网协议。HTTP 是基于浏览器的互联网请求的基础，通常用于加载网页或通过互联网发送表单内容。缓解应用程序层攻击特别复杂，因为恶意流量和正常流量很难区分。</p>
<p>为了获得最大效率，恶意行为者通常会利用或创建僵尸网络，以最大程度地扩大攻击的影响。通过利用感染了恶意软件的多台设备，攻击者可以发起大量攻击流量来进行攻击。</p>
<p>HTTP 洪水攻击有两种：</p>
<ul>
<li><strong>HTTP GET 攻击</strong>：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。</li>
<li><strong>HTTP POST 攻击</strong>：一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。</li>
</ul>
<h6 id="如何防护-HTTP-Flood？"><a href="#如何防护-HTTP-Flood？" class="headerlink" title="如何防护 HTTP Flood？"></a>如何防护 HTTP Flood？</h6><p>如前所述，缓解第 7 层攻击非常复杂，而且通常要从多方面进行。一种方法是对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击。</p>
<p>其他阻止 HTTP 洪水攻击的途径包括使用 Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析。Cloudflare 具有超过 2000 万个互联网设备的规模优势，能够分析来自各种来源的流量并通过快速更新的 WAF 规则和其他防护策略来缓解潜在的攻击，从而消除应用程序层 DDoS 流量。</p>
<h5 id="DNS-Flood"><a href="#DNS-Flood" class="headerlink" title="DNS Flood"></a>DNS Flood</h5><h6 id="DNS-Flood是什么"><a href="#DNS-Flood是什么" class="headerlink" title="DNS Flood是什么"></a>DNS Flood是什么</h6><p>域名系统（DNS）服务器是互联网的“电话簿“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。DNS Flood 攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS Flood 攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood 攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量。</p>
<h6 id="DNS-Flood的原理是什么"><a href="#DNS-Flood的原理是什么" class="headerlink" title="DNS Flood的原理是什么"></a>DNS Flood的原理是什么</h6><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97ea11a212924900b10d159226783887~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>域名系统的功能是将易于记忆的名称（例如 example.com）转换成难以记住的网站服务器地址（例如 192.168.0.1），因此成功攻击 DNS 基础设施将导致大多数人无法使用互联网。DNS Flood 攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽<a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/">物联网（IoT） </a><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-botnet/">僵尸网络 </a>（如 <a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/">Mirai </a>）兴起后激增的。DNS Flood 攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。</p>
<p>DNS Flood 攻击不同于 <a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/learning/ddos/dns-amplification-ddos-attack/">DNS 放大攻击 </a>。与 DNS Flood 攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。这些设备对非常大的 DNS 记录发出小型请求，但在发出请求时，攻击者伪造返回地址为目标受害者。这种放大效果让攻击者能借助有限的攻击资源来破坏较大的目标。</p>
<h6 id="如何防护-DNS-Flood"><a href="#如何防护-DNS-Flood" class="headerlink" title="如何防护 DNS Flood?"></a>如何防护 DNS Flood?</h6><p>DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。</p>
<h5 id="TCP重置攻击"><a href="#TCP重置攻击" class="headerlink" title="TCP重置攻击"></a>TCP重置攻击</h5><p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>
<p><strong>TCP</strong> 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 <strong>TCP</strong> 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 <strong>TCP</strong> 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。</p>
<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP&#x2F;IP</strong> 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 <code>IPSec</code>）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 <code>TLS</code>）来验证服务端的身份。但这个方法对 <strong>TCP</strong> 重置包并不适用，因为 <strong>TCP</strong> 重置包是 <strong>TCP</strong> 协议本身的一部分，无法使用更高级别的协议进行验证。</p>
<h5 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h5><p>猪八戒要向小蓝表白，于是写了一封信给小蓝，结果第三者小黑拦截到了这封信，把这封信进行了篡改，于是乎在他们之间进行搞破坏行动。这个马文才就是中间人，实施的就是中间人攻击。好我们继续聊聊什么是中间人攻击。</p>
<h6 id="什么是中间人攻击"><a href="#什么是中间人攻击" class="headerlink" title="什么是中间人攻击"></a>什么是中间人攻击</h6><p>中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM 攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。我们画一张图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d69b74e63981472b852797f2fa08976f~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="图片">图片</p>
<p>从这张图可以看到，中间人其实就是攻击者。通过这种原理，有很多实现的用途，比如说，你在手机上浏览不健康网站的时候，手机就会提示你，此网站可能含有病毒，是否继续访问还是做其他的操作等等</p>
<h6 id="中间人攻击的原理是什么？"><a href="#中间人攻击的原理是什么？" class="headerlink" title="中间人攻击的原理是什么？"></a>中间人攻击的原理是什么？</h6><p>举个例子，我和公司签了一个一份劳动合同，一人一份合同。不晓得哪个可能改了合同内容，不知道真假了，怎么搞？只好找专业的机构来鉴定，自然就要花钱。</p>
<p>在安全领域有句话：<strong>我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本</strong>。既然没法杜绝这种情况，那我们就想办法提高作案的成本，今天我们就简单了解下基本的网络安全知识，也是面试中的高频面试题了。</p>
<p>为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。</p>
<p><strong>如果第三方机构内部不严格或容易出现纰漏？</strong></p>
<p>虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢</p>
<p>一种可行的办法是引入 <strong>摘要算法</strong> 。即合同和摘要一起，为了简单的理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。</p>
<h6 id="有哪些常用的摘要算法呢？"><a href="#有哪些常用的摘要算法呢？" class="headerlink" title="有哪些常用的摘要算法呢？"></a>有哪些常用的摘要算法呢？</h6><p>目前比较常用的加密算法有消息摘要算法和安全散列算法(<strong>SHA</strong>)。<strong>MD5</strong> 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，<strong>MD5</strong> 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。</p>
<p>所以在大部分的情况下都会选择 <strong>SHA 算法</strong> 。</p>
<p><strong>出现内鬼了怎么办？</strong></p>
<p>看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全的杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢</p>
<p><strong>那如何确保员工不会修改合同呢？</strong></p>
<p>这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大</p>
<p><strong>那么员工万一和某个用户串通好了呢？</strong></p>
<p>看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了 <strong>数字签名和证书</strong>。</p>
<h6 id="数字签名证书有什么用，什么是非对称加密"><a href="#数字签名证书有什么用，什么是非对称加密" class="headerlink" title="数字签名证书有什么用，什么是非对称加密"></a>数字签名证书有什么用，什么是非对称加密</h6><p>同样的，举个例子。Sum 和 Mike 两个人签合同。Sum 首先用 <strong>SHA</strong> 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Sum 将合同原文、签名，以及公钥三者都交给 Mike</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b7d6fca78b45c8840c12411b717f2f~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如果 Sum 想要证明合同是 Mike 的，那么就要使用 Mike 的公钥，将这个签名解密得到摘要 x，然后 Mike 计算原文的 sha 摘要 Y，随后对比 x 和 y，如果两者相等，就认为数据没有被篡改</p>
<p>在这样的过程中，Mike 是不能更改 Sum 的合同，因为要修改合同不仅仅要修改原文还要修改摘要，修改摘要需要提供 Mike 的私钥，私钥即 Sum 独有的密码，公钥即 Sum 公布给他人使用的密码</p>
<p>总之，公钥加密的数据只能私钥可以解密。私钥加密的数据只有公钥可以解密，这就是 <strong>非对称加密</strong> 。</p>
<h6 id="什么是对称加密"><a href="#什么是对称加密" class="headerlink" title="什么是对称加密"></a>什么是对称加密</h6><p>对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef81cb5e2f0a4d3d9ac5a44ecf97e3cc~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h6 id="第三方机构和证书机制有什么用？"><a href="#第三方机构和证书机制有什么用？" class="headerlink" title="第三方机构和证书机制有什么用？"></a>第三方机构和证书机制有什么用？</h6><p>问题还有，此时如果 Sum 否认给过 Mike 的公钥和合同，不久 gg 了</p>
<p>所以需要 Sum 过的话做过的事儿需要足够的信誉，这就引入了 <strong>第三方机构和证书机制</strong> 。</p>
<p>证书之所以会有信用，是因为证书的签发方拥有信用。所以如果 Sum 想让 Mike 承认自己的公钥，Sum 不会直接将公钥给 Mike ，而是提供由第三方机构，含有公钥的证书。如果 Mike 也信任这个机构，法律都认可，那 ik，信任关系成立</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1a3dbf87e3e41ff894f39512a10f66d~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>如上图所示，Sum 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Sum 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Mike 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Sum 证书的摘要、证书的原文。有了 Sum 证书的摘要和原文，Mike 就可以进行验签。验签通过，Mike 就可以确认 Sum 的证书的确是第三方机构签发的。</p>
<p>用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于需要第三方信用服务机构提供信用背书。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了</p>
<p>为了让这个信任条更加稳固，就需要环环相扣，打造更长的信任链，避免单点信任风险</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1481f0409da94ba6bb0fee69bf0996f8~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Sum 证书。</p>
<p>如果要验证 Sum 证书的合法性，就需要用三级机构证书中的公钥去解密 Sum 证书的数字签名。</p>
<p>如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。</p>
<p>如果要验证二级结构证书的合法性，就需要用根证书去解密。</p>
<p>以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。</p>
<blockquote>
<p>前面我们知道：</p>
<ul>
<li>可以通过哈希算法来保证消息的完整性；</li>
<li>可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；</li>
</ul>
<p>但是这还远远不够，<strong>还缺少身份验证的环节</strong>，万一公钥是被伪造的呢？</p>
<p>还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。</p>
<p>但是我们还可以自己伪造出一对公私钥啊！</p>
<p>你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。</p>
<p>但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是你父亲写的请假条，又允许你请假了。</p>
<p>好家伙，为了一个请假，真的是斗智斗勇。</p>
<p>后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。</p>
<p>正所谓魔高一丈，道高一尺。</p>
<p>既然伪造公私钥那么随意，所以你爸把他的公钥注册到<strong>警察局</strong>，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息 + 公钥 + 数字签名」打包成一个<strong>数字证书，也就是说这个数字证书包含你爸爸的公钥。</strong></p>
<p>这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。</p>
<p>老师拿到了数字证书后，<strong>首先会去警察局验证这个数字证书是否合法</strong>，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥（你爸爸的）给到老师。</p>
<p><strong>由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的</strong>，于是老师就可以安心的用这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。</p>
<p>正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。</p>
<p>在计算机里，这个权威的机构就是 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<p>数字证书的工作流程，我也画了一张图，方便大家理解：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" lazyload alt="数子证书工作流程"></p>
</blockquote>
<h6 id="中间人攻击如何避免"><a href="#中间人攻击如何避免" class="headerlink" title="中间人攻击如何避免"></a>中间人攻击如何避免</h6><p>既然知道了中间人攻击的原理也知道了他的危险，现在我们看看如何避免。相信我们都遇到过下面这种状况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dde4b76be6240699312d822a3fe1ed3~tplv-k3u1fbpfcp-zoom-1.image" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>出现这个界面的很多情况下，都是遇到了中间人攻击的现象，需要对安全证书进行及时地监测。而且大名鼎鼎的 github 网站，也曾遭遇过中间人攻击：</p>
<p>想要避免中间人攻击的方法目前主要有两个：</p>
<ul>
<li>客户端不要轻易相信证书：因为这些证书极有可能是中间人。</li>
<li>App 可以提前预埋证书在本地：意思是我们本地提前有一些证书，这样其他证书就不能再起作用了。</li>
</ul>
<h5 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h5><p>通过上面的描述，总之即好多种攻击都是 <strong>DDOS</strong> 攻击，所以简单总结下这个攻击相关内容。</p>
<p>其实，像全球互联网各大公司，均遭受过大量的 <strong>DDoS</strong>。</p>
<p>2018 年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。后续的 DDoS 攻击带宽最高也达到了 1Tbps</p>
<h6 id="什么是DDos"><a href="#什么是DDos" class="headerlink" title="什么是DDos"></a>什么是DDos</h6><p>攻击DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p>
<blockquote>
<p>举个例子</p>
</blockquote>
<p>我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。</p>
<p>上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。</p>
<p>攻击方式很多，比如 <strong>ICMP Flood</strong>、<strong>UDP Flood</strong>、<strong>NTP Flood</strong>、<strong>SYN Flood</strong>、<strong>CC 攻击</strong>、<strong>DNS Query Flood</strong>等等。</p>
<h6 id="如何应对DDOS攻击"><a href="#如何应对DDOS攻击" class="headerlink" title="如何应对DDOS攻击"></a>如何应对DDOS攻击</h6><ul>
<li><p><strong>高防服务器</strong> ：</p>
<p>还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。</p>
<p>高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~</p>
</li>
<li><p><strong>黑名单</strong></p>
<p>面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。</p>
</li>
<li><p><strong>DDOS清洗</strong></p>
<p><strong>DDos</strong> 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。</p>
<p><strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p>
</li>
<li><p><strong>CDN加速</strong></p>
<p>CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。</p>
<p>在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</p>
</li>
</ul>
<h3 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h5 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h5><h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><p>通过以下四点可以概括操作系统到底是什么：</p>
<ol>
<li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</li>
<li>操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<p>很多人容易把操作系统的内核（Kernel）和中央处理器（CPU，Central Processing Unit）弄混。你可以简单从下面两点来区别：</p>
<ol>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>
</ol>
<p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p>
<p><img src="https://oss.javaguide.cn/2020-8/Kernel_Layout.png" srcset="/img/loading.gif" lazyload alt="Kernel_Layout"></p>
<h5 id="什么是用户态和内核态"><a href="#什么是用户态和内核态" class="headerlink" title="什么是用户态和内核态"></a>什么是用户态和内核态</h5><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ul>
<li><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</li>
<li>**内核态(Kernel Mode)**：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/usermode-and-kernelmode.png" srcset="/img/loading.gif" lazyload alt="用户态和内核态">用户态和内核态</p>
<p>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p>
<h5 id="为什么要有用户态和内核态？只有一个内核态不行么？"><a href="#为什么要有用户态和内核态？只有一个内核态不行么？" class="headerlink" title="为什么要有用户态和内核态？只有一个内核态不行么？"></a>为什么要有用户态和内核态？只有一个内核态不行么？</h5><ul>
<li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 <strong>特权指令</strong> 。</li>
<li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li>
</ul>
<p>因此，同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。</p>
<h5 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h5><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/the-way-switch-between-user-mode-and-kernel-mode.drawio.png" srcset="/img/loading.gif" lazyload alt="用户态切换到内核态的 3 种方式">用户态切换到内核态的 3 种方式</p>
<p>用户态切换到内核态的 3 种方式：</p>
<ol>
<li><strong>系统调用（Trap）</strong>：用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</li>
<li><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
<li><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
</ol>
<p>在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。</p>
<h5 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h5><p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的内核态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call.png" srcset="/img/loading.gif" lazyload alt="系统调用"></p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li>
<li>文件管理：完成文件的读、写、创建及删除等功能。</li>
<li>进程管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等功能。</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>
<p>总结：系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。</p>
<h5 id="系统调用的过程了解吗？"><a href="#系统调用的过程了解吗？" class="headerlink" title="系统调用的过程了解吗？"></a>系统调用的过程了解吗？</h5><p>系统调用的过程可以简单分为以下几个步骤：</p>
<ol>
<li>用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</li>
<li>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。</li>
<li>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call-procedure.png" srcset="/img/loading.gif" lazyload alt="系统调用的过程"></p>
<h5 id="进程和线程-1"><a href="#进程和线程-1" class="headerlink" title="进程和线程"></a>进程和线程</h5><h6 id="什么是进程，什么是线程"><a href="#什么是进程，什么是线程" class="headerlink" title="什么是进程，什么是线程"></a>什么是进程，什么是线程</h6><p><strong>进程（Process）</strong> 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。</p>
<p><strong>线程（Thread）</strong> 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。</p>
<h6 id="进程和线程的区别是什么"><a href="#进程和线程的区别是什么" class="headerlink" title="进程和线程的区别是什么"></a>进程和线程的区别是什么</h6><p>下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" srcset="/img/loading.gif" lazyload alt="Java 运行时数据区域（JDK1.8 之后）">Java 运行时数据区域（JDK1.8 之后）</p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、</strong>虚拟机栈** 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong></p>
<ul>
<li>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。</li>
<li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>线程执行开销小，但不利于资源的管理和保护；而进程正相反</li>
</ul>
<h6 id="有了进程为什么还要线程"><a href="#有了进程为什么还要线程" class="headerlink" title="有了进程为什么还要线程"></a>有了进程为什么还要线程</h6><ul>
<li>进程切换是一个开销很大的操作，线程切换的成本较低。</li>
<li>线程更轻量，一个进程可以创建多个线程。</li>
<li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li>
<li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li>
</ul>
<h6 id="为什么要使用多线程-1"><a href="#为什么要使用多线程-1" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h6><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>
<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</li>
</ul>
<h6 id="线程同步的方法有哪些"><a href="#线程同步的方法有哪些" class="headerlink" title="线程同步的方法有哪些"></a>线程同步的方法有哪些</h6><p>线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。</p>
<p>下面是几种常见的线程同步的方式：</p>
<ol>
<li>**互斥锁(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 <code>synchronized</code> 关键词和各种 <code>Lock</code> 都是这种机制。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li>
<li>**信号量(Semaphore)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>屏障（Barrier）</strong>：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 <code>CyclicBarrier</code> 是这种机制。</li>
<li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h6 id="PCB-是什么？包含哪些信息"><a href="#PCB-是什么？包含哪些信息" class="headerlink" title="PCB 是什么？包含哪些信息"></a>PCB 是什么？包含哪些信息</h6><p><strong>PCB（Process Control Block）</strong> 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。</p>
<p>当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。</p>
<p>PCB 主要包含下面几部分的内容：</p>
<ul>
<li>进程的描述信息，包括进程的名称、标识符等等；</li>
<li>进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；</li>
<li>进程对资源的需求情况，包括 CPU 时间、内存空间、I&#x2F;O 设备等等。</li>
<li>进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。</li>
<li>处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针</li>
</ul>
<h6 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态"></a>进程有哪几种状态</h6><p>我们一般把进程大致分为 5 种状态，这一点和线程很像！</p>
<ul>
<li>**创建状态(new)**：进程正在被创建，尚未到就绪状态。</li>
<li>**就绪状态(ready)**：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li>**运行状态(running)**：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li>**阻塞状态(waiting)**：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li>**结束状态(terminated)**：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/state-transition-of-process.png" srcset="/img/loading.gif" lazyload alt="进程状态图转换图"></p>
<h6 id="进程之间的通信方式有哪几种"><a href="#进程之间的通信方式有哪几种" class="headerlink" title="进程之间的通信方式有哪几种"></a>进程之间的通信方式有哪几种</h6><p>**管道&#x2F;匿名管道(Pipes)**：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</p>
<p><strong>有名管道(Named Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 <strong>先进先出(First In First Out)</strong> 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
<p>**信号(Signal)**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p>
<p><strong>消息队列(Message Queuing)<strong>：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。</strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></p>
<p>**信号量(Semaphores)**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</p>
<p>**共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</p>
<p><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<h6 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h6><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/scheduling-algorithms-of-process.png" srcset="/img/loading.gif" lazyload alt="常见进程调度算法">常见进程调度算法</p>
<p>这是一个很重要的知识点！为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务调度算法(FCFS，First Come, First Served)</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先的调度算法(SJF，Shortest Job First)</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法（RR，Round-Robin）</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）</strong>：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度算法（Priority）</strong>：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h6 id="什么是僵尸进程和孤儿进程"><a href="#什么是僵尸进程和孤儿进程" class="headerlink" title="什么是僵尸进程和孤儿进程"></a>什么是僵尸进程和孤儿进程</h6><p>在 Unix&#x2F;Linux 系统中，子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<p>当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。</p>
<p>这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB 仍然存在但父进程无法得到状态信息的情况）。</p>
<ul>
<li><strong>僵尸进程</strong>：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。</li>
<li><strong>孤儿进程</strong>：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h6 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h6><p>死锁（Deadlock）描述的是这样一种情况：多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p>
<h6 id="能列举一个操作系统发生死锁的例子吗？"><a href="#能列举一个操作系统发生死锁的例子吗？" class="headerlink" title="能列举一个操作系统发生死锁的例子吗？"></a>能列举一个操作系统发生死锁的例子吗？</h6><p>假设有两个进程 A 和 B，以及两个资源 X 和 Y，它们的分配情况如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>占用资源</th>
<th>需求资源</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>X</td>
<td>Y</td>
</tr>
<tr>
<td>B</td>
<td>Y</td>
<td>X</td>
</tr>
</tbody></table>
<p>此时，进程 A 占用资源 X 并且请求资源 Y，而进程 B 已经占用了资源 Y 并请求资源 X。两个进程都在等待对方释放资源，无法继续执行，陷入了死锁状态。</p>
<h6 id="产生死锁的四个必要条件是什么"><a href="#产生死锁的四个必要条件是什么" class="headerlink" title="产生死锁的四个必要条件是什么"></a>产生死锁的四个必要条件是什么</h6><ol>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ol>
<p><strong>注意 ⚠️</strong>：这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h6 id="能写一个模拟死锁的代码吗"><a href="#能写一个模拟死锁的代码吗" class="headerlink" title="能写一个模拟死锁的代码吗"></a>能写一个模拟死锁的代码吗</h6><p>下面通过一个实际的例子来模拟下图展示的线程死锁：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png" srcset="/img/loading.gif" lazyload alt="线程死锁示意图 ">线程死锁示意图 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Thread[线程 1,5,main]get resource1<br>Thread[线程 2,5,main]get resource2<br>Thread[线程 1,5,main]waiting get resource2<br>Thread[线程 2,5,main]waiting get resource1<br></code></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 <code>resource2</code> 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<h6 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h6><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p>
<ul>
<li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li>
<li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li>
<li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li>
<li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<p><strong>死锁的预防</strong></p>
<p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p>
<p>破坏第三个条件 <strong>非抢占</strong>：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所有的资源，会导致 <strong>资源利用率下降</strong>。</p>
<p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p>
<p><strong>1、静态分配策略</strong></p>
<p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p>
<p><strong>2、层次分配策略</strong></p>
<p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p>
<p><strong>死锁的避免</strong></p>
<p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p>
</blockquote>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<p>银行家算法详情可见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33414271/article/details/80245715">《一句话+一张图说清楚——银行家算法》open in new window</a> 。</p>
<p>操作系统教程书中讲述的银行家算法也比较清晰，可以一看.</p>
<p>死锁的避免(银行家算法)改善了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p>
<p><strong>死锁的检测</strong></p>
<p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<p>进程-资源分配图</p>
<p>操作系统中的每一刻时刻的<strong>系统状态</strong>都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p>
<p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p>
<p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/process-resource-allocation-diagram.jpg" srcset="/img/loading.gif" lazyload alt="进程-资源分配图">进程-资源分配图</p>
<p>进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p>
<p>死锁检测步骤</p>
<p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
<p><strong>死锁的解除</strong></p>
<p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p>
<ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong>：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong>：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong>：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
<h5 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h5><h6 id="内存管理主要做什么"><a href="#内存管理主要做什么" class="headerlink" title="内存管理主要做什么"></a>内存管理主要做什么</h6><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png" srcset="/img/loading.gif" lazyload alt="内存管理主要做的事情">内存管理主要做的事情</p>
<p>操作系统的内存管理非常重要，主要负责下面这些事情：</p>
<ul>
<li><strong>内存的分配与回收</strong>：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li>
<li><strong>地址转换</strong>：将程序中的虚拟地址转换成内存中的物理地址。</li>
<li><strong>内存扩充</strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li><strong>内存映射</strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li>
<li><strong>内存优化</strong>：通过调整内存分配策略和回收算法来优化内存使用效率。</li>
<li><strong>内存安全</strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li>
</ul>
<h6 id="什么是内存碎片"><a href="#什么是内存碎片" class="headerlink" title="什么是内存碎片"></a>什么是内存碎片</h6><p>内存碎片是由内存的申请和释放产生的，通常分为下面两种：</p>
<ul>
<li>**内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)**：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。</li>
<li>**外部内存碎片(External Memory Fragmentation，简称为外部碎片)**：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并为分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png" srcset="/img/loading.gif" lazyload alt="内存碎片">内存碎片</p>
<p>内存碎片会导致内存利用率下降，如何减少内存碎片是内存管理要非常重视的一件事情。</p>
<h6 id="常见的内存管理有哪些方式"><a href="#常见的内存管理有哪些方式" class="headerlink" title="常见的内存管理有哪些方式"></a>常见的内存管理有哪些方式</h6><p>内存管理方式可以简单分为下面两种：</p>
<ul>
<li><strong>连续内存管理</strong>：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。</li>
<li><strong>非连续内存管理</strong>：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</li>
</ul>
<p><strong>连续内存管理</strong></p>
<p><strong>块式管理</strong> 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。</p>
<p>在 Linux 系统中，连续内存管理采用了 <strong>伙伴系统（Buddy System）算法</strong> 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6&#x3D;64 KB），并将相邻的内存块组合成一对伙伴（注意：<strong>必须是相邻的才是伙伴</strong>）。</p>
<p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。</p>
<p>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux-buddy-system.png" srcset="/img/loading.gif" lazyload alt="伙伴系统（Buddy System）内存管理">伙伴系统（Buddy System）内存管理</p>
<p>虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 2^n 的内存块，因此当需要分配的内存大小不是 2^n 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 2^7&#x3D;128 大小的内存块。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/buddy-system-memory-waste.png" srcset="/img/loading.gif" lazyload alt="伙伴系统内存浪费问题">伙伴系统内存浪费问题</p>
<p>对于内部内存碎片的问题，Linux 采用 <strong>SLAB</strong> 进行解决。由于这部分内容不是本篇文章的重点，这里就不详细介绍了。</p>
<p><strong>非连续内存管理</strong></p>
<p>非连续内存管理存在下面 3 种方式：</p>
<ul>
<li><strong>段式管理</strong>：以段(—段连续的物理内存)的形式管理&#x2F;分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</li>
<li><strong>页式管理</strong>：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页，现代操作系统广泛使用的一种内存管理方式。</li>
<li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页</li>
</ul>
<h6 id="什么是虚拟内存，有什么用"><a href="#什么是虚拟内存，有什么用" class="headerlink" title="什么是虚拟内存，有什么用"></a>什么是虚拟内存，有什么用</h6><p><strong>虚拟内存(Virtual Memory)</strong> 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。</p>
<p><img src="https://oss.javaguide.cn/xingqiu/virtual-memory.png" srcset="/img/loading.gif" lazyload alt="虚拟内存作为进程访问主存的桥梁">虚拟内存作为进程访问主存的桥梁</p>
<p>总结来说，虚拟内存主要提供了下面这些能力：</p>
<ul>
<li><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
<li><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li>
<li><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li>
<li><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li>
<li><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li>
<li><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
</ul>
<h6 id="没有虚拟内存有什么问题？"><a href="#没有虚拟内存有什么问题？" class="headerlink" title="没有虚拟内存有什么问题？"></a>没有虚拟内存有什么问题？</h6><p>如果没有虚拟内存的话，程序直接访问和操作的都是物理内存，看似少了一层中介，但多了很多问题。</p>
<p><strong>具体有什么问题呢？</strong> 这里举几个例子说明(参考虚拟内存提供的能力回答这个问题)：</p>
<ol>
<li>用户程序可以访问任意物理内存，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。</li>
<li>同时运行多个程序容易崩溃。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。</li>
<li>程序运行过程中使用的所有数据或指令都要载入物理内存，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。</li>
</ol>
<h6 id="什么是虚拟地址和物理地址"><a href="#什么是虚拟地址和物理地址" class="headerlink" title="什么是虚拟地址和物理地址"></a>什么是虚拟地址和物理地址</h6><p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p>
<p>也就是说，我们编程开发的时候实际就是在和虚拟地址打交道。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p>
<p>操作系统一般通过 CPU 芯片中的一个重要组件 <strong>MMU(Memory Management Unit，内存管理单元)</strong> 将虚拟地址转换为物理地址，这个过程被称为 <strong>地址翻译&#x2F;地址转换（Address Translation）</strong> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png" srcset="/img/loading.gif" lazyload alt="地址翻译过程">地址翻译过程</p>
<p>通过 MMU 将虚拟地址转换为物理地址后，再通过总线传到物理内存设备，进而完成相应的物理内存读写请求。</p>
<p>MMU 将虚拟地址翻译为物理地址的主要机制有两种: <strong>分段机制</strong> 和 <strong>分页机制</strong> 。</p>
<h6 id="什么是虚拟地址空间和物理地址空间"><a href="#什么是虚拟地址空间和物理地址空间" class="headerlink" title="什么是虚拟地址空间和物理地址空间"></a>什么是虚拟地址空间和物理地址空间</h6><p>虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。每一个进程都有一个一致且私有的虚拟地址空间。</p>
<p>物理地址空间是物理地址的集合，是物理内存的范围。</p>
<h6 id="虚拟地址空间和内存地址是如何转换的"><a href="#虚拟地址空间和内存地址是如何转换的" class="headerlink" title="虚拟地址空间和内存地址是如何转换的"></a>虚拟地址空间和内存地址是如何转换的</h6><p>MMU 将虚拟地址翻译为物理地址的主要机制有 3 种:</p>
<ol>
<li>分段机制</li>
<li>分页机制</li>
<li>段页机制</li>
</ol>
<p>其中，现代操作系统广泛采用分页机制，需要重点关注！</p>
<h6 id="什么是分段机制"><a href="#什么是分段机制" class="headerlink" title="什么是分段机制"></a>什么是分段机制</h6><p><strong>分段机制（Segmentation）</strong> 以段(—段 <strong>连续</strong> 的物理内存)的形式管理&#x2F;分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</p>
<h6 id="段表有什么用？地址翻译过程是怎样的？"><a href="#段表有什么用？地址翻译过程是怎样的？" class="headerlink" title="段表有什么用？地址翻译过程是怎样的？"></a>段表有什么用？地址翻译过程是怎样的？</h6><p>分段管理通过 <strong>段表（Segment Table）</strong> 映射虚拟地址和物理地址。</p>
<p>分段机制下的虚拟地址由两部分组成：</p>
<ul>
<li><strong>段号</strong>：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li>
<li><strong>段内偏移量</strong>：相对于该段起始地址的偏移量。</li>
</ul>
<p>具体的地址翻译过程如下：</p>
<ol>
<li>MMU 首先解析得到虚拟地址中的段号；</li>
<li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）；</li>
<li>从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-virtual-address-composition.png" srcset="/img/loading.gif" lazyload alt="分段机制下的地址翻译过程">分段机制下的地址翻译过程</p>
<p>段表中还存有诸如段长(可用于检查虚拟地址是否超出合法范围)、段类型（该段的类型，例如代码段、数据段等）等信息。</p>
<p><strong>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？</strong></p>
<p>不一定。段表项可能并不存在：</p>
<ul>
<li><strong>段表项被删除</strong>：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li>
<li><strong>段表项还未创建</strong>：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li>
</ul>
<h6 id="分段机制为什么会导致外部碎片"><a href="#分段机制为什么会导致外部碎片" class="headerlink" title="分段机制为什么会导致外部碎片"></a>分段机制为什么会导致外部碎片</h6><p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p>
<ul>
<li>游戏占用了 512MB 内存</li>
<li>浏览器占用了 128MB 内存</li>
<li>音乐占用了 256 MB 内存。</li>
</ul>
<p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。</p>
<p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6142bc3c917e4a6298bdb62936e0d332.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h6 id="内存分段会出现内存碎片吗？"><a href="#内存分段会出现内存碎片吗？" class="headerlink" title="内存分段会出现内存碎片吗？"></a>内存分段会出现内存碎片吗？</h6><p>内存碎片主要分为，内部内存碎片和外部内存碎片。</p>
<p>内存分段管理可以做到段根据实际需求分配内存，所以有多少需求就分配多大的段，所以<strong>不会出现内部内存碎片</strong>。</p>
<p>但是由于每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载，所以<strong>会出现外部内存碎片</strong>的问题。</p>
<p>解决「外部内存碎片」的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
<h6 id="什么是分页机制"><a href="#什么是分页机制" class="headerlink" title="什么是分页机制"></a>什么是分页机制</h6><p><strong>分页机制（Paging）</strong> 把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p>
<p><strong>注意：这里的页是连续等长的，不同于分段机制下不同长度的段。</strong></p>
<p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理，可有效避免分段机制中外部内存碎片的问题。</p>
<h6 id="页表有什么用？地址翻译过程是怎样的？"><a href="#页表有什么用？地址翻译过程是怎样的？" class="headerlink" title="页表有什么用？地址翻译过程是怎样的？"></a>页表有什么用？地址翻译过程是怎样的？</h6><p>分页管理通过 <strong>页表（Page Table）</strong> 映射虚拟地址和物理地址。我这里画了一张基于单级页表进行地址翻译的示意图。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png" srcset="/img/loading.gif" lazyload alt="单级页表">单级页表</p>
<p>在分页机制下，每个应用程序都会有一个对应的页表。</p>
<p>分页机制下的虚拟地址由两部分组成：</p>
<ul>
<li><strong>页号</strong>：通过虚拟页号可以从页表中取出对应的物理页号；</li>
<li><strong>页内偏移量</strong>：物理页起始地址+页内偏移量&#x3D;物理内存地址。</li>
</ul>
<p>具体的地址翻译过程如下：</p>
<ol>
<li>MMU 首先解析得到虚拟地址中的虚拟页号；</li>
<li>通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）；</li>
<li>用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png" srcset="/img/loading.gif" lazyload alt="分页机制下的地址翻译过程">分页机制下的地址翻译过程</p>
<p>页表中还存有诸如访问标志（标识该页面有没有被访问过）、页类型（该段的类型，例如代码段、数据段等）等信息。</p>
<p><strong>通过虚拟页号一定要找到对应的物理页号吗？找到了物理页号得到最终的物理地址后对应的物理页一定存在吗？</strong></p>
<p>不一定！可能会存在 <strong>页缺失</strong> 。也就是说，物理内存中没有对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射（对应的页表项不存在）。关于页缺失的内容，后面会详细介绍到。</p>
<h6 id="分页机制和分段机制有哪些共同点和区别？"><a href="#分页机制和分段机制有哪些共同点和区别？" class="headerlink" title="分页机制和分段机制有哪些共同点和区别？"></a>分页机制和分段机制有哪些共同点和区别？</h6><p><strong>共同点</strong>：</p>
<ul>
<li>都是非连续内存管理的方式。</li>
<li>都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。</li>
<li>页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</li>
<li>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。</li>
<li>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</li>
<li>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。</li>
</ul>
<h6 id="段页机制"><a href="#段页机制" class="headerlink" title="段页机制"></a>段页机制</h6><p>结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</p>
<p>在段页式机制下，地址翻译的过程分为两个步骤：</p>
<ol>
<li>段式地址映射。</li>
<li>页式地址映射。</li>
</ol>
<h6 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h6><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的 <strong>局部性原理（Locality Principle）</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>
<p>局部性原理是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p>
<p>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：</p>
<ul>
<li><strong>时间局部性</strong>：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。</li>
<li><strong>空间局部性</strong>：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。</li>
</ul>
<p>总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p>
<h5 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h5><h6 id="文件系统的主要作用是什么"><a href="#文件系统的主要作用是什么" class="headerlink" title="文件系统的主要作用是什么"></a>文件系统的主要作用是什么</h6><p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：</p>
<ol>
<li><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。</li>
<li><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</li>
<li><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</li>
<li><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。</li>
</ol>
<h6 id="软连接和硬链接有什么区别"><a href="#软连接和硬链接有什么区别" class="headerlink" title="软连接和硬链接有什么区别"></a>软连接和硬链接有什么区别</h6><p>在 Linux&#x2F;类 Unix 系统上，文件链接（File Link）是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：</p>
<p><strong>1、硬链接（Hard Link）</strong></p>
<ul>
<li>在 Linux&#x2F;类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li>
<li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li>
<li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li>
<li><code>ln</code> 命令用于创建硬链接。</li>
</ul>
<p><strong>2、软链接（Symbolic Link 或 Symlink）</strong></p>
<ul>
<li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li>
<li>源文件删除后，硬链接依然存在，但是指向的是一个无效的文件路径。</li>
<li>软连接类似于 Windows 系统中的快捷方式。</li>
<li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li>
<li><code>ln -s</code> 命令用于创建软链接</li>
</ul>
<h6 id="硬链接为什么不能跨文件系统"><a href="#硬链接为什么不能跨文件系统" class="headerlink" title="硬链接为什么不能跨文件系统"></a>硬链接为什么不能跨文件系统</h6><p>我们之前提到过，硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。</p>
<p>然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</p>
<h6 id="提高文件系统性能的方式有哪些"><a href="#提高文件系统性能的方式有哪些" class="headerlink" title="提高文件系统性能的方式有哪些"></a>提高文件系统性能的方式有哪些</h6><ul>
<li><strong>优化硬件</strong>：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。</li>
<li><strong>选择合适的文件系统选型</strong>：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。</li>
<li><strong>运用缓存</strong>：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。</li>
<li><strong>避免磁盘过度使用</strong>：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。</li>
<li><strong>对磁盘进行合理的分区</strong>：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。</li>
</ul>
<h6 id="常见的磁盘调度算法有哪些"><a href="#常见的磁盘调度算法有哪些" class="headerlink" title="常见的磁盘调度算法有哪些"></a>常见的磁盘调度算法有哪些</h6><h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><p>磁盘调度算法是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。</p>
<p>一次磁盘读写操作的时间由磁盘寻道&#x2F;寻找时间、延迟时间和传输时间决定。磁盘调度算法可以通过改变到达磁盘请求的处理顺序，减少磁盘寻道时间和延迟时间。</p>
<p>常见的磁盘调度算法有下面这 6 种（其他还有很多磁盘调度算法都是基于这些算法改进得来的）：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/disk-scheduling-algorithms.png" srcset="/img/loading.gif" lazyload alt="常见的磁盘调度算法">常见的磁盘调度算法</p>
<ol>
<li><strong>先来先服务算法（First-Come First-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</li>
<li><strong>最短寻道时间优先算法（Shortest Seek Time First，SSTF）</strong>：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</li>
<li><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</li>
<li><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</li>
<li><strong>边扫描边观察算法（LOOK）</strong>：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。</li>
<li><strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</li>
</ol>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><h5 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h5><h6 id="解释一下Linux的名言：“在Linux中，万物皆文件”"><a href="#解释一下Linux的名言：“在Linux中，万物皆文件”" class="headerlink" title="解释一下Linux的名言：“在Linux中，万物皆文件”"></a>解释一下Linux的名言：“在Linux中，万物皆文件”</h6><p>在 Linux 操作系统中，一切被操作系统管理的资源，如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或目录等，都被视为文件。这是 Linux 系统中一个重要的概念，即”一切都是文件”。</p>
<p>这种概念源自 UNIX 哲学，即将所有资源都抽象为文件的方式来进行管理和访问。Linux 的文件系统也借鉴了 UNIX 文件系统的设计理念。这种设计使得 Linux 系统可以通过统一的文件接口来管理和操作不同类型的资源，从而实现了一种统一的文件操作方式。例如，可以使用类似于读写文件的方式来对待网络接口、磁盘驱动器、设备文件等，使得操作和管理这些资源更加统一和简便。</p>
<p>这种文件为中心的设计理念为 Linux 系统带来了灵活性和可扩展性，使得 Linux 成为一种强大的操作系统。同时，这也是 Linux 系统的一大特点，深受广大用户和开发者的喜欢和推崇。</p>
<h6 id="inode是什么"><a href="#inode是什么" class="headerlink" title="inode是什么"></a>inode是什么</h6><p>inode 是 Linux&#x2F;Unix 文件系统的基础。那 inode 到是什么?有什么作用呢?</p>
<p>通过以下五点可以概括 inode 到底是什么：</p>
<ol>
<li>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong>：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 <strong>每个文件都有一个唯一的 inode，存储文件的元信息。</strong></li>
<li>inode 是一种固定大小的数据结构，其大小在文件系统创建时就确定了，并且在文件的生命周期内保持不变。</li>
<li>inode 的访问速度非常快，因为系统可以直接通过 inode 号码定位到文件的元数据信息，无需遍历整个文件系统。</li>
<li>inode 的数量是有限的，每个文件系统只能包含固定数量的 inode。这意味着当文件系统中的 inode 用完时，无法再创建新的文件或目录，即使磁盘上还有可用空间。因此，在创建文件系统时，需要根据文件和目录的预期数量来合理分配 inode 的数量。</li>
<li>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息，包括文件的 inode 号、文件类型、权限、所有者、文件大小、修改时间。</li>
</ol>
<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<p>再总结一下 inode 和 block：</p>
<ul>
<li><strong>inode</strong>：记录文件的属性信息，可以使用 <code>stat</code> 命令查看 inode 信息。</li>
<li><strong>block</strong>：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<p><img src="https://javaguide.cn/assets/%E6%96%87%E4%BB%B6inode%E4%BF%A1%E6%81%AF-d9175a2d.png" srcset="/img/loading.gif" lazyload alt="文件inode信息">文件inode信息</p>
<p>可以看出，Linux&#x2F;Unix 操作系统使用 inode 区分不同的文件。这样做的好处是，即使文件名被修改或删除，文件的 inode 号码不会改变，从而可以避免一些因文件重命名、移动或删除导致的错误。同时，inode 也可以提供更高的文件系统性能，因为 inode 的访问速度非常快，可以直接通过 inode 号码定位到文件的元数据信息，无需遍历整个文件系统。</p>
<p>不过，使用 inode 号码也使得文件系统在用户和应用程序层面更加抽象和复杂，需要通过系统命令或文件系统接口来访问和管理文件的 inode 信息</p>
<h6 id="Linux有哪些文件类型"><a href="#Linux有哪些文件类型" class="headerlink" title="Linux有哪些文件类型"></a>Linux有哪些文件类型</h6><p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong> 等。</p>
<ul>
<li><strong>普通文件（-）</strong>：用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li><strong>目录文件（d，directory file）</strong>：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li><strong>符号链接文件（l，symbolic link）</strong>：保留了指向文件的地址而不是文件本身。</li>
<li><strong>字符设备（c，char）</strong>：用来访问字符设备比如键盘。</li>
<li><strong>设备文件（b，block）</strong>：用来访问块设备比如硬盘、软盘。</li>
<li><strong>管道文件(p，pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>
<li>**套接字文件(s，socket)**：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<p>每种文件类型都有不同的用途和属性，可以通过命令如<code>ls</code>、<code>file</code>等来查看文件的类型信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 普通文件（-）</span><br>-rw-r--r--  1 user  group  1024 Apr 14 10:00 file.txt<br><br><span class="hljs-comment"># 目录文件（d，directory file）*</span><br>drwxr-xr-x  2 user  group  4096 Apr 14 10:00 directory/<br><br><span class="hljs-comment"># 套接字文件(s，socket)</span><br>srwxrwxrwx  1 user  group    0 Apr 14 10:00 socket<br></code></pre></td></tr></table></figure>

<h6 id="Linux目录树"><a href="#Linux目录树" class="headerlink" title="Linux目录树"></a>Linux目录树</h6><p>Linux 使用一种称为目录树的层次结构来组织文件和目录。目录树由根目录（&#x2F;）作为起始点，向下延伸，形成一系列的目录和子目录。每个目录可以包含文件和其他子目录。结构层次鲜明，就像一棵倒立的树。 <img src="/../../../assets/Linux%E7%9B%AE%E5%BD%95%E6%A0%91-b82202fa.png" srcset="/img/loading.gif" lazyload alt="Linux的目录结构"></p>
<p><strong>常见目录说明：</strong></p>
<ul>
<li><strong>&#x2F;bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li>
<li><strong>&#x2F;etc：</strong> 存放系统管理和配置文件；</li>
<li><strong>&#x2F;home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li>
<li><strong>&#x2F;usr：</strong> 用于存放系统应用程序；</li>
<li><strong>&#x2F;opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>
<li><strong>&#x2F;proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>&#x2F;root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>&#x2F;sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>
<li><strong>&#x2F;dev：</strong> 用于存放设备文件；</li>
<li><strong>&#x2F;mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>&#x2F;boot：</strong> 存放用于系统引导时使用的各种文件；</li>
<li><strong>&#x2F;lib 和&#x2F;lib64：</strong> 存放着和系统运行相关的库文件 ；</li>
<li><strong>&#x2F;tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>&#x2F;var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>&#x2F;lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里</li>
</ul>
<h5 id="Linux常见命令"><a href="#Linux常见命令" class="headerlink" title="Linux常见命令"></a>Linux常见命令</h5><p>下面只是给出了一些比较常用的命令。</p>
<p>推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。Linux 命令在线速查手册：<a target="_blank" rel="noopener" href="https://wangchujiang.com/linux-command/">https://wangchujiang.com/linux-command/</a> 。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux/linux-command-search.png" srcset="/img/loading.gif" lazyload alt=" Linux 命令快查"> Linux 命令快查</p>
<p>另外，<a target="_blank" rel="noopener" href="https://www.shell.how/">shell.howopen in new window</a> 这个网站可以用来解释常见命令的意思，对你学习 Linux 基本命令以及其他常用命令（如 Git、NPM）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux/shell-now.png" srcset="/img/loading.gif" lazyload alt="shell.how 使用示例">shell.how 使用示例</p>
<p>目录切换</p>
<ul>
<li><code>cd usr</code>：切换到该目录下 usr 目录</li>
<li><code>cd ..（或cd../）</code>：切换到上一层目录</li>
<li><code>cd /</code>：切换到系统根目录</li>
<li><code>cd ~</code>：切换到用户主目录</li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<p>目录操作</p>
<ul>
<li><code>ls</code>：显示目录中的文件和子目录的列表。例如：<code>ls /home</code>，显示 <code>/home</code> 目录下的文件和子目录列表。</li>
<li><code>ll</code>：<code>ll</code> 是 <code>ls -l</code> 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息</li>
<li><code>mkdir [选项] 目录名</code>：创建新目录（增）。例如：<code>mkdir -m 755 my_directory</code>，创建一个名为 <code>my_directory</code> 的新目录，并将其权限设置为 755，即所有用户对该目录有读、写和执行的权限。</li>
<li><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li>
<li><code>pwd</code>：显示当前工作目录的路径。</li>
<li><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</li>
<li><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</li>
<li><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。例如：<code>cp file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件复制到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>cp -r source destination</code>，将 <code>source</code> 目录及其下的所有子目录和文件复制到 <code>destination</code> 目录下，并保留源文件的属性和目录结构。</li>
<li><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。例如：<code>mv file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件移动到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>mv</code> 与 <code>cp</code> 的结果不同，<code>mv</code> 好像文件“搬家”，文件个数并未增加。而 <code>cp</code> 对文件进行复制，文件个数增加了。</li>
</ul>
<h6 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h6><p><code>cd usr</code>：切换到该目录下 usr 目录</p>
<p><code>cd ..（或cd../）</code>：切换到上一层目录</p>
<p><code>cd /</code>：切换到系统根目录</p>
<p><code>cd ~</code>：切换到用户主目录</p>
<p><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</p>
<h6 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h6><ul>
<li><code>ls</code>：显示目录中的文件和子目录的列表。例如：<code>ls /home</code>，显示 <code>/home</code> 目录下的文件和子目录列表。</li>
<li><code>ll</code>：<code>ll</code> 是 <code>ls -l</code> 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息</li>
<li><code>mkdir [选项] 目录名</code>：创建新目录（增）。例如：<code>mkdir -m 755 my_directory</code>，创建一个名为 <code>my_directory</code> 的新目录，并将其权限设置为 755，即所有用户对该目录有读、写和执行的权限。</li>
<li><code>find [路径] [表达式]</code>：在指定目录及其子目录中搜索文件或目录（查），非常强大灵活。例如：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以 <code>.txt</code> 结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code> ,忽略大小写: <code>find /home -i name &quot;*.txt&quot;</code> ；③ 当前目录及子目录下查找所有以 <code>.txt</code> 和 <code>.pdf</code> 结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;</code>。</li>
<li><code>pwd</code>：显示当前工作目录的路径。</li>
<li><code>rmdir [选项] 目录名</code>：删除空目录（删）。例如：<code>rmdir -p my_directory</code>，删除名为 <code>my_directory</code> 的空目录，并且会递归删除<code>my_directory</code>的空父目录，直到遇到非空目录或根目录。</li>
<li><code>rm [选项] 文件或目录名</code>：删除文件&#x2F;目录（删）。例如：<code>rm -r my_directory</code>，删除名为 <code>my_directory</code> 的目录，<code>-r</code>(recursive,递归) 表示会递归删除指定目录及其所有子目录和文件。</li>
<li><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。例如：<code>cp file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件复制到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>cp -r source destination</code>，将 <code>source</code> 目录及其下的所有子目录和文件复制到 <code>destination</code> 目录下，并保留源文件的属性和目录结构。</li>
<li><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。例如：<code>mv file.txt /home/file.txt</code>，将 <code>file.txt</code> 文件移动到 <code>/home</code> 目录下，并重命名为 <code>file.txt</code>。<code>mv</code> 与 <code>cp</code> 的结果不同，<code>mv</code> 好像文件“搬家”，文件个数并未增加。而 <code>cp</code> 对文件进行复制，文件个数增加了。</li>
</ul>
<h6 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h6><p>像 <code>mv</code>、<code>cp</code>、<code>rm</code> 等文件和目录都适用的命令，这里就不重复列举了。</p>
<ul>
<li><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）。例如：<code>touch file1.txt file2.txt file3.txt</code> ，创建 3 个文件。</li>
<li><code>ln [选项] &lt;源文件&gt; &lt;硬链接/软链接文件&gt;</code>：创建硬链接&#x2F;软链接。例如：<code>ln -s file.txt file_link</code>，创建名为 <code>file_link</code> 的软链接，指向 <code>file.txt</code> 文件。<code>-s</code> 选项代表的就是创建软链接，s 即 symbolic（软链接又名符号链接） 。</li>
<li><code>cat/more/less/tail 文件名</code>：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 Tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li>
<li><code>vim 文件名</code>：修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤：<code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）</li>
</ul>
<h6 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h6><p><strong>1）打包并压缩文件：</strong></p>
<p>Linux 中的打包文件一般是以 <code>.tar</code> 结尾的，压缩的命令一般是以 <code>.gz</code> 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般 <code>.tar.gz</code>。</p>
<p>命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p>
<ul>
<li>z：调用 gzip 压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p>比如：假如 test 目录下有三个文件分别是：<code>aaa.txt</code>、 <code>bbb.txt</code>、<code>ccc.txt</code>，如果我们要打包 <code>test</code> 目录并指定压缩后的压缩包名称为 <code>test.tar.gz</code> 可以使用命令：<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code> 。</p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：<code>tar [-xvf] 压缩文件</code></p>
<p>其中 x 代表解压</p>
<p>示例：</p>
<ul>
<li>将 <code>/test</code> 下的 <code>test.tar.gz</code> 解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code></li>
<li>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下:<code>tar -xvf test.tar.gz -C /usr</code>（<code>-C</code> 代表指定解压的位置）</li>
</ul>
<h6 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h6><ul>
<li><code>scp [选项] 源文件 远程文件</code> （scp 即 secure copy，安全复制）：用于通过 SSH 协议进行安全的文件传输，可以实现从本地到远程主机的上传和从远程主机到本地的下载。例如：<code>scp -r my_directory user@remote:/home/user</code> ，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。<code>scp -r user@remote:/home/user/my_directory</code> ，将远程服务器的 <code>/home/user</code> 目录下的<code>my_directory</code>目录下载到本地。需要注意的是，<code>scp</code> 命令需要在本地和远程系统之间建立 SSH 连接进行文件传输，因此需要确保远程服务器已经配置了 SSH 服务，并且具有正确的权限和认证方式。</li>
<li><code>rsync [选项] 源文件 远程文件</code> : 可以在本地和远程系统之间高效地进行文件复制，并且能够智能地处理增量复制，节省带宽和时间。例如：<code>rsync -r my_directory user@remote:/home/user</code>，将本地目录<code>my_directory</code>上传到远程服务器 <code>/home/user</code> 目录下。</li>
<li><code>ftp</code> (File Transfer Protocol)：提供了一种简单的方式来连接到远程 FTP 服务器并进行文件上传、下载、删除等操作。使用之前需要先连接登录远程 FTP 服务器，进入 FTP 命令行界面后，可以使用 <code>put</code> 命令将本地文件上传到远程主机，可以使用<code>get</code>命令将远程主机的文件下载到本地，可以使用 <code>delete</code> 命令删除远程主机的文件。这里就不进行演示了。</li>
</ul>
<h6 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h6><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p>
<p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk0AAADkBAMAAAB3WA1kAAAAElBMVEUAAACqqqoAAKoAqgD/AAAAqqr31TvxAAAKr0lEQVR42uycbZqjIBCEQ05A3SAPJ/HH3v9Mi72NJQMuhpDomK7dUQboGN/BD+ppvZlMJtO1hWqtq3f2tXAHxDVSG1D2SYu8sxTYVJFj4WA5PEPP18IR62MLtjo5cDt5ZyloU1Vg4WChmxPDG5yAtGA75rVywsc4wUE3K98DPmtqH3caxYMCwCoc2uQAv3FM5ZwgNdpZoYARK04ObHJzACCFRFj3C8CYg8d55RQFj7ypzUmjeFBgCdca/cK1cKlWhOQkC5H+wuYEQgCwiR+2jkwf9orIXDk5QHdKCkg7zsGwzelW5eR3cILC+R8nnrq5nHmBTQ4cu2tw8AM48W/kkcZT3tTizHXGieENTuyjYEtO2fGdcbqBTdDtl5HX4ITbfk5c6ee1OI0fTwDanLCXk/NVTijDGdXmxM5tTvKjv0lh0MUdPOi3r/soQxnFM0QsMXx1zoCvhGNuBzwjnO4f+6RvVXTmWV2jPKSQxpLidIffQJlMJpPJ9A16xX+i+v0nzlKW+xH4y/lPSf3+k9QwEFK4nP+U9Ir/VOF0Pf+JvkKn/yQR1/efFjhAn//EoSYsIZu5nv+08PS9/hPHE7fk/NX8p4VTt/9U53Q1/0nU7z9tcrqa/6R6wX9CldPF/KekLv+Jn1z64+Y/mUwmk8nUI/iXouE7/CeJgmchRuzxn6Tflv8UHrK8vUnOvxaMp3wVRsUFCwKr6T9pvw3/6X5iTlEdnKQDuKO8u236T27h5HyV03hxw3DgzFyNH/0iWVN93zv8p5ITnN/nP7mMk1tzCo95EYdUXAyWGjbIpkh+QYO8aZj/5BLLzL7Z7T8B9J94fro/ZjxhLowfWsl4Wr53wiNjIG+qx3f5T+ysBWCX/8TxpLg5ngTPuznxV+6jlNi0NZyavkqTk/Zq+wUlp9sxnHQ8qRzypmr4QZxYOIJT2k3uS950Q8kJz/tPzv86TnL+xfpM4LIzQdZU4dThP7Ema8Iu/8lt+0/3EOSi94+TyWQymUymvbpQ/tNXPH+XZM/f7eNkz9+9O/+JTQ7cluU/bT5/l08YLf+p9vxd8ZTi5Z6/G5H/hFvB6XLP3w3If6pxutzzd6ohz98x2PKf6s/fWf6TyWQymUy/N//pn9aXcYeND2Sfsob3ltSj2OgZ8nq68p84V+FtITY/kH3KGlfclN3PySmqmxNWnKRlEzzKWKWL2PAZTg6e/tMn8p8YKIBATmQiCEF2sijGmM8J3kOYfx5x8cb8J6HyqfwnDgnFR4ROoou3ySh41sD95BQpPeJ/LQyWAtLV+/OfKAgej/K9a9JETs5zyRrA/eQUQuJEjeREX+UT+U8U1EAq02S4kgI3zxr4glP8+RCnT+U/0QjJOOUZm6zhikXcDuIEwL8//6nkxAI56apxX1A/P4VYeGf+U1x9LP8phWhTNXUetJWYrJrXZMa9Xub0evc9MmfNOA0Rj0rTL9OfPk23L1PnDn8lJ/jnw07sP71FU99mpvP6T0kn43Q6/+k9mvr8p+mk/lOcroQw35LHwlAjaurzn6aT+k8zFUEUBNm4id7U5z9N5/Sf4j8ZRhFSuIcwcDo89flP00n9p5nMXTkJojAI1NTnP00n9Z8KTqOsqKnPf5pO6j+R0+jzU5//NJ3XfwqPIJzS9e768xY8H5JR+Zb5HZ6m9JWcnr/Nvq+ubt/D6VQyTubTJR2e/6RTW4z1n9rvf+JGGV7mqvBdNOFxaF4P5/mj/Kf+9z+RExUWYsdyoocwyH/a+/6nbOZJTlTB6cj8J3Ia6z+13/9ETjSiRJKustyGB72jumvNcflP3PWB/lP7+TtZ5EYUB07QaR05hftDag7Kf+LEfaT/1H7+jtukEVVwmhU4M5bUqGPyn1iFUf5T+3kpfmJuRLU5HZD/NJST7+fkPI2oJqcD85+kcZT/1M0JVU5SIidZHZT/RLdptP/Ufv+TgCmtqaBo+CIoOYc/wpdlRP1l7wqQ44SBGPgF7A8Y//+RPeylwnXbyRwbVkmkGRIfJBei5AzoJCEIgiAIOfoTVf94F5pq+zyCQn+i6R9fivNUvgtPwf3j4AmfgfT+ce/5MZb+8cZP8VNxIL1/3N1cxtI/fnndVexlfv94lyM3Y+kfP3hi7B8/ZVuW/vGDJ8b+8fMXZekfP3hi7B8/NjL1jx88MfaPn0c3lv7xpj+VH5e/EwRBEIQD6frTsm6h/qfvqj+dUhCX/4lPf1ptC83ffQ396Q3/kwuRUf6nWP2p1t3fOk/3P8GKFOF/itWf3FTg7oI0/xN4sqj8Xaz+1PJ3y2tpg5rZ/+TfFpa/C9Wf2vgsGEv0P4GEsPxdmK4CnjzTmel/Agkx/qd4njA/pfufOsVB/qdY/QnHOylSgiAIgvCA/oTrlqT8HS5p5qCdryHQVRrDq+Xk77Bp1lWAwsCTnx/m5e987X95otGfLDV/N/FUcT7e1xD0j2NPE/N3/sF5wtXc7yW/fxw8ZeXvXG2YeHqhVucpv38cu5ySv8NPnXg6xv7/RNA/Dp5y8ncf4Ymhfxw8BehPoTyVfeYpV38ys5T8HTZhn1x2QhHUItlJEARBEL7A/e8MJxEY3PE/OUodZQIGX8/b/ePQjQbD/T3/k4OUp7f8T4NuBJ7u+Z/A04j8/N2d/nHDxT54uul/ctkJRVCvEUP+7u3+cVCEiSrA/9RNT2VH0cpCkb+70z9uF64swv8EG0b9TJ7w8In73426rUX5n+r+FE+P3f/OhpdekP9pqU/x9Nj97wxfHMET5qeJp/z83Y3+cTNzfdwn4gD/E2xPXgQl7UkQBEEQHtKfjKZ//LVmbh0HcnWV1Wj6x8c/NBlPZjT942sUT/H+J7wWCPrHYX+q3qJdhiLyPP8TBCSG/vHx/uZ1r23YBm1Nrv/J+kLQPz7aDr3ftw1QO57kf8Imgv5xfwT9yWvsl77k+p9OLgj6xy/PWmeesv1PRtM/PsxPA0+Yn5L8TxCQOPrH8X5L6fNT2Y9jnmJ3giAIgvCI/gSsG03+7p9g8PXYRpO/+xNMPK220eTvJhDoTxdZhiV/V2r9i+xEkL/ra9P1p+Xif5plJ4L8nV9hseTvXH+ajAXp+TtfTZO/q/skp6TrT5cnoMnfzbJTvv50eQKW/J3rTz4AMvUngCd/dxzmJDv9aucMUiOGYSgqMN5XNzH0Itno/leprCp8MnJJxmqgNP4aPI40ZPHGScgHa2lpaenfqny+oUaP1SwnuBbzmu7/BGHLStp/qjlObcQJynBK9H+KfczT/pOMz36VE93JibOcsKUu6T+NOaFahksHmXNO0X+ypGUOJQqa7v8EYSdd0n8SEapCGjoSxJETafShj408o0c6J8uMOUX/yahooPS7++8iJ+Z0/ych5SSyVY3D6V85tWKcbNKoFZvYcf9d0xhziv6Tfbn/hFLQbP+nyIk/Mv4TOG1SwckXML9yIv/0pDIxRs6N2s+cBv6TzjmWgqb7GkVOWf8JnE7Xk4MxJHagw5ucmMHJ1xNK93Ga91XOOcX7ExmZ79gRXeIU/SdWkQZKQ/9pov/TnZwUEDjF553xcTL9Hr5z8owhAqf4VI7+E25Lh1LkNN3/KfaRyvd/quLrSWTwR4ITLr5iz7w9Q76eiJ7x3lK31HtLKw95v1ucrkkkxYnoIZyWr7L0d/UFD5a7hMwPx0AAAAAASUVORK5CYII=" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="/../../../assets/Linux%E6%9D%83%E9%99%90%E8%A7%A3%E8%AF%BB-7c1098a0.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d：代表目录</li>
<li>-：代表文件</li>
<li>l：代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p><strong>Linux 中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r 也可以用数字 4 表示</li>
<li>w：代表权限是可写，w 也可以用数字 2 表示</li>
<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以使用 cat 查看文件的内容</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以修改文件的内容</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以查看目录下列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以使用 cd 进入目录</td>
</tr>
</tbody></table>
<p>需要注意的是：<strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>
<p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li>**所有者(u)**：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li>
<li>**文件所在组(g)**：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li>
<li>**其它组(o)**：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件&#x2F;目录的权限。</p>
</blockquote>
<p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改&#x2F;test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAg0AAAD2BAMAAACn/KlUAAAAD1BMVEUAAACqqqr/AACqAAAAqgDVR6mAAAAHP0lEQVR42uxdAZKbMAzEzQe8P+j0BZnh/3+r0UI3ruJe7QsTCNo7iCIhX7wRBjbOMQUCgUAgEAgEAoFAILAbANlEMm9mSMglAlhInjor4dEFy5hOAjzzpDyhrFKWt9ibD/IIoKv8FkvxD+ChPF6Lh5SRVfMA/vCwelLxmMGAgZ4qi/wB+aQ8TMjQe70yQx60g7AeFgO+QvAR9VCWJg/A3zwsi3iwWviQ/YJLqx6migf1jR4z8ME8mJk9DynXPMj6gPGh5iGp+4/jAxwPqLPOXQ+YEqpzpLQZm4e8IGsbgh5lleWRB6yeQCAQCAQ+B8kZyKsDpzn4vwBwRsqbI13o4B88GFAJCMBVeVjVJwkIZbnq+CAegBz1sBgpeLg6Dw8CwpV5SJXskO3ZFcfJQCAQeI5fQ/g5fRrGehQ8rFmtM4v8L4lDIn8xlgXNKRjgqs4y0ECHnLIrD8iTR4sd2FofFclopCVwZag2ppHQISPsyUPq50EbQEYjDeCqyrJHGtiDB32ayVSIbYb+tV8g1aVOt59QYRAFjgfWCNO3TtddgjIZ2uYhAWZITuEWQH89IEM8JOj9YajFAzdWqa9eP6HClQNISM2DrQg+UZgd9SFfW7AF3fXAeS5bKsBXT4OhzQCe8ZA9D25ChXvVXNPd5EFDo9aadOEHXgIsk24eRGLKaE17EjwPtngeJs8Dw1jNikrHQ9VzujwpIttlHpoHMKGTBz0oyfPwunoAvuBBsTYPeMoDt5YHPTwwSzygxQMXPqPRxQP5s/bcWQ1DnocEaOOHPXT1+gkVBgA5AWBIxQOOt+IBOgYwa9KIoNCWlUGDtbBxnBDn1XF9ETwED6E/BI6Cbv3BA8hj+gM9+oYHjYb+sC+69QePcf3BPP4ynoAz9kTal4e2/sCsHXjo0R+EAf3Bt5D69QdmmfUS/UHo0R+EEf3Bk48+/UFZYIhcgf0e0h+EXv2BGNEf/K6FTv2BWaqHWu4cud4Ueq67hZHrbj8Wold/YFabB2WeiAcLDegP+9TDkP4wDekPnodB/QENHvr1B2FIf5i69QcHhnr1B/0tr0/W+sOJvkEbCAQCgc/Ha/SH48x/OKX+wFCNS+oP8C1eUX8oIX8+eUH9wULuA9Pr6Q8WcrNArqg/YPI8XFF/eMbD9fQHhZR8Rf1hCYX+EAgEAoETYVh/0GFuXH+AUh1u05c4hP7wiu9fYGpjnr7AcfQH8jCkP/TwcHj9AcsPeRjTH/DQ6fl2n273xaBnXkzzr4zcyha34j6a/pBQfLZCHtMfRGzp4b0QMNMgEfRb9+lYw8fTH0qI7H13/gPf+dt8p0GPee/q+kzXAa+7uVcwND7/wWB9nc0QD0aBHHQdkweGxvSHdj20eZgPpz+44+bo/Ac/PnAHKKZ4KB6Gp/lo+sO68bfnP/jjBXeQ5bE8Z4FYucxlKavLIygwFoKHAg6jb8OvI2F6CU7/RZUfHdsGD/vc/4I86Iipp3siO4M8vO/+Fz+bl9w7Qid5r+WhPF6Lh5ff/8J4YGjxZHNrR2PbANjyyp2u+uuQTiOxtFSfhapRC1u7Zgg/3nD/C9UDQ2y5YG1HPFTyBa/eG6F68gwy/P8WkUM54uFN978QD1vLxbUWmOMhb22jFRIPivvrFBEDt1+84f4XPTwAG62wtEZIPGyF//QrB3qtjof33f+iox7KwiiY4kMkV6meh7F62P/+Fxof/osH2PhHLn3o/3jgopfqeHjP/S+240XaeGA7a5XLgEYn+2VWHWK1SdmQFKz//7DWwlbOyKc+r/7N3tmlKgwDYfQi2UC3cFeSh9n/mhxntEMJKKFRJuk5WhkJQfIRxf7leDjtya0r7l9sPuzL72fpxCcHhxwccnixzPGH/0zg38S/iX8T/yb+TfybBv5NB/+mgX8TAACgF/ybf3gnyWEH/+YT/JsG/k0D7yQ5HMC/GeDfBPgCt+mu5P8Ot+nOpBvk4JCDkyeHtP7NEsUPcsjr35QofpBDXv/miRz8bGYYFOLGh2dT2yuJf7NI1QGLF4bou1L1qUV3DrH+gz7ixoe9qe2Vxr8pupVqhSO2Sfd8OK7/oB8XNz406z9EryT+zSKPAUv1IoKR2p3Dcd0DreKC/72p7ZXEvyn6KLVUKxzxl5M5+Hz4nEMS/2aTw4j5oGixxY0PbQ7a5r2S+DePOfjm76zozCHWf/Ch+Adt0dTmkMS/WWzUVbzwufBIxp7C/2r2L8iBHMiBHLIcn8S/mcB/gX8T/yb+Tfyb+Dfxb+LfxL+JfxMAABYH/2aC4w/4N/Fv4t/Ev4l/E/8m/k38m/g3AQBgcfBv4t/Ev4l/E/8m/k38m/g38W/i37wKRIB/M4l/E2Byxvkv5l6lebz/Ys4TB2/9F9fKYbD/Ys4vxxj/xRLz4bT/YpHvxXn/xcI59PsvFvh9GOO/mHs+3Nu7YxoAABAGghrwbxYPhA5N7iT80LWv/xe9HQib1qXQAQAAuFqK6eakDZMsPAAAAABJRU5ErkJggg==" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本 zookeeper</li>
<li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h6 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h6><p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux 用户管理相关命令:</strong></p>
<ul>
<li><code>useradd [选项] 用户名</code>:创建用户账号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</li>
<li><code>userdel [选项] 用户名</code>:删除用户帐号。</li>
<li><code>usermod [选项] 用户名</code>:修改用户账号的属性和配置比如用户名、用户 ID、家目录。</li>
<li><code>passwd [选项] 用户名</code>: 设置用户的认证信息，包括用户密码、密码过期时间等。。例如：<code>passwd -S 用户名</code> ，显示用户账号密码信息。<code>passwd -d 用户名</code>: 清除用户密码，会导致用户无法登录。<code>passwd 用户名</code>，修改用户密码，随后系统会提示输入新密码并确认密码。</li>
<li><code>su [选项] 用户名</code>（su 即 Switch User，切换用户）：在当前登录的用户和其他用户之间切换身份。</li>
</ul>
<h6 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h6><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>
<p><strong>Linux 系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd [选项] 用户组</code> :增加一个新的用户组。</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组。</li>
<li><code>groupmod [选项] 用户组</code> : 修改用户组的属性</li>
</ul>
<h6 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h6><p><code>top [选项]</code>：用于实时查看系统的 CPU 使用率、内存使用率、进程信息等。</p>
<p><code>htop [选项]</code>：类似于 <code>top</code>，但提供了更加交互式和友好的界面，可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>
<p><code>uptime [选项]</code>：用于查看系统总共运行了多长时间、系统的平均负载等信息。</p>
<p><code>vmstat [间隔时间] [重复次数]</code>：vmstat （Virtual Memory Statistics） 的含义为显示虚拟内存状态，但是它可以报告关于进程、内存、I&#x2F;O 等系统整体运行状态。</p>
<p><code>free [选项]</code>：用于查看系统的内存使用情况，包括已用内存、可用内存、缓冲区和缓存等。</p>
<p><code>df [选项] [文件系统]</code>：用于查看系统的磁盘空间使用情况，包括磁盘空间的总量、已使用量和可用量等，可以指定文件系统上。例如：<code>df -a</code>，查看全部文件系统。</p>
<p><code>du [选项] [文件]</code>：用于查看指定目录或文件的磁盘空间使用情况，可以指定不同的选项来控制输出格式和单位。</p>
<p><code>sar [选项] [时间间隔] [重复次数]</code>：用于收集、报告和分析系统的性能统计信息，包括系统的 CPU 使用、内存使用、磁盘 I&#x2F;O、网络活动等详细信息。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。</p>
<p><code>ps [选项]</code>：用于查看系统中的进程信息，包括进程的 ID、状态、资源使用情况等。<code>ps -ef</code>&#x2F;<code>ps -aux</code>：这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p><code>systemctl [命令] [服务名称]</code>：用于管理系统的服务和单元，可以查看系统服务的状态、启动、停止、重启等。</p>
<h6 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h6><ul>
<li><code>ping [选项] 目标主机</code>：测试与目标主机的网络连接。</li>
<li><code>ifconfig</code> 或 <code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</li>
<li><code>netstat [选项]</code>：用于查看系统的网络连接状态和网络统计信息，可以查看当前的网络连接情况、监听端口、网络协议等。</li>
<li><code>ss [选项]</code>：比 <code>netstat</code> 更好用，提供了更快速、更详细的网络连接信息</li>
</ul>
<h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ul>
<li><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</li>
<li><code>grep 要搜索的字符串 要搜索的文件 --color</code>：搜索命令，–color 代表高亮显示。</li>
<li><code>kill -9 进程的pid</code>：杀死进程（-9 表示强制终止）先用 ps 查找进程，然后用 kill 杀掉。</li>
<li><code>shutdown</code>：<code>shutdown -h now</code>：指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</li>
<li><code>reboot</code>：<code>reboot</code>：重开机。<code>reboot -w</code>：做个重开机的模拟（只有纪录并不会真的重开机）。</li>
</ul>
<h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><h6 id="环境变量查看"><a href="#环境变量查看" class="headerlink" title="环境变量查看"></a>环境变量查看</h6><p>通过 <code>export</code> 命令可以输出当前系统定义的所有环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出当前的环境变量值</span><br><span class="hljs-built_in">export</span> -p<br></code></pre></td></tr></table></figure>

<p>除了 <code>export</code> 命令之外， <code>env</code> 命令也可以列出所有环境变量。</p>
<p><code>echo</code> 命令可以输出指定环境变量的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出当前的PATH环境变量的值</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 输出当前的HOME环境变量的值</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span><br></code></pre></td></tr></table></figure>

<h6 id="环境变量修改"><a href="#环境变量修改" class="headerlink" title="环境变量修改"></a>环境变量修改</h6><p>通过 <code>export</code>命令可以修改指定的环境变量。不过，这种方式修改环境变量仅仅对当前 shell 终端生效，关闭 shell 终端就会失效。修改完成之后，立即生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> CLASSPATH=./JAVA_HOME/lib;<span class="hljs-variable">$JAVA_HOME</span>/jre/lib<br></code></pre></td></tr></table></figure>

<p>通过 <code>vim</code> 命令修改环境变量配置文件。这种方式修改环境变量永久有效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim ~/.bash_profile<br></code></pre></td></tr></table></figure>

<p>如果修改的是系统级别环境变量则对所有用户生效，如果修改的是用户级别环境变量则仅对当前用户生效。</p>
<p>修改完成之后，需要 <code>source</code> 命令让其生效或者关闭 shell 终端重新登录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure>














                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Mysql/">#Mysql</a>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF/">#后端</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">#数据库</a>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/JDBC/">#JDBC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面经</div>
      <div>https://swustcoder.github.io/2023/12/26/面经/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Yang Qiu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/07/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/" title="Linux操作命令">
                        <span class="hidden-mobile">Linux操作命令</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
    <div class="statistics">
  
  

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
